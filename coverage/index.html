<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","challenger-air","src","main.rs"],"content":"pub fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":1,"address":[401792,401760],"length":1,"stats":{"Line":1}},{"line":2,"address":[401796],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","examples","allocation_log.rs"],"content":"//! An example to show how the allocation log works.\n//!\n//! *NOTE*: The example must be run in debug mode or with a custom profile\n//! that enables debug_assertions, and with `RUST_LOG=DEBUG` for tracing.\n\nuse p3_baby_bear::BabyBear;\nuse p3_circuit::CircuitBuilder;\nuse p3_field::PrimeCharacteristicRing;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\nfn main() {\n    init_logger();\n\n    println!(\"Building a simple circuit to demonstrate the allocation log...\\n\");\n\n    let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n    // Build a simple circuit: (a + b * c) * (a - b) / 2\n    println!(\"Creating circuit: result = (a + b * c) * (a - b) / 2\\n\");\n\n    let a = builder.alloc_public_input(\"input_a\");\n    let b = builder.alloc_public_input(\"input_b\");\n    let c = builder.alloc_public_input(\"input_c\");\n\n    let two = builder.alloc_const(BabyBear::TWO, \"2\");\n\n    let _two_bis = builder.alloc_const(BabyBear::TWO, \"2 bis\"); // should be ignored\n\n    let bc = builder.alloc_mul(b, c, \"b_times_c\");\n    let sum = builder.alloc_add(a, bc, \"a_plus_bc\");\n    let diff = builder.alloc_sub(a, bc, \"a_minus_bc\");\n    let product = builder.alloc_mul(sum, diff, \"sum_times_diff\");\n    let _result = builder.alloc_div(product, two, \"final_result\");\n\n    builder.dump_allocation_log();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","alloc_entry.rs"],"content":"//! Module defining allocation entries for debugging purposes.\n//! These complement circuit building by logging all allocations happening\n//! within the expression graph.\n\nuse alloc::format;\nuse alloc::string::{String, ToString};\nuse alloc::vec::Vec;\n\nuse hashbrown::HashSet;\n\nuse crate::ExprId;\nuse crate::op::NonPrimitiveOpType;\n\n/// Type of allocation for debugging purposes\n#[derive(Debug, Clone)]\npub enum AllocationType {\n    Public,\n    Const,\n    Add,\n    Sub,\n    Mul,\n    Div,\n    NonPrimitiveOp(NonPrimitiveOpType),\n    NonPrimitiveOutput,\n    WitnessHint,\n}\n\n/// Detailed allocation entry for debugging\n#[derive(Debug, Clone)]\npub struct AllocationEntry {\n    /// The expression ID allocated\n    pub expr_id: ExprId,\n    /// Type of allocation\n    pub alloc_type: AllocationType,\n    /// User-provided label (if any)\n    pub label: \u0026'static str,\n    /// Dependencies for this entry, i.e. the expressions that this entry depends on.\n    pub dependencies: Vec\u003cVec\u003cExprId\u003e\u003e,\n    /// Scope/sub-circuit this allocation belongs to (if any)\n    pub scope: Option\u003c\u0026'static str\u003e,\n}\n\n/// Dump an allocation log (debug builds only).\n///\n/// Shows all allocations with their types, labels, and dependencies,\n/// grouped by allocation type.\npub(crate) fn dump_allocation_log(allocation_log: \u0026[AllocationEntry]) {\n    tracing::debug!(\"=== Circuit Allocation Log ===\");\n    tracing::debug!(\"Total allocations: {}\\n\", allocation_log.len());\n\n    let all_scopes = list_scopes(allocation_log);\n\n    for scope in all_scopes {\n        dump_allocation_log_scope(allocation_log, Some(scope));\n    }\n\n    // Dump also allocations that do not fall under a particular scope\n    dump_allocation_log_scope(allocation_log, None);\n\n    tracing::debug!(\"=== End Allocation Log ===\\n\");\n}\n\n/// Dump an allocation log filtered by scope (debug builds only).\n///\n/// Shows only allocations within the specified scope, grouped by allocation type.\npub(crate) fn dump_allocation_log_scope(allocation_log: \u0026[AllocationEntry], scope: Option\u003c\u0026str\u003e) {\n    let filtered: Vec\u003c_\u003e = allocation_log\n        .iter()\n        .filter(|e| e.scope == scope)\n        .cloned()\n        .collect();\n\n    let scope_name = scope.unwrap_or(\"main\");\n\n    if filtered.is_empty() {\n        tracing::debug!(\"\\nScope '{}' has no allocations\\n\", scope_name);\n        return;\n    }\n\n    tracing::debug!(\"=== Allocation Log for scope '{}' ===\", scope_name);\n    tracing::debug!(\"Total allocations in scope: {}\\n\", filtered.len());\n\n    dump_internal_log(\u0026filtered);\n\n    tracing::debug!(\"=== End Scope Log ===\\n\");\n}\n\nfn dump_internal_log(allocation_log: \u0026[AllocationEntry]) {\n    // Group by type\n    let mut publics = Vec::new();\n    let mut consts = Vec::new();\n    let mut adds = Vec::new();\n    let mut subs = Vec::new();\n    let mut muls = Vec::new();\n    let mut divs = Vec::new();\n    let mut non_primitives = Vec::new();\n    let mut witness_hints = Vec::new();\n\n    fn display_label(label: \u0026str) -\u003e String {\n        if label.is_empty() {\n            \"\".to_string()\n        } else {\n            format!(\": {label}\")\n        }\n    }\n\n    for entry in allocation_log {\n        match entry.alloc_type {\n            AllocationType::Public =\u003e publics.push(entry),\n            AllocationType::Const =\u003e consts.push(entry),\n            AllocationType::Add =\u003e adds.push(entry),\n            AllocationType::Sub =\u003e subs.push(entry),\n            AllocationType::Mul =\u003e muls.push(entry),\n            AllocationType::Div =\u003e divs.push(entry),\n            AllocationType::NonPrimitiveOp(_) | AllocationType::NonPrimitiveOutput =\u003e {\n                non_primitives.push(entry);\n            }\n            AllocationType::WitnessHint =\u003e witness_hints.push(entry),\n        }\n    }\n\n    // Dump all operations per group\n\n    if !publics.is_empty() {\n        tracing::debug!(\"--- Public Inputs ({}) ---\", publics.len());\n        for entry in publics {\n            tracing::debug!(\n                \"  expr_{} (Public){}\",\n                entry.expr_id.0,\n                display_label(entry.label)\n            );\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !consts.is_empty() {\n        tracing::debug!(\"--- Constants ({}) ---\", consts.len());\n        for entry in consts {\n            tracing::debug!(\n                \"  expr_{} (Const){}\",\n                entry.expr_id.0,\n                display_label(entry.label)\n            );\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !adds.is_empty() {\n        tracing::debug!(\"--- Additions ({}) ---\", adds.len());\n        for entry in adds {\n            if entry.dependencies.len() == 2 {\n                tracing::debug!(\n                    \"  expr_{} = expr_{} + expr_{}{}\",\n                    entry.expr_id.0,\n                    entry.dependencies[0][0].0,\n                    entry.dependencies[1][0].0,\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\n                    \"  expr_{} (Add){}\",\n                    entry.expr_id.0,\n                    display_label(entry.label)\n                );\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !subs.is_empty() {\n        tracing::debug!(\"--- Subtractions ({}) ---\", subs.len());\n        for entry in subs {\n            if entry.dependencies.len() == 2 {\n                tracing::debug!(\n                    \"  expr_{} = expr_{} - expr_{}{}\",\n                    entry.expr_id.0,\n                    entry.dependencies[0][0].0,\n                    entry.dependencies[1][0].0,\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\n                    \"  expr_{} (Sub){}\",\n                    entry.expr_id.0,\n                    display_label(entry.label)\n                );\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !muls.is_empty() {\n        tracing::debug!(\"--- Multiplications ({}) ---\", muls.len());\n        for entry in muls {\n            if entry.dependencies.len() == 2 {\n                tracing::debug!(\n                    \"  expr_{} = expr_{} * expr_{}{}\",\n                    entry.expr_id.0,\n                    entry.dependencies[0][0].0,\n                    entry.dependencies[1][0].0,\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\n                    \"  expr_{} (Mul){}\",\n                    entry.expr_id.0,\n                    display_label(entry.label)\n                );\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !divs.is_empty() {\n        tracing::debug!(\"--- Divisions ({}) ---\", divs.len());\n        for entry in divs {\n            if entry.dependencies.len() == 2 {\n                tracing::debug!(\n                    \"  expr_{} = expr_{} / expr_{}{}\",\n                    entry.expr_id.0,\n                    entry.dependencies[0][0].0,\n                    entry.dependencies[1][0].0,\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\n                    \"  expr_{} (Div){}\",\n                    entry.expr_id.0,\n                    display_label(entry.label)\n                );\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !non_primitives.is_empty() {\n        tracing::debug!(\n            \"--- Non-Primitive Operations ({}) ---\",\n            non_primitives.len()\n        );\n        for entry in non_primitives {\n            let op_name = match \u0026entry.alloc_type {\n                AllocationType::NonPrimitiveOp(op_type) =\u003e format!(\"{op_type:?}\").to_string(),\n                AllocationType::NonPrimitiveOutput =\u003e \"NonPrimitiveOutput\".to_string(),\n                _ =\u003e \"Unknown\".to_string(),\n            };\n            if !entry.dependencies.is_empty() {\n                let deps: Vec\u003c_\u003e = entry\n                    .dependencies\n                    .iter()\n                    .flatten()\n                    .map(|e| format!(\"expr_{}\", e.0))\n                    .collect();\n                tracing::debug!(\n                    \"  {} (inputs: [{}]){}\",\n                    op_name,\n                    deps.join(\", \"),\n                    display_label(entry.label)\n                );\n            } else {\n                tracing::debug!(\"  {}{}\", op_name, display_label(entry.label));\n            }\n        }\n        tracing::debug!(\"\");\n    }\n\n    if !witness_hints.is_empty() {\n        tracing::debug!(\"--- Witness Hints ({}) ---\", witness_hints.len());\n        for entry in witness_hints {\n            tracing::debug!(\n                \"  expr_{} (WitnessHint){}\",\n                entry.expr_id.0,\n                display_label(entry.label)\n            );\n        }\n        tracing::debug!(\"\");\n    }\n}\n\n/// List all unique scopes present in the allocation log.\npub(crate) fn list_scopes(allocation_log: \u0026[AllocationEntry]) -\u003e Vec\u003c\u0026'static str\u003e {\n    let mut scopes = HashSet::new();\n    for entry in allocation_log {\n        if let Some(scope) = entry.scope {\n            scopes.insert(scope);\n        }\n    }\n\n    let mut scope_list: Vec\u003c_\u003e = scopes.into_iter().collect();\n    scope_list.sort_unstable();\n    scope_list\n}\n","traces":[{"line":47,"address":[3891808,3893342,3893348],"length":1,"stats":{"Line":2}},{"line":48,"address":[4008017,4008194],"length":1,"stats":{"Line":2}},{"line":49,"address":[5199150,5198946,5199418],"length":1,"stats":{"Line":4}},{"line":51,"address":[3143985],"length":1,"stats":{"Line":2}},{"line":53,"address":[2645647,2645183,2645564],"length":1,"stats":{"Line":9}},{"line":54,"address":[3887496,3887913],"length":1,"stats":{"Line":3}},{"line":58,"address":[10995130],"length":1,"stats":{"Line":2}},{"line":60,"address":[4009139,4009319],"length":1,"stats":{"Line":2}},{"line":66,"address":[5200480,5203001,5202995],"length":1,"stats":{"Line":3}},{"line":69,"address":[2648945,2646387,2648928],"length":1,"stats":{"Line":9}},{"line":73,"address":[4009838,4009953],"length":1,"stats":{"Line":6}},{"line":75,"address":[10995969],"length":1,"stats":{"Line":3}},{"line":76,"address":[3888436,3890365,3890123],"length":1,"stats":{"Line":0}},{"line":80,"address":[10594290,10593994,10593928],"length":1,"stats":{"Line":6}},{"line":81,"address":[3145795,3146394,3146091],"length":1,"stats":{"Line":6}},{"line":83,"address":[8090971,8090628],"length":1,"stats":{"Line":6}},{"line":85,"address":[2647890,2648161],"length":1,"stats":{"Line":2}},{"line":88,"address":[3863284,3860224,3884791],"length":1,"stats":{"Line":3}},{"line":90,"address":[3981893],"length":1,"stats":{"Line":2}},{"line":91,"address":[10968006],"length":1,"stats":{"Line":2}},{"line":92,"address":[10968051],"length":1,"stats":{"Line":2}},{"line":93,"address":[2618756],"length":1,"stats":{"Line":3}},{"line":94,"address":[5172965],"length":1,"stats":{"Line":3}},{"line":95,"address":[3866070],"length":1,"stats":{"Line":3}},{"line":96,"address":[5173095],"length":1,"stats":{"Line":3}},{"line":97,"address":[3117832],"length":1,"stats":{"Line":3}},{"line":99,"address":[3117072],"length":1,"stats":{"Line":0}},{"line":100,"address":[5172427],"length":1,"stats":{"Line":0}},{"line":101,"address":[3865605],"length":1,"stats":{"Line":0}},{"line":103,"address":[3860062],"length":1,"stats":{"Line":0}},{"line":107,"address":[8062185,8062274],"length":1,"stats":{"Line":6}},{"line":108,"address":[3861060],"length":1,"stats":{"Line":3}},{"line":109,"address":[2642620,2642837],"length":1,"stats":{"Line":5}},{"line":110,"address":[10992010,10992202],"length":1,"stats":{"Line":5}},{"line":111,"address":[8085768,8085935],"length":1,"stats":{"Line":6}},{"line":112,"address":[7165065,7165179],"length":1,"stats":{"Line":4}},{"line":113,"address":[3890041,3889921],"length":1,"stats":{"Line":4}},{"line":114,"address":[3141580,3141678],"length":1,"stats":{"Line":2}},{"line":116,"address":[4006151,4006227],"length":1,"stats":{"Line":0}},{"line":118,"address":[3890056,3890002],"length":1,"stats":{"Line":0}},{"line":124,"address":[5173480],"length":1,"stats":{"Line":2}},{"line":125,"address":[7142465,7142134,7142074],"length":1,"stats":{"Line":4}},{"line":126,"address":[10567498,10566984,10567355],"length":1,"stats":{"Line":6}},{"line":127,"address":[10970528],"length":1,"stats":{"Line":2}},{"line":133,"address":[3862091],"length":1,"stats":{"Line":2}},{"line":136,"address":[5175681,5173547],"length":1,"stats":{"Line":4}},{"line":137,"address":[7144609,7144278,7144218],"length":1,"stats":{"Line":6}},{"line":138,"address":[3266866,3266723,3266352],"length":1,"stats":{"Line":8}},{"line":139,"address":[8065537,8066091,8066455],"length":1,"stats":{"Line":2}},{"line":145,"address":[10569779],"length":1,"stats":{"Line":2}},{"line":148,"address":[2623699,2621571],"length":1,"stats":{"Line":4}},{"line":149,"address":[3871288,3870889,3870953],"length":1,"stats":{"Line":4}},{"line":150,"address":[3122850,3123221,3123364],"length":1,"stats":{"Line":7}},{"line":151,"address":[5178755,5179301],"length":1,"stats":{"Line":6}},{"line":152,"address":[3124378],"length":1,"stats":{"Line":2}},{"line":160,"address":[7149144],"length":1,"stats":{"Line":0}},{"line":167,"address":[3988012],"length":1,"stats":{"Line":3}},{"line":170,"address":[2623733,2626900],"length":1,"stats":{"Line":4}},{"line":171,"address":[3990266,3990665,3990330],"length":1,"stats":{"Line":4}},{"line":172,"address":[5181893,5181750,5181379],"length":1,"stats":{"Line":3}},{"line":173,"address":[3875542,3874996],"length":1,"stats":{"Line":2}},{"line":174,"address":[10576196],"length":1,"stats":{"Line":0}},{"line":182,"address":[8071480,8072493,8072857],"length":1,"stats":{"Line":0}},{"line":189,"address":[5181997],"length":1,"stats":{"Line":1}},{"line":192,"address":[3990294,3993461],"length":1,"stats":{"Line":4}},{"line":193,"address":[3128923,3128987,3129322],"length":1,"stats":{"Line":2}},{"line":194,"address":[7152995,7153358,7153493],"length":1,"stats":{"Line":3}},{"line":195,"address":[5185157,5185703],"length":1,"stats":{"Line":2}},{"line":196,"address":[3878749,3878815,3879348],"length":1,"stats":{"Line":0}},{"line":204,"address":[8074681,8075694,8076058],"length":1,"stats":{"Line":0}},{"line":211,"address":[10578334],"length":1,"stats":{"Line":1}},{"line":214,"address":[10577415,10580582],"length":1,"stats":{"Line":4}},{"line":215,"address":[5187851,5187516,5187452],"length":1,"stats":{"Line":2}},{"line":216,"address":[3881335,3880821,3881192],"length":1,"stats":{"Line":3}},{"line":217,"address":[8077302,8077848],"length":1,"stats":{"Line":2}},{"line":218,"address":[3134134],"length":1,"stats":{"Line":0}},{"line":226,"address":[3280620],"length":1,"stats":{"Line":0}},{"line":233,"address":[7156746],"length":1,"stats":{"Line":1}},{"line":236,"address":[10583783,10580616],"length":1,"stats":{"Line":4}},{"line":237,"address":[3878713],"length":1,"stats":{"Line":0}},{"line":241,"address":[8079926,8080297,8080440],"length":1,"stats":{"Line":0}},{"line":242,"address":[7159870],"length":1,"stats":{"Line":0}},{"line":243,"address":[3136931,3136851],"length":1,"stats":{"Line":0}},{"line":244,"address":[2638081,2638331],"length":1,"stats":{"Line":0}},{"line":245,"address":[7160444,7160772],"length":1,"stats":{"Line":0}},{"line":247,"address":[10585593,10585666],"length":1,"stats":{"Line":0}},{"line":248,"address":[3880160],"length":1,"stats":{"Line":0}},{"line":252,"address":[7166176,7160979,7166220],"length":1,"stats":{"Line":0}},{"line":254,"address":[3880852],"length":1,"stats":{"Line":0}},{"line":261,"address":[4002967,4001787],"length":1,"stats":{"Line":0}},{"line":264,"address":[7159947],"length":1,"stats":{"Line":0}},{"line":267,"address":[7159020,7162707],"length":1,"stats":{"Line":4}},{"line":268,"address":[3887532,3887478,3887867],"length":1,"stats":{"Line":0}},{"line":269,"address":[8084072,8084215,8083701],"length":1,"stats":{"Line":0}},{"line":270,"address":[3140003,3140799,3140496],"length":1,"stats":{"Line":0}},{"line":276,"address":[5195381],"length":1,"stats":{"Line":0}},{"line":281,"address":[8061253,8060704,8061309],"length":1,"stats":{"Line":3}},{"line":282,"address":[10564939],"length":1,"stats":{"Line":3}},{"line":283,"address":[3859459,3859531],"length":1,"stats":{"Line":6}},{"line":284,"address":[3262356,3262656],"length":1,"stats":{"Line":5}},{"line":285,"address":[10967560],"length":1,"stats":{"Line":2}},{"line":289,"address":[3981269],"length":1,"stats":{"Line":3}},{"line":290,"address":[7140782,7140853],"length":1,"stats":{"Line":7}},{"line":291,"address":[3859874],"length":1,"stats":{"Line":4}}],"covered":74,"coverable":104},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","circuit_builder.rs"],"content":"use alloc::sync::Arc;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::hash::Hash;\nuse core::marker::PhantomData;\n\nuse hashbrown::HashMap;\nuse itertools::zip_eq;\nuse p3_field::{ExtensionField, Field, PrimeCharacteristicRing, PrimeField64};\nuse p3_symmetric::Permutation;\nuse p3_util::log2_ceil_u64;\n\nuse super::compiler::{ExpressionLowerer, Optimizer};\nuse super::{BuilderConfig, ExpressionBuilder, PublicInputTracker};\nuse crate::circuit::Circuit;\nuse crate::op::{DefaultHint, NonPrimitiveOpType, Poseidon2PermConfig, WitnessHintsFiller};\nuse crate::tables::{Poseidon2Params, TraceGeneratorFn};\nuse crate::types::{ExprId, NonPrimitiveOpId, WitnessAllocator, WitnessId};\nuse crate::{CircuitBuilderError, CircuitError, CircuitField};\n\n/// Builder for constructing circuits.\npub struct CircuitBuilder\u003cF\u003e {\n    /// Expression graph builder\n    expr_builder: ExpressionBuilder\u003cF\u003e,\n\n    /// Public input tracker\n    public_tracker: PublicInputTracker,\n\n    /// Witness index allocator\n    witness_alloc: WitnessAllocator,\n\n    /// Non-primitive operations (complex constraints that don't produce `ExprId`s)\n    non_primitive_ops: Vec\u003cNonPrimitiveOperationData\u003e,\n\n    /// Builder configuration\n    config: BuilderConfig\u003cF\u003e,\n\n    /// Registered non-primitive trace generators.\n    non_primitive_trace_generators: HashMap\u003cNonPrimitiveOpType, TraceGeneratorFn\u003cF\u003e\u003e,\n}\n\n/// Per-op extra parameters that are not encoded in the op type.\n#[derive(Debug, Clone)]\npub enum NonPrimitiveOpParams {\n    Poseidon2Perm { new_start: bool, merkle_path: bool },\n}\n\n/// The non-primitive operation id, type, the vectors of the expressions representing its inputs\n/// and outputs, and any per-op parameters.\n#[derive(Debug, Clone)]\npub struct NonPrimitiveOperationData {\n    pub op_id: NonPrimitiveOpId,\n    pub op_type: NonPrimitiveOpType,\n    /// Input expressions (e.g., for Poseidon2Perm: [in0, in1, in2, in3, mmcs_index_sum, mmcs_bit])\n    pub input_exprs: Vec\u003cVec\u003cExprId\u003e\u003e,\n    /// Output expressions (e.g., for Poseidon2Perm: [out0, out1])\n    pub output_exprs: Vec\u003cVec\u003cExprId\u003e\u003e,\n    pub params: Option\u003cNonPrimitiveOpParams\u003e,\n}\n\nimpl\u003cF\u003e Default for CircuitBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + Hash,\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cF\u003e CircuitBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + Hash,\n{\n    /// Creates a new circuit builder.\n    pub fn new() -\u003e Self {\n        Self {\n            expr_builder: ExpressionBuilder::new(),\n            public_tracker: PublicInputTracker::new(),\n            witness_alloc: WitnessAllocator::new(),\n            non_primitive_ops: Vec::new(),\n            config: BuilderConfig::new(),\n            non_primitive_trace_generators: HashMap::new(),\n        }\n    }\n\n    /// Enables a non-primitive operation type on this builder.\n    pub fn enable_op(\u0026mut self, op: NonPrimitiveOpType, cfg: crate::op::NonPrimitiveOpConfig\u003cF\u003e) {\n        self.config.enable_op(op, cfg);\n    }\n\n    /// Enables Poseidon2 permutation operations (one perm per table row).\n    ///\n    /// The current implementation only supports extension degree D=4 and WIDTH=16.\n    ///\n    /// # Arguments\n    /// * `trace_generator` - Function to generate Poseidon2 trace from circuit and witness\n    /// * `perm` - The Poseidon2 permutation to use for execution\n    pub fn enable_poseidon2_perm\u003cConfig, P\u003e(\n        \u0026mut self,\n        trace_generator: TraceGeneratorFn\u003cF\u003e,\n        perm: P,\n    ) where\n        Config: Poseidon2Params,\n        F: CircuitField + ExtensionField\u003cConfig::BaseField\u003e,\n        P: Permutation\u003c[Config::BaseField; 16]\u003e + Clone + Send + Sync + 'static,\n    {\n        // Hard gate on D=4 and WIDTH=16 to avoid silently accepting incompatible configs.\n        assert!(\n            Config::D == 4,\n            \"Poseidon2 perm op only supports extension degree D=4\"\n        );\n        assert!(\n            Config::WIDTH == 16,\n            \"Poseidon2 perm op only supports WIDTH=16\"\n        );\n\n        // Build exec closure that:\n        // 1. Converts [F;4] extension limbs to [Base;16] using basis coefficients\n        // 2. Calls perm.permute([Base;16])\n        // 3. Converts output [Base;16] back to [F;4]\n        let exec: crate::op::Poseidon2PermExec\u003cF\u003e = Arc::new(move |input: \u0026[F; 4]| {\n            // Convert 4 extension elements to 16 base elements\n            let mut base_input = [Config::BaseField::ZERO; 16];\n            for (i, ext_elem) in input.iter().enumerate() {\n                let coeffs = ext_elem.as_basis_coefficients_slice();\n                debug_assert_eq!(\n                    coeffs.len(),\n                    4,\n                    \"Extension field should have D=4 basis coefficients\"\n                );\n                base_input[i * 4..(i + 1) * 4].copy_from_slice(coeffs);\n            }\n\n            // Apply permutation\n            let base_output = perm.permute(base_input);\n\n            // Convert 16 base elements back to 4 extension elements\n            let mut output = [F::ZERO; 4];\n            for i in 0..4 {\n                let coeffs = \u0026base_output[i * 4..(i + 1) * 4];\n                output[i] = F::from_basis_coefficients_slice(coeffs)\n                    .expect(\"basis coefficients should be valid\");\n            }\n            output\n        });\n\n        self.config.enable_op(\n            NonPrimitiveOpType::Poseidon2Perm,\n            crate::op::NonPrimitiveOpConfig::Poseidon2Perm(Poseidon2PermConfig { exec }),\n        );\n        self.non_primitive_trace_generators\n            .insert(NonPrimitiveOpType::Poseidon2Perm, trace_generator);\n    }\n\n    /// Checks whether an op type is enabled on this builder.\n    fn is_op_enabled(\u0026self, op: \u0026NonPrimitiveOpType) -\u003e bool {\n        self.config.is_op_enabled(op)\n    }\n\n    pub(crate) fn ensure_op_enabled(\n        \u0026self,\n        op: NonPrimitiveOpType,\n    ) -\u003e Result\u003c(), CircuitBuilderError\u003e {\n        if !self.is_op_enabled(\u0026op) {\n            return Err(CircuitBuilderError::OpNotAllowed { op });\n        }\n        Ok(())\n    }\n\n    /// Adds a public input to the circuit.\n    ///\n    /// Cost: 1 row in Public table + 1 row in witness table.\n    pub fn add_public_input(\u0026mut self) -\u003e ExprId {\n        self.alloc_public_input(\"\")\n    }\n\n    /// Allocates a public input with a descriptive label.\n    ///\n    /// The label is logged in debug builds for easier debugging of public input ordering.\n    ///\n    /// Cost: 1 row in Public table + 1 row in witness table.\n    pub fn alloc_public_input(\u0026mut self, label: \u0026'static str) -\u003e ExprId {\n        let pos = self.public_tracker.alloc();\n        self.expr_builder.add_public(pos, label)\n    }\n\n    /// Allocates multiple public inputs with a descriptive label.\n    pub fn alloc_public_inputs(\u0026mut self, count: usize, label: \u0026'static str) -\u003e Vec\u003cExprId\u003e {\n        (0..count).map(|_| self.alloc_public_input(label)).collect()\n    }\n\n    /// Allocates a fixed-size array of public inputs with a descriptive label.\n    pub fn alloc_public_input_array\u003cconst N: usize\u003e(\u0026mut self, label: \u0026'static str) -\u003e [ExprId; N] {\n        core::array::from_fn(|_| self.alloc_public_input(label))\n    }\n\n    /// Returns the current public input count.\n    pub const fn public_input_count(\u0026self) -\u003e usize {\n        self.public_tracker.count()\n    }\n\n    /// Allocates a sequence of witness hints.\n    /// Each hint is a placeholder whose values will later be provided by the given `filler`.\n    #[must_use]\n    pub fn alloc_witness_hints\u003cW: 'static + WitnessHintsFiller\u003cF\u003e\u003e(\n        \u0026mut self,\n        filler: W,\n        label: \u0026'static str,\n    ) -\u003e Vec\u003cExprId\u003e {\n        self.expr_builder.add_witness_hints(filler, label)\n    }\n\n    /// Allocates a sequence of witness hints using the default filler.\n    /// This is equivalent to calling `alloc_witness_hints` with `DefaultHint`,\n    /// but is kept only for compatibility and should be removed.\n    /// TODO: Remove this function.\n    #[must_use]\n    pub fn alloc_witness_hints_default_filler(\n        \u0026mut self,\n        count: usize,\n        label: \u0026'static str,\n    ) -\u003e Vec\u003cExprId\u003e {\n        self.expr_builder\n            .add_witness_hints(DefaultHint { n_outputs: count }, label)\n    }\n\n    /// Adds a constant to the circuit (deduplicated).\n    ///\n    /// If this value was previously added, returns the original ExprId.\n    /// Cost: 1 row in Const table + 1 row in witness table (only for new constants).\n    pub fn add_const(\u0026mut self, val: F) -\u003e ExprId {\n        self.alloc_const(val, \"\")\n    }\n\n    /// Allocates a constant with a descriptive label.\n    ///\n    /// Cost: 1 row in Const table + 1 row in witness table (only for new constants).\n    pub fn alloc_const(\u0026mut self, val: F, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.add_const(val, label)\n    }\n\n    /// Adds two expressions.\n    ///\n    /// Cost: 1 row in Add table + 1 row in witness table.\n    pub fn add(\u0026mut self, lhs: ExprId, rhs: ExprId) -\u003e ExprId {\n        self.alloc_add(lhs, rhs, \"\")\n    }\n\n    /// Adds two expressions with a descriptive label.\n    ///\n    /// Cost: 1 row in Add table + 1 row in witness table.\n    pub fn alloc_add(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.add_add(lhs, rhs, label)\n    }\n\n    /// Subtracts two expressions.\n    ///\n    /// Cost: 1 row in Add table + 1 row in witness table (encoded as result + rhs = lhs).\n    pub fn sub(\u0026mut self, lhs: ExprId, rhs: ExprId) -\u003e ExprId {\n        self.alloc_sub(lhs, rhs, \"\")\n    }\n\n    /// Subtracts two expressions with a descriptive label.\n    ///\n    /// Cost: 1 row in Add table + 1 row in witness table.\n    pub fn alloc_sub(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.add_sub(lhs, rhs, label)\n    }\n\n    /// Multiplies two expressions.\n    ///\n    /// Cost: 1 row in Mul table + 1 row in witness table.\n    pub fn mul(\u0026mut self, lhs: ExprId, rhs: ExprId) -\u003e ExprId {\n        self.alloc_mul(lhs, rhs, \"\")\n    }\n\n    /// Multiplies two expressions with a descriptive label.\n    ///\n    /// Cost: 1 row in Mul table + 1 row in witness table.\n    pub fn alloc_mul(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.add_mul(lhs, rhs, label)\n    }\n\n    /// Computes and returns `a * b + c`.\n    ///\n    /// This is a common fused operation in cryptographic circuits.\n    ///\n    /// # Arguments\n    /// * `a`, `b`, `c`: The expressions to operate on.\n    ///\n    /// # Returns\n    /// A new `ExprId` representing the result of `a * b + c`.\n    ///\n    /// # Cost\n    /// 1 multiplication and 1 addition constraint.\n    pub fn mul_add(\u0026mut self, a: ExprId, b: ExprId, c: ExprId) -\u003e ExprId {\n        let product = self.mul(a, b);\n        self.add(product, c)\n    }\n\n    /// Multiplies a slice of expressions together.\n    ///\n    /// # Arguments\n    /// * `inputs`: A slice of `ExprId`s to multiply.\n    ///\n    /// # Returns\n    /// A new `ExprId` representing the product of all inputs. Returns `1` if the slice is empty.\n    ///\n    /// # Cost\n    /// `N-1` multiplication constraints, where `N` is the number of inputs.\n    pub fn mul_many(\u0026mut self, inputs: \u0026[ExprId]) -\u003e ExprId {\n        // Handle edge cases for empty or single-element slices.\n        if inputs.is_empty() {\n            return self.add_const(F::ONE);\n        }\n        if inputs.len() == 1 {\n            return inputs[0];\n        }\n\n        // Efficiently multiply all elements using a fold.\n        inputs\n            .iter()\n            .skip(1)\n            .fold(inputs[0], |acc, \u0026x| self.mul(acc, x))\n    }\n\n    /// Computes the inner product (dot product) of two slices of expressions.\n    ///\n    /// Computes `∑ (a[i] * b[i])`.\n    ///\n    /// # Arguments\n    /// * `a`: The first slice of `ExprId`s.\n    /// * `b`: The second slice of `ExprId`s.\n    ///\n    /// # Panics\n    /// Panics if the input slices `a` and `b` have different lengths.\n    ///\n    /// # Returns\n    /// A new `ExprId` representing the inner product.\n    ///\n    /// # Cost\n    /// `N` multiplications and `N-1` additions, where `N` is the length of the slices.\n    pub fn inner_product(\u0026mut self, a: \u0026[ExprId], b: \u0026[ExprId]) -\u003e ExprId {\n        let zero = self.add_const(F::ZERO);\n\n        // Calculate the sum of element-wise products.\n        zip_eq(a, b).fold(zero, |acc, (\u0026x, \u0026y)| self.mul_add(x, y, acc))\n    }\n\n    /// Divides two expressions.\n    ///\n    /// Cost: 1 row in Mul table + 1 row in witness table (encoded as rhs * out = lhs).\n    pub fn div(\u0026mut self, lhs: ExprId, rhs: ExprId) -\u003e ExprId {\n        self.alloc_div(lhs, rhs, \"\")\n    }\n\n    /// Divides two expressions with a descriptive label.\n    ///\n    /// Cost: 1 row in Mul table + 1 row in witness table.\n    pub fn alloc_div(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.expr_builder.add_div(lhs, rhs, label)\n    }\n\n    /// Asserts that an expression equals zero by connecting it to Const(0).\n    ///\n    /// Cost: Free in proving (implemented via connect).\n    pub fn assert_zero(\u0026mut self, expr: ExprId) {\n        self.connect(expr, ExprId::ZERO);\n    }\n\n    /// Asserts that an expression is boolean: b ∈ {0,1}.\n    ///\n    /// Encodes the constraint b · (b − 1) = 0 via `assert_zero`.\n    /// Cost: 1 mul + 1 add.\n    pub fn assert_bool(\u0026mut self, b: ExprId) {\n        let one = self.add_const(F::ONE);\n        let b_minus_one = self.sub(b, one);\n        let prod = self.mul(b, b_minus_one);\n        self.assert_zero(prod);\n    }\n\n    /// Connects two expressions, enforcing a == b (by aliasing outputs).\n    ///\n    /// Cost: Free in proving (handled by IR optimization layer via witness slot aliasing).\n    pub fn connect(\u0026mut self, a: ExprId, b: ExprId) {\n        self.expr_builder.connect(a, b);\n    }\n\n    /// Selects between two values using selector `b`:\n    /// result = s + b · (t − s).\n    ///\n    /// When `b` ∈ {0,1}, this returns `t` if b = 1, else `s` if b = 0.\n    /// Call `assert_bool(b)` beforehand if you need booleanity enforced.\n    /// Cost: 1 mul + 2 add.\n    pub fn select(\u0026mut self, b: ExprId, t: ExprId, s: ExprId) -\u003e ExprId {\n        let t_minus_s = self.sub(t, s);\n        let scaled = self.mul(b, t_minus_s);\n        self.add(s, scaled)\n    }\n\n    /// Exponentiates a base expression to a power of 2 (i.e. base^(2^power_log)), by squaring repeatedly.\n    pub fn exp_power_of_2(\u0026mut self, base: ExprId, power_log: usize) -\u003e ExprId {\n        let mut res = base;\n        for _ in 0..power_log {\n            let square = self.mul(res, res);\n            res = square;\n        }\n        res\n    }\n\n    /// Pushes a non-primitive op and creates optional output nodes tied to the call.\n    ///\n    /// `output_labels` must have length equal to the op's output arity; each `Some(label)`\n    /// creates an `Expr::NonPrimitiveOutput { call, output_idx }` node for that output index.\n    /// The returned `Vec\u003cOption\u003cExprId\u003e\u003e` is aligned with `output_labels`.\n    pub(crate) fn push_non_primitive_op_with_outputs(\n        \u0026mut self,\n        op_type: NonPrimitiveOpType,\n        input_exprs: Vec\u003cVec\u003cExprId\u003e\u003e,\n        output_labels: Vec\u003cOption\u003c\u0026'static str\u003e\u003e,\n        params: Option\u003cNonPrimitiveOpParams\u003e,\n        label: \u0026'static str,\n    ) -\u003e (NonPrimitiveOpId, ExprId, Vec\u003cOption\u003cExprId\u003e\u003e) {\n        let op_id = NonPrimitiveOpId(self.non_primitive_ops.len() as u32);\n\n        let flattened_inputs: Vec\u003cExprId\u003e = input_exprs.iter().flatten().copied().collect();\n        let call_expr_id = self.expr_builder.add_non_primitive_call(\n            op_id,\n            op_type.clone(),\n            flattened_inputs,\n            label,\n        );\n\n        let mut output_exprs: Vec\u003cVec\u003cExprId\u003e\u003e = vec![Vec::new(); output_labels.len()];\n        let mut outputs: Vec\u003cOption\u003cExprId\u003e\u003e = vec![None; output_labels.len()];\n        for (i, maybe_label) in output_labels.into_iter().enumerate() {\n            if let Some(out_label) = maybe_label {\n                let out_expr_id =\n                    self.expr_builder\n                        .add_non_primitive_output(call_expr_id, i as u32, out_label);\n                output_exprs[i] = vec![out_expr_id];\n                outputs[i] = Some(out_expr_id);\n            }\n        }\n\n        self.non_primitive_ops.push(NonPrimitiveOperationData {\n            op_id,\n            op_type,\n            input_exprs,\n            output_exprs,\n            params,\n        });\n\n        (op_id, call_expr_id, outputs)\n    }\n\n    /// Pushes a new scope onto the scope stack.\n    ///\n    /// All subsequent allocations will be tagged with this scope until\n    /// `pop_scope` is called. Scopes can be nested.\n    ///\n    /// If debug_assertions are not enabled, this is a no-op.\n    #[allow(unused_variables)]\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn push_scope(\u0026mut self, scope: \u0026'static str) {\n        #[cfg(debug_assertions)]\n        self.expr_builder.push_scope(scope);\n    }\n\n    /// Pops the current scope from the scope stack.\n    ///\n    /// If debug_assertions are not enabled, this is a no-op.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn pop_scope(\u0026mut self) {\n        #[cfg(debug_assertions)]\n        self.expr_builder.pop_scope();\n    }\n\n    /// Dumps the allocation log.\n    ///\n    /// If debug_assertions are not enabled, this is a no-op.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn dump_allocation_log(\u0026self) {\n        self.expr_builder.dump_allocation_log();\n    }\n\n    /// Lists all unique scopes in the allocation log.\n    ///\n    /// Returns an empty vector if debug_assertions are not enabled.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn list_scopes(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        self.expr_builder.list_scopes()\n    }\n}\n\nimpl\u003cF\u003e CircuitBuilder\u003cF\u003e\nwhere\n    F: Field + Clone + PartialEq + Eq + Hash,\n{\n    /// Builds the circuit into a Circuit with separate lowering and IR transformation stages.\n    /// Returns an error if lowering fails due to an internal inconsistency.\n    pub fn build(self) -\u003e Result\u003cCircuit\u003cF\u003e, CircuitBuilderError\u003e {\n        let (circuit, _) = self.build_with_public_mapping()?;\n        Ok(circuit)\n    }\n\n    /// Builds the circuit and returns both the circuit and the ExprId→WitnessId mapping for public inputs.\n    #[allow(clippy::type_complexity)]\n    pub fn build_with_public_mapping(\n        self,\n    ) -\u003e Result\u003c(Circuit\u003cF\u003e, HashMap\u003cExprId, WitnessId\u003e), CircuitBuilderError\u003e {\n        // Stage 1: Lower expressions and non-primitives into a single op list\n        for data in \u0026self.non_primitive_ops {\n            self.ensure_op_enabled(data.op_type.clone())?;\n        }\n        let lowerer = ExpressionLowerer::new(\n            self.expr_builder.graph(),\n            \u0026self.non_primitive_ops,\n            self.expr_builder.pending_connects(),\n            self.public_tracker.count(),\n            self.expr_builder.hints_fillers(),\n            self.witness_alloc,\n        );\n        let (ops, public_rows, expr_to_widx, public_mappings, witness_count) = lowerer.lower()?;\n\n        // Stage 2: IR transformations and optimizations\n        let optimizer = Optimizer::new();\n        let ops = optimizer.optimize(ops);\n\n        // Stage 3: Generate final circuit\n        let mut circuit = Circuit::new(witness_count, expr_to_widx);\n        circuit.ops = ops;\n        circuit.public_rows = public_rows;\n        circuit.public_flat_len = self.public_tracker.count();\n        circuit.enabled_ops = self.config.into_enabled_ops();\n        circuit.non_primitive_trace_generators = self.non_primitive_trace_generators;\n\n        Ok((circuit, public_mappings))\n    }\n\n    /// Decomposes a field element into its little-endian binary representation.\n    ///\n    /// Given a target `x`, creates `n_bits` boolean witness targets representing\n    /// the binary decomposition, and constrains them to reconstruct `x`.\n    ///\n    /// # Parameters\n    /// - `x`: The field element to decompose.\n    /// - `n_bits`: Number of bits in the decomposition (must be ≤ 64).\n    ///\n    /// # Returns\n    /// A vector of `n_bits` boolean [`ExprId`]s\n    /// ```text\n    ///     [b_0, b_1, ..., b_{n-1}]\n    /// ```\n    /// such that:\n    /// ```text\n    ///     x = b_0·2^0 + b_1·2^1 + b_2·2^2 + ... + b_{n-1}·2^{n-1}.\n    /// ```\n    ///\n    /// # Errors\n    /// Returns [`CircuitError::BinaryDecompositionTooManyBits`] if `n_bits \u003e 64`.\n    ///\n    /// # Cost\n    /// `n_bits` witness hints + `n_bits` boolean constraints + reconstruction constraints.\n    pub fn decompose_to_bits\u003cBF\u003e(\n        \u0026mut self,\n        x: ExprId,\n        n_bits: usize,\n    ) -\u003e Result\u003cVec\u003cExprId\u003e, CircuitError\u003e\n    where\n        F: ExtensionField\u003cBF\u003e,\n        BF: PrimeField64,\n    {\n        self.push_scope(\"decompose_to_bits\");\n\n        // Allocate witness hints that will be filled with the binary decomposition at runtime.\n        let hint = BinaryDecompositionHint::\u003cBF\u003e::new(x, n_bits)?;\n        let bits = self.alloc_witness_hints(hint, \"decompose_to_bits\");\n\n        // Constrain that the bits reconstruct to the original value.\n        let reconstructed = self.reconstruct_index_from_bits(\u0026bits);\n        self.connect(x, reconstructed);\n\n        self.pop_scope();\n        Ok(bits)\n    }\n\n    /// Reconstructs an integer from its little-endian binary representation.\n    ///\n    /// Computes `index = Σ b_i · 2^i` for bits `[b_0, b_1, ..., b_{n-1}]`.\n    ///\n    /// # Parameters\n    /// - `bits`: Slice of boolean `ExprId`s in little-endian order.\n    ///\n    /// # Returns\n    /// An `ExprId` representing the reconstructed integer value.\n    ///\n    /// # Cost\n    /// `n` boolean constraints + `n` multiplications + `n` additions, where `n = bits.len()`.\n    pub fn reconstruct_index_from_bits(\u0026mut self, bits: \u0026[ExprId]) -\u003e ExprId {\n        self.push_scope(\"reconstruct_index_from_bits\");\n\n        // Accumulator for the running sum.\n        let mut acc = self.add_const(F::ZERO);\n        // Current power of 2 (starts at 2^0 = 1).\n        let mut pow2 = self.add_const(F::ONE);\n\n        for \u0026b in bits {\n            // Ensure each bit is boolean.\n            self.assert_bool(b);\n            // Add b_i · 2^i to the accumulator.\n            let term = self.mul(b, pow2);\n            acc = self.add(acc, term);\n            // Double the power: 2^i → 2^{i+1}.\n            pow2 = self.add(pow2, pow2);\n        }\n\n        self.pop_scope();\n        acc\n    }\n}\n\n/// Witness hint filler for binary decomposition of a field element.\n///\n/// At runtime:\n/// - It extracts the canonical `u64` representation of the input field element,\n/// - It fills the witness with its little-endian binary decomposition.\n#[derive(Debug, Clone)]\nstruct BinaryDecompositionHint\u003cBF: PrimeField64\u003e {\n    /// The single input expression to decompose.\n    inputs: Vec\u003cExprId\u003e,\n    /// Number of bits in the decomposition.\n    n_bits: usize,\n    /// Phantom data for the base field type.\n    _phantom: PhantomData\u003cBF\u003e,\n}\n\nimpl\u003cBF: PrimeField64\u003e BinaryDecompositionHint\u003cBF\u003e {\n    /// Creates a new binary decomposition hint.\n    ///\n    /// # Parameters\n    /// - `input`: The expression to decompose.\n    /// - `n_bits`: Number of output bits (must be ≤ 64).\n    ///\n    /// # Errors\n    /// Returns an error if `n_bits \u003e 64` since we extract a `u64` value.\n    fn new(input: ExprId, n_bits: usize) -\u003e Result\u003cSelf, CircuitError\u003e {\n        if n_bits \u003e 64 {\n            return Err(CircuitError::BinaryDecompositionTooManyBits {\n                expected: 64,\n                n_bits,\n            });\n        }\n        Ok(Self {\n            inputs: vec![input],\n            n_bits,\n            _phantom: PhantomData,\n        })\n    }\n}\n\nimpl\u003cBF: PrimeField64, F: ExtensionField\u003cBF\u003e\u003e WitnessHintsFiller\u003cF\u003e\n    for BinaryDecompositionHint\u003cBF\u003e\n{\n    fn inputs(\u0026self) -\u003e \u0026[ExprId] {\n        \u0026self.inputs\n    }\n\n    fn n_outputs(\u0026self) -\u003e usize {\n        self.n_bits\n    }\n\n    fn compute_outputs(\u0026self, inputs_val: Vec\u003cF\u003e) -\u003e Result\u003cVec\u003cF\u003e, CircuitError\u003e {\n        // Extract the base field coefficient and convert to canonical u64.\n        let val = inputs_val[0].as_basis_coefficients_slice()[0].as_canonical_u64();\n\n        // Extract each bit: (val \u003e\u003e i) \u0026 1 gives the i-th bit.\n        let bits = (0..self.n_bits)\n            .map(|i| F::from_bool(val \u003e\u003e i \u0026 1 == 1))\n            .collect();\n\n        // Sanity check: ensure we have enough bits to represent the value.\n        debug_assert!(self.n_bits as u64 \u003e= log2_ceil_u64(val));\n\n        Ok(bits)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::extension::BinomialExtensionField;\n\n    use super::*;\n    use crate::op::NonPrimitiveOpConfig;\n\n    #[test]\n    fn test_new_builder_initialization() {\n        let builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        assert_eq!(builder.public_input_count(), 0);\n    }\n\n    #[test]\n    fn test_default_same_as_new() {\n        let builder1 = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let builder2 = CircuitBuilder::\u003cBabyBear\u003e::default();\n        assert_eq!(builder1.public_input_count(), builder2.public_input_count());\n    }\n\n    #[test]\n    fn test_add_public_input_single() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        builder.add_public_input();\n        assert_eq!(builder.public_input_count(), 1);\n    }\n\n    #[test]\n    fn test_alloc_public_inputs_multiple() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let pis = builder.alloc_public_inputs(5, \"batch\");\n        assert_eq!(pis.len(), 5);\n        assert_eq!(builder.public_input_count(), 5);\n    }\n\n    #[test]\n    fn test_alloc_public_input_array() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let pis: [ExprId; 3] = builder.alloc_public_input_array(\"array\");\n        assert_eq!(pis.len(), 3);\n        assert_eq!(builder.public_input_count(), 3);\n    }\n\n    #[test]\n    fn test_public_input_count_increments() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        assert_eq!(builder.public_input_count(), 0);\n        builder.add_public_input();\n        assert_eq!(builder.public_input_count(), 1);\n        builder.add_public_input();\n        assert_eq!(builder.public_input_count(), 2);\n    }\n\n    #[test]\n    fn test_add_const_deduplication() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let c1 = builder.add_const(BabyBear::from_u64(99));\n        let c2 = builder.add_const(BabyBear::from_u64(99));\n        assert_eq!(c1, c2);\n    }\n\n    #[test]\n    fn test_exp_power_of_2_zero() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let base = builder.add_const(BabyBear::from_u64(5));\n        let result = builder.exp_power_of_2(base, 0);\n        assert_eq!(result, base);\n    }\n\n    #[test]\n    fn test_select_operation() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let b = builder.add_public_input();\n        let t = builder.add_const(BabyBear::from_u64(10));\n        let s = builder.add_const(BabyBear::from_u64(5));\n        let _result = builder.select(b, t, s);\n        // Should create: t_minus_s, scaled, and result\n        assert_eq!(builder.public_input_count(), 1);\n    }\n\n    #[test]\n    #[cfg(debug_assertions)]\n    fn test_scope_operations() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        builder.push_scope(\"test_scope\");\n        builder.add_const(BabyBear::ONE);\n        builder.pop_scope();\n        let scopes = builder.list_scopes();\n        assert!(scopes.contains(\u0026\"test_scope\"));\n    }\n\n    #[test]\n    #[cfg(not(debug_assertions))]\n    fn test_list_scopes_release() {\n        let builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        assert!(builder.list_scopes().is_empty());\n    }\n\n    #[test]\n    fn test_build_empty_circuit() {\n        let builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let circuit = builder\n            .build()\n            .expect(\"Empty circuit should build successfully\");\n\n        assert_eq!(circuit.public_flat_len, 0);\n        assert_eq!(circuit.witness_count, 1);\n        assert_eq!(circuit.ops.len(), 1);\n        assert!(circuit.public_rows.is_empty());\n        assert!(circuit.enabled_ops.is_empty());\n\n        match \u0026circuit.ops[0] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(0));\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const operation at index 0\"),\n        }\n    }\n\n    #[test]\n    fn test_build_with_public_inputs() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        builder.add_public_input();\n        builder.add_public_input();\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with public inputs should build\");\n\n        assert_eq!(circuit.public_flat_len, 2);\n        assert_eq!(circuit.public_rows.len(), 2);\n        assert_eq!(circuit.witness_count, 3);\n        assert_eq!(circuit.ops.len(), 3);\n\n        match \u0026circuit.ops[0] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(0));\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const at index 0\"),\n        }\n\n        match \u0026circuit.ops[1] {\n            crate::op::Op::Public { out, public_pos } =\u003e {\n                assert_eq!(*out, WitnessId(1));\n                assert_eq!(*public_pos, 0);\n            }\n            _ =\u003e panic!(\"Expected Public at index 1\"),\n        }\n\n        match \u0026circuit.ops[2] {\n            crate::op::Op::Public { out, public_pos } =\u003e {\n                assert_eq!(*out, WitnessId(2));\n                assert_eq!(*public_pos, 1);\n            }\n            _ =\u003e panic!(\"Expected Public at index 2\"),\n        }\n\n        assert_eq!(circuit.public_rows[0], WitnessId(1));\n        assert_eq!(circuit.public_rows[1], WitnessId(2));\n    }\n\n    #[test]\n    fn test_build_with_constants() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        builder.add_const(BabyBear::from_u64(1));\n        builder.add_const(BabyBear::from_u64(2));\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with constants should build\");\n\n        assert_eq!(circuit.public_flat_len, 0);\n        assert!(circuit.public_rows.is_empty());\n        assert_eq!(circuit.witness_count, 3);\n        assert_eq!(circuit.ops.len(), 3);\n\n        match \u0026circuit.ops[0] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(0));\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const at index 0\"),\n        }\n\n        match \u0026circuit.ops[1] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(1));\n                assert_eq!(*val, BabyBear::from_u64(1));\n            }\n            _ =\u003e panic!(\"Expected Const at index 1\"),\n        }\n\n        match \u0026circuit.ops[2] {\n            crate::op::Op::Const { out, val } =\u003e {\n                assert_eq!(*out, WitnessId(2));\n                assert_eq!(*val, BabyBear::from_u64(2));\n            }\n            _ =\u003e panic!(\"Expected Const at index 2\"),\n        }\n    }\n\n    #[test]\n    fn test_build_with_operations() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.add_const(BabyBear::from_u64(2));\n        let b = builder.add_const(BabyBear::from_u64(3));\n        builder.add(a, b);\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with operations should build\");\n\n        assert_eq!(circuit.witness_count, 4);\n        assert_eq!(circuit.ops.len(), 4);\n\n        match \u0026circuit.ops[3] {\n            crate::op::Op::Add { out, a, b } =\u003e {\n                assert_eq!(*out, WitnessId(3));\n                assert_eq!(*a, WitnessId(1));\n                assert_eq!(*b, WitnessId(2));\n            }\n            _ =\u003e panic!(\"Expected Add at index 3\"),\n        }\n    }\n\n    #[test]\n    fn test_build_with_public_mapping() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let p0 = builder.add_public_input();\n        let p1 = builder.add_public_input();\n        let (circuit, mapping) = builder\n            .build_with_public_mapping()\n            .expect(\"Circuit should build with public mapping\");\n\n        assert_eq!(circuit.public_flat_len, 2);\n        assert_eq!(mapping.len(), 2);\n        assert_eq!(mapping[\u0026p0], WitnessId(1));\n        assert_eq!(mapping[\u0026p1], WitnessId(2));\n    }\n\n    #[test]\n    fn test_build_with_connect_deduplication() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.add_const(BabyBear::from_u64(5));\n        let b = builder.add_const(BabyBear::from_u64(5));\n        builder.connect(a, b);\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with constraints should build\");\n\n        assert_eq!(circuit.witness_count, 2);\n        assert_eq!(circuit.ops.len(), 2);\n    }\n\n    #[test]\n    fn test_build_with_witness_hint() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let default_hint = DefaultHint { n_outputs: 1 };\n        let a = builder.alloc_witness_hints(default_hint, \"a\");\n        assert_eq!(a.len(), 1);\n        let circuit = builder\n            .build()\n            .expect(\"Circuit with operations should build\");\n\n        assert_eq!(circuit.witness_count, 2);\n        assert_eq!(circuit.ops.len(), 2);\n\n        match \u0026circuit.ops[1] {\n            crate::op::Op::Unconstrained {\n                inputs, outputs, ..\n            } =\u003e {\n                assert_eq!(*inputs, vec![]);\n                assert_eq!(*outputs, vec![WitnessId(1)]);\n            }\n            _ =\u003e panic!(\"Expected Unconstrained at index 0\"),\n        }\n    }\n\n    #[test]\n    fn test_non_primitive_outputs_ordering_and_dedup() {\n        use crate::ops::{Poseidon2PermCall, Poseidon2PermOps};\n\n        type Ext4 = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n        builder.enable_op(\n            NonPrimitiveOpType::Poseidon2Perm,\n            NonPrimitiveOpConfig::None,\n        );\n\n        // Use add_poseidon2_perm with out_ctl to expose outputs.\n        let z = builder.add_const(Ext4::ZERO);\n        let (op_id, outputs) = builder\n            .add_poseidon2_perm(Poseidon2PermCall {\n                new_start: true,\n                merkle_path: false,\n                mmcs_bit: None, // Must be None when merkle_path=false\n                inputs: [Some(z), Some(z), Some(z), Some(z)],\n                out_ctl: [true, true],\n                mmcs_index_sum: None,\n            })\n            .unwrap();\n\n        let out0 = outputs[0].unwrap();\n        let out1 = outputs[1].unwrap();\n\n        let one = builder.add_const(Ext4::ONE);\n        let sum0 = builder.add(out0, one);\n        let sum1 = builder.add(out1, one);\n\n        let circuit = builder.build().unwrap();\n\n        // Non-primitive op emitted exactly once.\n        let non_prims: Vec\u003c_\u003e = circuit\n            .ops\n            .iter()\n            .enumerate()\n            .filter_map(|(i, op)| match op {\n                crate::op::Op::NonPrimitiveOpWithExecutor { op_id: oid, .. } if *oid == op_id =\u003e {\n                    Some(i)\n                }\n                _ =\u003e None,\n            })\n            .collect();\n        assert_eq!(non_prims.len(), 1);\n        let non_prim_pos = non_prims[0];\n\n        // Exact Add matches (order of a/b may swap).\n        let w_out0 = circuit.expr_to_widx[\u0026out0];\n        let w_out1 = circuit.expr_to_widx[\u0026out1];\n        let w_one = circuit.expr_to_widx[\u0026one];\n        let w_sum0 = circuit.expr_to_widx[\u0026sum0];\n        let w_sum1 = circuit.expr_to_widx[\u0026sum1];\n\n        let add0_pos = circuit\n            .ops\n            .iter()\n            .position(|op| match op {\n                crate::op::Op::Add { a, b, out } =\u003e {\n                    *out == w_sum0\n                        \u0026\u0026 ((*a == w_out0 \u0026\u0026 *b == w_one) || (*a == w_one \u0026\u0026 *b == w_out0))\n                }\n                _ =\u003e false,\n            })\n            .unwrap();\n\n        let add1_pos = circuit\n            .ops\n            .iter()\n            .position(|op| match op {\n                crate::op::Op::Add { a, b, out } =\u003e {\n                    *out == w_sum1\n                        \u0026\u0026 ((*a == w_out1 \u0026\u0026 *b == w_one) || (*a == w_one \u0026\u0026 *b == w_out1))\n                }\n                _ =\u003e false,\n            })\n            .unwrap();\n\n        assert!(non_prim_pos \u003c add0_pos);\n        assert!(non_prim_pos \u003c add1_pos);\n    }\n}\n\n#[cfg(test)]\nmod proptests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n    use proptest::prelude::*;\n\n    use super::*;\n\n    // Strategy for generating valid field elements\n    fn field_element() -\u003e impl Strategy\u003cValue = BabyBear\u003e {\n        any::\u003cu64\u003e().prop_map(BabyBear::from_u64)\n    }\n\n    proptest! {\n        #[test]\n        fn field_add_commutative(a in field_element(), b in field_element()) {\n            let mut builder1 = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder1.add_const(a);\n            let cb = builder1.add_const(b);\n            let sum1 = builder1.add(ca, cb);\n\n            let mut builder2 = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca2 = builder2.add_const(a);\n            let cb2 = builder2.add_const(b);\n            let sum2 = builder2.add(cb2, ca2);\n\n            let circuit1 = builder1.build().unwrap();\n            let circuit2 = builder2.build().unwrap();\n\n            let  runner1 = circuit1.runner();\n            let  runner2 = circuit2.runner();\n\n            let traces1 = runner1.run().unwrap();\n            let traces2 = runner2.run().unwrap();\n\n            prop_assert_eq!(\n                traces1.witness_trace.values[sum1.0 as usize],\n                traces2.witness_trace.values[sum2.0 as usize],\n                \"addition should be commutative\"\n            );\n        }\n\n        #[test]\n        fn field_mul_commutative(a in field_element(), b in field_element()) {\n            let mut builder1 = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder1.add_const(a);\n            let cb = builder1.add_const(b);\n            let prod1 = builder1.mul(ca, cb);\n\n            let mut builder2 = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca2 = builder2.add_const(a);\n            let cb2 = builder2.add_const(b);\n            let prod2 = builder2.mul(cb2, ca2);\n\n            let circuit1 = builder1.build().unwrap();\n            let circuit2 = builder2.build().unwrap();\n\n            let  runner1 = circuit1.runner();\n            let  runner2 = circuit2.runner();\n\n            let traces1 = runner1.run().unwrap();\n            let traces2 = runner2.run().unwrap();\n\n            prop_assert_eq!(\n                traces1.witness_trace.values[prod1.0 as usize],\n                traces2.witness_trace.values[prod2.0 as usize],\n                \"multiplication should be commutative\"\n            );\n        }\n\n        #[test]\n        fn field_add_identity(a in field_element()) {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.add_const(a);\n            let zero = builder.add_const(BabyBear::ZERO);\n            let result = builder.add(ca, zero);\n\n            let circuit = builder.build().unwrap();\n            let  runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            prop_assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                a,\n                \"a + 0 = a\"\n            );\n        }\n\n        #[test]\n        fn field_mul_identity(a in field_element()) {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.add_const(a);\n            let one = builder.add_const(BabyBear::ONE);\n            let result = builder.mul(ca, one);\n\n            let circuit = builder.build().unwrap();\n            let  runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            prop_assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                a,\n                \"a * 1 = a\"\n            );\n        }\n\n        #[test]\n        fn field_add_sub(a in field_element(), b in field_element()) {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.add_const(a);\n            let cb = builder.add_const(b);\n            let diff = builder.sub(ca, cb);\n            let result = builder.add(diff, cb);\n\n            let circuit = builder.build().unwrap();\n            let  runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            prop_assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                a,\n                \"(a - b) + b = a\"\n            );\n        }\n\n        #[test]\n        fn field_mul_div(a in field_element(), b in field_element().prop_filter(\"b must be non-zero\", |\u0026x| x != BabyBear::ZERO)) {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.add_const(a);\n            let cb = builder.add_const(b);\n            let quot = builder.div(ca, cb);\n            let result = builder.mul(quot, cb);\n\n            let circuit = builder.build().unwrap();\n            let  runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            prop_assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                a,\n                \"(a / b) * b = a\"\n            );\n        }\n    }\n\n    #[test]\n    fn test_mul_add() {\n        // Test case 1: Basic computation (3 * 4 + 5 = 17)\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let a = builder.add_const(BabyBear::from_u64(3));\n            let b = builder.add_const(BabyBear::from_u64(4));\n            let c = builder.add_const(BabyBear::from_u64(5));\n            let result = builder.mul_add(a, b, c);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                BabyBear::from_u64(17)\n            );\n        }\n\n        // Test case 2: With zero product (0 * 7 + 9 = 9)\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let zero = builder.add_const(BabyBear::ZERO);\n            let b = builder.add_const(BabyBear::from_u64(7));\n            let c = builder.add_const(BabyBear::from_u64(9));\n            let result = builder.mul_add(zero, b, c);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                BabyBear::from_u64(9)\n            );\n        }\n    }\n\n    #[test]\n    fn test_mul_many() {\n        // Test case 1: Empty slice returns 1 (multiplicative identity)\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let result = builder.mul_many(\u0026[]);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                BabyBear::ONE\n            );\n        }\n\n        // Test case 2: Multiple elements [2, 3, 4, 5] = 120\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let vals: Vec\u003cExprId\u003e = vec![2, 3, 4, 5]\n                .into_iter()\n                .map(|v| builder.add_const(BabyBear::from_u64(v)))\n                .collect();\n            let result = builder.mul_many(\u0026vals);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                BabyBear::from_u64(120)\n            );\n        }\n\n        // Test case 3: With zero element [5, 0, 7] = 0\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let with_zero = vec![\n                builder.add_const(BabyBear::from_u64(5)),\n                builder.add_const(BabyBear::ZERO),\n                builder.add_const(BabyBear::from_u64(7)),\n            ];\n            let result = builder.mul_many(\u0026with_zero);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                BabyBear::ZERO\n            );\n        }\n    }\n\n    #[test]\n    fn test_inner_product() {\n        // Test case 1: Basic dot product [1,2,3] · [4,5,6] = 32\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let a: Vec\u003cExprId\u003e = vec![1, 2, 3]\n                .into_iter()\n                .map(|v| builder.add_const(BabyBear::from_u64(v)))\n                .collect();\n            let b: Vec\u003cExprId\u003e = vec![4, 5, 6]\n                .into_iter()\n                .map(|v| builder.add_const(BabyBear::from_u64(v)))\n                .collect();\n            let result = builder.inner_product(\u0026a, \u0026b);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                BabyBear::from_u64(32)\n            );\n        }\n\n        // Test case 2: Empty vectors [] · [] = 0\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let empty_a: Vec\u003cExprId\u003e = vec![];\n            let empty_b: Vec\u003cExprId\u003e = vec![];\n            let result = builder.inner_product(\u0026empty_a, \u0026empty_b);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                BabyBear::ZERO\n            );\n        }\n\n        // Test case 3: Zero vector [0,0,0] · [5,6,7] = 0\n        {\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let zeros: Vec\u003cExprId\u003e = (0..3).map(|_| builder.add_const(BabyBear::ZERO)).collect();\n            let vals: Vec\u003cExprId\u003e = vec![5, 6, 7]\n                .into_iter()\n                .map(|v| builder.add_const(BabyBear::from_u64(v)))\n                .collect();\n            let result = builder.inner_product(\u0026zeros, \u0026vals);\n\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                BabyBear::ZERO\n            );\n        }\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_inner_product_mismatched_lengths() {\n        // Verify that inner_product panics with mismatched vector lengths\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        // Create vectors with different lengths: [1,2] vs [3,4,5]\n        let a: Vec\u003cExprId\u003e = vec![1, 2]\n            .into_iter()\n            .map(|v| builder.add_const(BabyBear::from_u64(v)))\n            .collect();\n        let b: Vec\u003cExprId\u003e = vec![3, 4, 5]\n            .into_iter()\n            .map(|v| builder.add_const(BabyBear::from_u64(v)))\n            .collect();\n\n        // Should panic: lengths don't match (2 != 3)\n        builder.inner_product(\u0026a, \u0026b);\n    }\n\n    proptest! {\n        #[test]\n        fn prop_mul_add_correctness(\n            a in field_element(),\n            b in field_element(),\n            c in field_element()\n        ) {\n            // Build circuit with mul_add\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let ca = builder.add_const(a);\n            let cb = builder.add_const(b);\n            let cc = builder.add_const(c);\n            let result = builder.mul_add(ca, cb, cc);\n\n            // Execute circuit\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            // Compute expected value\n            let expected = a * b + c;\n\n            // Verify correctness\n            prop_assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                expected\n            );\n        }\n\n        #[test]\n        fn prop_mul_many_correctness(\n            values in prop::collection::vec(field_element(), 0..8)\n        ) {\n            // Build circuit with mul_many\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let expr_ids: Vec\u003cExprId\u003e = values\n                .iter()\n                .map(|\u0026v| builder.add_const(v))\n                .collect();\n            let result = builder.mul_many(\u0026expr_ids);\n\n            // Execute circuit\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            // Compute expected product (empty → 1, otherwise fold multiply)\n            let expected = if values.is_empty() {\n                BabyBear::ONE\n            } else {\n                values.iter().fold(BabyBear::ONE, |acc, \u0026x| acc * x)\n            };\n\n            // Verify correctness\n            prop_assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                expected\n            );\n        }\n\n        #[test]\n        fn prop_inner_product_correctness(\n            values in prop::collection::vec((field_element(), field_element()), 0..8)\n        ) {\n            // Extract equal-length vectors from paired values\n            let vec1: Vec\u003cBabyBear\u003e = values.iter().map(|(a, _)| *a).collect();\n            let vec2: Vec\u003cBabyBear\u003e = values.iter().map(|(_, b)| *b).collect();\n\n            // Build circuit with inner_product\n            let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n            let a: Vec\u003cExprId\u003e = vec1.iter().map(|\u0026v| builder.add_const(v)).collect();\n            let b: Vec\u003cExprId\u003e = vec2.iter().map(|\u0026v| builder.add_const(v)).collect();\n            let result = builder.inner_product(\u0026a, \u0026b);\n\n            // Execute circuit\n            let circuit = builder.build().unwrap();\n            let runner = circuit.runner();\n            let traces = runner.run().unwrap();\n\n            // Compute expected dot product: Σ(a_i * b_i)\n            let expected = vec1\n                .iter()\n                .zip(vec2.iter())\n                .fold(BabyBear::ZERO, |acc, (\u0026x, \u0026y)| acc + x * y);\n\n            // Verify correctness\n            prop_assert_eq!(\n                traces.witness_trace.values[result.0 as usize],\n                expected\n            );\n        }\n    }\n\n    #[test]\n    fn test_reconstruct_index_from_bits() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        // Test reconstructing the value 5 (binary: 101)\n        let bit0 = builder.add_const(BabyBear::ONE); // 1\n        let bit1 = builder.add_const(BabyBear::ZERO); // 0\n        let bit2 = builder.add_const(BabyBear::ONE); // 1\n\n        let bits = vec![bit0, bit1, bit2];\n        let result = builder.reconstruct_index_from_bits(\u0026bits);\n\n        // Connect result to a public input so we can verify its value\n        let output = builder.add_public_input();\n        builder.connect(result, output);\n\n        // Build and run the circuit\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let mut runner = circuit.runner();\n\n        // Set public inputs: the expected result value 5\n        let expected_result = BabyBear::from_u64(5); // 1*1 + 0*2 + 1*4 = 5\n        runner\n            .set_public_inputs(\u0026[expected_result])\n            .expect(\"Failed to set public inputs\");\n\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        // Just verify the calculation is correct - reconstruct gives us 5\n        assert_eq!(traces.public_trace.values[0], BabyBear::from_u64(5));\n    }\n\n    #[test]\n    fn test_decompose_to_bits() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n\n        // Create a target representing the value we want to decompose\n        let value = builder.add_const(BabyBear::from_u64(6)); // Binary: 110\n\n        // Decompose into 3 bits - this creates its own public inputs for the bits\n        let bits = builder.decompose_to_bits::\u003cBabyBear\u003e(value, 3).unwrap();\n\n        // Build and run the circuit\n        let circuit = builder.build().expect(\"Failed to build circuit\");\n        let runner = circuit.runner();\n        let traces = runner.run().expect(\"Failed to run circuit\");\n\n        // Verify the bits are correctly decomposed - 6 = [0,1,1] in little-endian\n        assert_eq!(traces.witness_trace.values[3], BabyBear::ZERO); // bit 0\n        assert_eq!(traces.witness_trace.values[4], BabyBear::ONE); // bit 1\n        assert_eq!(traces.witness_trace.values[5], BabyBear::ONE); // bit 2\n        assert_eq!(bits.len(), 3);\n    }\n}\n","traces":[{"line":65,"address":[6933280],"length":1,"stats":{"Line":1}},{"line":66,"address":[6933288],"length":1,"stats":{"Line":1}},{"line":75,"address":[4480886,4480512,4480892],"length":1,"stats":{"Line":22}},{"line":77,"address":[6949494,6949894],"length":1,"stats":{"Line":22}},{"line":78,"address":[1718587],"length":1,"stats":{"Line":21}},{"line":79,"address":[],"length":0,"stats":{"Line":20}},{"line":80,"address":[4480615],"length":1,"stats":{"Line":21}},{"line":81,"address":[3144230],"length":1,"stats":{"Line":20}},{"line":82,"address":[],"length":0,"stats":{"Line":21}},{"line":87,"address":[6952096],"length":1,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[2117936],"length":1,"stats":{"Line":1}},{"line":157,"address":[3139486],"length":1,"stats":{"Line":1}},{"line":160,"address":[5269088,5268752,5268640,5268864,5268976],"length":1,"stats":{"Line":1}},{"line":164,"address":[4121408],"length":1,"stats":{"Line":1}},{"line":165,"address":[2347779],"length":1,"stats":{"Line":0}},{"line":167,"address":[3746872,3746984],"length":1,"stats":{"Line":1}},{"line":173,"address":[4120672],"length":1,"stats":{"Line":11}},{"line":174,"address":[2456917],"length":1,"stats":{"Line":11}},{"line":182,"address":[6940832,6940752],"length":1,"stats":{"Line":18}},{"line":183,"address":[1715617],"length":1,"stats":{"Line":18}},{"line":184,"address":[5269268,5269588,5269428,5269348,5269508],"length":1,"stats":{"Line":17}},{"line":188,"address":[3140544],"length":1,"stats":{"Line":7}},{"line":189,"address":[2348033,2347960,2348016],"length":1,"stats":{"Line":21}},{"line":193,"address":[2348112],"length":1,"stats":{"Line":8}},{"line":194,"address":[3747403,3747424,3747441],"length":1,"stats":{"Line":24}},{"line":198,"address":[6940912],"length":1,"stats":{"Line":1}},{"line":199,"address":[6940917],"length":1,"stats":{"Line":1}},{"line":205,"address":[2348064],"length":1,"stats":{"Line":8}},{"line":210,"address":[6941163,6941215,6941115],"length":1,"stats":{"Line":8}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[2122384],"length":1,"stats":{"Line":13}},{"line":232,"address":[4126445],"length":1,"stats":{"Line":15}},{"line":238,"address":[6939152,6939120],"length":1,"stats":{"Line":14}},{"line":239,"address":[1715367],"length":1,"stats":{"Line":16}},{"line":245,"address":[2461232],"length":1,"stats":{"Line":15}},{"line":246,"address":[2121281],"length":1,"stats":{"Line":16}},{"line":252,"address":[2462784],"length":1,"stats":{"Line":16}},{"line":253,"address":[],"length":0,"stats":{"Line":16}},{"line":259,"address":[5286128,5286032,5286080,5286176,5286224],"length":1,"stats":{"Line":15}},{"line":260,"address":[1718977],"length":1,"stats":{"Line":15}},{"line":266,"address":[1719552],"length":1,"stats":{"Line":16}},{"line":267,"address":[2353067],"length":1,"stats":{"Line":16}},{"line":273,"address":[5283840,5283984,5283888,5283936,5283792],"length":1,"stats":{"Line":16}},{"line":274,"address":[],"length":0,"stats":{"Line":15}},{"line":280,"address":[3755968],"length":1,"stats":{"Line":15}},{"line":281,"address":[],"length":0,"stats":{"Line":15}},{"line":296,"address":[2462352],"length":1,"stats":{"Line":6}},{"line":297,"address":[2352493],"length":1,"stats":{"Line":6}},{"line":298,"address":[4126096],"length":1,"stats":{"Line":6}},{"line":311,"address":[2462416],"length":1,"stats":{"Line":6}},{"line":313,"address":[3755516],"length":1,"stats":{"Line":6}},{"line":314,"address":[2462503],"length":1,"stats":{"Line":1}},{"line":316,"address":[4126186],"length":1,"stats":{"Line":6}},{"line":317,"address":[3145345,3145284],"length":1,"stats":{"Line":8}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[4126267,4126330,4126384,4126402],"length":1,"stats":{"Line":17}},{"line":343,"address":[],"length":0,"stats":{"Line":6}},{"line":344,"address":[],"length":0,"stats":{"Line":6}},{"line":347,"address":[4120432,4120459,4120383],"length":1,"stats":{"Line":18}},{"line":353,"address":[2121312],"length":1,"stats":{"Line":7}},{"line":354,"address":[],"length":0,"stats":{"Line":7}},{"line":360,"address":[],"length":0,"stats":{"Line":7}},{"line":361,"address":[4126539],"length":1,"stats":{"Line":7}},{"line":367,"address":[2346576],"length":1,"stats":{"Line":14}},{"line":368,"address":[5268157,5268189,5268221,5268093,5268125],"length":1,"stats":{"Line":13}},{"line":375,"address":[3139072],"length":1,"stats":{"Line":7}},{"line":376,"address":[6939222],"length":1,"stats":{"Line":7}},{"line":377,"address":[],"length":0,"stats":{"Line":7}},{"line":378,"address":[2346539],"length":1,"stats":{"Line":8}},{"line":379,"address":[6939283],"length":1,"stats":{"Line":8}},{"line":385,"address":[6951280,6951248],"length":1,"stats":{"Line":16}},{"line":386,"address":[],"length":0,"stats":{"Line":16}},{"line":395,"address":[],"length":0,"stats":{"Line":7}},{"line":396,"address":[6951190],"length":1,"stats":{"Line":7}},{"line":397,"address":[],"length":0,"stats":{"Line":7}},{"line":398,"address":[2122334],"length":1,"stats":{"Line":7}},{"line":402,"address":[],"length":0,"stats":{"Line":6}},{"line":403,"address":[2346929],"length":1,"stats":{"Line":6}},{"line":404,"address":[4120581,4120646],"length":1,"stats":{"Line":11}},{"line":405,"address":[],"length":0,"stats":{"Line":5}},{"line":406,"address":[4120642],"length":1,"stats":{"Line":5}},{"line":408,"address":[4120648],"length":1,"stats":{"Line":6}},{"line":416,"address":[6949117,6949201,6947168],"length":1,"stats":{"Line":1}},{"line":424,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":430,"address":[],"length":0,"stats":{"Line":1}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[6947937,6947869],"length":1,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":3}},{"line":437,"address":[],"length":0,"stats":{"Line":3}},{"line":438,"address":[6948706],"length":1,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[6948718,6949107],"length":1,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[6948335],"length":1,"stats":{"Line":1}},{"line":450,"address":[6948366],"length":1,"stats":{"Line":1}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":465,"address":[4120080],"length":1,"stats":{"Line":8}},{"line":467,"address":[3745362],"length":1,"stats":{"Line":8}},{"line":474,"address":[2462976],"length":1,"stats":{"Line":8}},{"line":476,"address":[2122613],"length":1,"stats":{"Line":8}},{"line":483,"address":[3747360],"length":1,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":2}},{"line":491,"address":[6939328],"length":1,"stats":{"Line":1}},{"line":492,"address":[6939345],"length":1,"stats":{"Line":1}},{"line":502,"address":[],"length":0,"stats":{"Line":16}},{"line":503,"address":[3144577],"length":1,"stats":{"Line":16}},{"line":504,"address":[2462118],"length":1,"stats":{"Line":18}},{"line":509,"address":[3140832,3143213],"length":1,"stats":{"Line":16}},{"line":513,"address":[3750315,3747515,3747665,3750465],"length":1,"stats":{"Line":33}},{"line":514,"address":[2458391,2460639],"length":1,"stats":{"Line":2}},{"line":517,"address":[5269917,5272717,5278317,5281117,5275517],"length":1,"stats":{"Line":17}},{"line":518,"address":[5278340,5272740,5269940,5281140,5275540],"length":1,"stats":{"Line":17}},{"line":519,"address":[6944522,6941738],"length":1,"stats":{"Line":18}},{"line":520,"address":[],"length":0,"stats":{"Line":18}},{"line":521,"address":[3141330],"length":1,"stats":{"Line":17}},{"line":522,"address":[3748044,3750844],"length":1,"stats":{"Line":17}},{"line":524,"address":[],"length":0,"stats":{"Line":17}},{"line":527,"address":[3748478,3751278],"length":1,"stats":{"Line":16}},{"line":528,"address":[2349265],"length":1,"stats":{"Line":18}},{"line":531,"address":[3751412,3748612],"length":1,"stats":{"Line":15}},{"line":532,"address":[6942580,6945364],"length":1,"stats":{"Line":15}},{"line":533,"address":[2349630],"length":1,"stats":{"Line":18}},{"line":534,"address":[3142501,3142425],"length":1,"stats":{"Line":33}},{"line":535,"address":[],"length":0,"stats":{"Line":16}},{"line":536,"address":[6945977,6943193],"length":1,"stats":{"Line":18}},{"line":538,"address":[2350308],"length":1,"stats":{"Line":16}},{"line":565,"address":[4121342,4121348,4120704],"length":1,"stats":{"Line":6}},{"line":574,"address":[3746174],"length":1,"stats":{"Line":6}},{"line":577,"address":[],"length":0,"stats":{"Line":12}},{"line":578,"address":[],"length":0,"stats":{"Line":6}},{"line":581,"address":[3140079,3140152],"length":1,"stats":{"Line":12}},{"line":582,"address":[2457447],"length":1,"stats":{"Line":6}},{"line":584,"address":[],"length":0,"stats":{"Line":6}},{"line":585,"address":[],"length":0,"stats":{"Line":6}},{"line":600,"address":[6946896],"length":1,"stats":{"Line":6}},{"line":601,"address":[6946930],"length":1,"stats":{"Line":6}},{"line":604,"address":[6946952],"length":1,"stats":{"Line":6}},{"line":606,"address":[3753174],"length":1,"stats":{"Line":6}},{"line":608,"address":[6946992,6947139],"length":1,"stats":{"Line":12}},{"line":610,"address":[],"length":0,"stats":{"Line":6}},{"line":612,"address":[6947084],"length":1,"stats":{"Line":6}},{"line":613,"address":[4124865],"length":1,"stats":{"Line":6}},{"line":615,"address":[4124883],"length":1,"stats":{"Line":6}},{"line":618,"address":[3753386],"length":1,"stats":{"Line":6}},{"line":619,"address":[4124915],"length":1,"stats":{"Line":6}},{"line":647,"address":[],"length":0,"stats":{"Line":6}},{"line":648,"address":[6952201],"length":1,"stats":{"Line":6}},{"line":649,"address":[6952246],"length":1,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[4126885],"length":1,"stats":{"Line":6}},{"line":655,"address":[],"length":0,"stats":{"Line":12}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[4138384],"length":1,"stats":{"Line":6}},{"line":666,"address":[6988885],"length":1,"stats":{"Line":6}},{"line":669,"address":[2409328],"length":1,"stats":{"Line":6}},{"line":670,"address":[4138405],"length":1,"stats":{"Line":6}},{"line":673,"address":[3810224,3810691],"length":1,"stats":{"Line":6}},{"line":675,"address":[2408796,2408731],"length":1,"stats":{"Line":12}},{"line":678,"address":[2518374],"length":1,"stats":{"Line":6}},{"line":679,"address":[6988508,6988784,6988803],"length":1,"stats":{"Line":20}},{"line":683,"address":[],"length":0,"stats":{"Line":12}},{"line":685,"address":[],"length":0,"stats":{"Line":6}}],"covered":161,"coverable":203},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","compiler","expression_lowerer.rs"],"content":"use alloc::boxed::Box;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::hash::Hash;\n\nuse hashbrown::{HashMap, HashSet};\nuse p3_field::{Field, PrimeCharacteristicRing};\n\nuse crate::builder::CircuitBuilderError;\nuse crate::builder::circuit_builder::{NonPrimitiveOpParams, NonPrimitiveOperationData};\nuse crate::builder::compiler::get_witness_id;\nuse crate::expr::{Expr, ExpressionGraph};\nuse crate::op::{NonPrimitiveOpType, Op, WitnessHintsFiller};\nuse crate::ops::Poseidon2PermExecutor;\nuse crate::types::{ExprId, NonPrimitiveOpId, WitnessAllocator, WitnessId};\n\n/// Sparse disjoint-set \"find\" with path compression over a HashMap (iterative).\n/// If `x` is not present, it's its own representative and is not inserted.\n#[inline]\nfn dsu_find(parents: \u0026mut HashMap\u003cusize, usize\u003e, x: usize) -\u003e usize {\n    let mut v = x;\n    let mut trail: Vec\u003cusize\u003e = Vec::new();\n    while let Some(\u0026p) = parents.get(\u0026v) {\n        if p == v {\n            break;\n        }\n        trail.push(v);\n        v = p;\n    }\n    let root = v;\n    for u in trail {\n        parents.insert(u, root);\n    }\n    root\n}\n\n/// Sparse disjoint-set \"union\" by attaching `b`'s root under `a`'s root.\n#[inline]\nfn dsu_union(parents: \u0026mut HashMap\u003cusize, usize\u003e, a: usize, b: usize) {\n    let ra = dsu_find(parents, a);\n    let rb = dsu_find(parents, b);\n    if ra != rb {\n        parents.insert(rb, ra);\n    }\n}\n\n/// Build a sparse disjoint-set forest honoring all pending connects.\n/// Returns a parent map keyed only by ExprIds that appear in `connects`.\nfn build_connect_dsu(connects: \u0026[(ExprId, ExprId)]) -\u003e HashMap\u003cusize, usize\u003e {\n    let mut parents: HashMap\u003cusize, usize\u003e = HashMap::new();\n    for (a, b) in connects {\n        let ai = a.0 as usize;\n        let bi = b.0 as usize;\n        dsu_union(\u0026mut parents, ai, bi);\n    }\n    parents\n}\n\n/// Responsible for lowering expression graphs to primitive operations.\n///\n/// This component handles:\n/// - Converting high-level expressions to primitive operations (Const, Public, Add, Mul, etc.)\n/// - Managing witness allocation during lowering\n/// - Implementing the DSU-based connection strategy for witness sharing\n/// - Building the mapping from ExprId to WitnessId\n#[derive(Debug)]\npub struct ExpressionLowerer\u003c'a, F\u003e {\n    /// Reference to the expression graph to lower\n    graph: \u0026'a ExpressionGraph\u003cF\u003e,\n\n    /// Non-primitive operations to lower (referenced by `Expr::NonPrimitiveOutput`)\n    non_primitive_ops: \u0026'a [NonPrimitiveOperationData],\n\n    /// Pending connections between expressions\n    pending_connects: \u0026'a [(ExprId, ExprId)],\n\n    /// Number of public inputs\n    public_input_count: usize,\n\n    /// The fillers corresponding to the witness hints sequences.\n    /// The order of fillers must match the order in which the witness hints sequences were allocated.\n    hints_fillers: \u0026'a [Box\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e],\n\n    /// Witness allocator\n    witness_alloc: WitnessAllocator,\n}\n\nimpl\u003c'a, F\u003e ExpressionLowerer\u003c'a, F\u003e\nwhere\n    F: Field + Clone + PrimeCharacteristicRing + PartialEq + Eq + Hash,\n{\n    /// Creates a new expression lowerer.\n    pub const fn new(\n        graph: \u0026'a ExpressionGraph\u003cF\u003e,\n        non_primitive_ops: \u0026'a [NonPrimitiveOperationData],\n        pending_connects: \u0026'a [(ExprId, ExprId)],\n        public_input_count: usize,\n        hints_fillers: \u0026'a [Box\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e],\n        witness_alloc: WitnessAllocator,\n    ) -\u003e Self {\n        Self {\n            graph,\n            non_primitive_ops,\n            pending_connects,\n            public_input_count,\n            hints_fillers,\n            witness_alloc,\n        }\n    }\n\n    fn emit_non_primitive_op\u003cAllocFn\u003e(\n        data: \u0026NonPrimitiveOperationData,\n        output_exprs: \u0026[(u32, ExprId)],\n        expr_to_widx: \u0026mut HashMap\u003cExprId, WitnessId\u003e,\n        alloc_witness_id_for_expr: \u0026mut AllocFn,\n        ops: \u0026mut Vec\u003cOp\u003cF\u003e\u003e,\n    ) -\u003e Result\u003c(), CircuitBuilderError\u003e\n    where\n        AllocFn: FnMut(usize) -\u003e WitnessId,\n    {\n        for (_output_idx, expr_id) in output_exprs {\n            expr_to_widx\n                .entry(*expr_id)\n                .or_insert_with(|| alloc_witness_id_for_expr(expr_id.0 as usize));\n        }\n\n        match \u0026data.op_type {\n            NonPrimitiveOpType::Poseidon2Perm =\u003e {\n                let (new_start, merkle_path) = match data.params.as_ref().ok_or_else(|| {\n                    CircuitBuilderError::InvalidNonPrimitiveOpConfiguration {\n                        op: data.op_type.clone(),\n                    }\n                })? {\n                    NonPrimitiveOpParams::Poseidon2Perm {\n                        new_start,\n                        merkle_path,\n                    } =\u003e (*new_start, *merkle_path),\n                };\n\n                // Expected input layout: [in0, in1, in2, in3, mmcs_index_sum, mmcs_bit]\n                if data.input_exprs.len() != 6 {\n                    return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                        op: \"Poseidon2Perm\",\n                        expected: \"6 inputs (in0..3, mmcs_index_sum, mmcs_bit)\".to_string(),\n                        got: data.input_exprs.len(),\n                    });\n                }\n\n                // Expected output layout: [out0, out1]\n                if data.output_exprs.len() != 2 {\n                    return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                        op: \"Poseidon2Perm\",\n                        expected: \"2 outputs (out0, out1)\".to_string(),\n                        got: data.output_exprs.len(),\n                    });\n                }\n\n                let mut inputs_widx: Vec\u003cVec\u003cWitnessId\u003e\u003e = Vec::with_capacity(6);\n                // Inputs (Limbs 0-3)\n                for (i, limb_exprs) in data.input_exprs.iter().take(4).enumerate() {\n                    if !(limb_exprs.is_empty() || limb_exprs.len() == 1) {\n                        return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                            op: \"Poseidon2Perm\",\n                            expected: \"0 or 1 extension element per input limb\".to_string(),\n                            got: limb_exprs.len(),\n                        });\n                    }\n                    let limb_widx = limb_exprs\n                        .iter()\n                        .map(|\u0026expr| {\n                            get_witness_id(\n                                expr_to_widx,\n                                expr,\n                                \u0026format!(\"Poseidon2Perm input limb {i}\"),\n                            )\n                        })\n                        .collect::\u003cResult\u003cVec\u003cWitnessId\u003e, _\u003e\u003e()?;\n                    inputs_widx.push(limb_widx);\n                }\n\n                // mmcs_index_sum (0 or 1 element)\n                let mmcs_exprs = \u0026data.input_exprs[4];\n                if !(mmcs_exprs.is_empty() || mmcs_exprs.len() == 1) {\n                    return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                        op: \"Poseidon2Perm\",\n                        expected: \"0 or 1 element for mmcs_index_sum\".to_string(),\n                        got: mmcs_exprs.len(),\n                    });\n                }\n                let mmcs_widx = mmcs_exprs\n                    .iter()\n                    .map(|\u0026expr| {\n                        get_witness_id(expr_to_widx, expr, \"Poseidon2Perm mmcs_index_sum input\")\n                    })\n                    .collect::\u003cResult\u003cVec\u003cWitnessId\u003e, _\u003e\u003e()?;\n                inputs_widx.push(mmcs_widx);\n\n                // mmcs_bit (0 or 1 element)\n                let mmcs_bit_exprs = \u0026data.input_exprs[5];\n                if !(mmcs_bit_exprs.is_empty() || mmcs_bit_exprs.len() == 1) {\n                    return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                        op: \"Poseidon2Perm\",\n                        expected: \"0 or 1 element for mmcs_bit\".to_string(),\n                        got: mmcs_bit_exprs.len(),\n                    });\n                }\n                let mmcs_bit_widx = mmcs_bit_exprs\n                    .iter()\n                    .map(|\u0026expr| get_witness_id(expr_to_widx, expr, \"Poseidon2Perm mmcs_bit input\"))\n                    .collect::\u003cResult\u003cVec\u003cWitnessId\u003e, _\u003e\u003e()?;\n                inputs_widx.push(mmcs_bit_widx);\n\n                // Output CTL exposures (0 or 1 element each).\n                //\n                // For Poseidon2Perm we take outputs exclusively from `data.output_exprs` to avoid\n                // generating multiple witness ids per output limb (which breaks both execution and\n                // trace building).\n                let mut poseidon2_outputs: Vec\u003cVec\u003cWitnessId\u003e\u003e = Vec::with_capacity(2);\n                for (i, limb_exprs) in data.output_exprs.iter().enumerate() {\n                    if !(limb_exprs.is_empty() || limb_exprs.len() == 1) {\n                        return Err(CircuitBuilderError::NonPrimitiveOpArity {\n                            op: \"Poseidon2Perm\",\n                            expected: \"0 or 1 extension element per output limb\".to_string(),\n                            got: limb_exprs.len(),\n                        });\n                    }\n                    if let Some(\u0026expr) = limb_exprs.first() {\n                        let w = get_witness_id(\n                            expr_to_widx,\n                            expr,\n                            \u0026format!(\"Poseidon2Perm output limb {i}\"),\n                        )?;\n                        poseidon2_outputs.push(vec![w]);\n                    } else {\n                        poseidon2_outputs.push(Vec::new());\n                    }\n                }\n\n                ops.push(Op::NonPrimitiveOpWithExecutor {\n                    inputs: inputs_widx,\n                    outputs: poseidon2_outputs,\n                    executor: Box::new(Poseidon2PermExecutor::new(new_start, merkle_path)),\n                    op_id: data.op_id,\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Lowers the expression graph to operations.\n    ///\n    /// Returns:\n    /// - Vector of operations\n    /// - Vector mapping public input positions to witness IDs\n    /// - HashMap mapping expression IDs to witness IDs\n    /// - HashMap mapping public input expression IDs to witness IDs\n    /// - Total witness count\n    #[allow(clippy::type_complexity)]\n    pub fn lower(\n        mut self,\n    ) -\u003e Result\u003c\n        (\n            Vec\u003cOp\u003cF\u003e\u003e,\n            Vec\u003cWitnessId\u003e,\n            HashMap\u003cExprId, WitnessId\u003e,\n            HashMap\u003cExprId, WitnessId\u003e,\n            u32,\n        ),\n        CircuitBuilderError,\n    \u003e {\n        // Precompute mapping from op_id -\u003e output expression nodes, to allow emitting an op once\n        // while still producing witness ids for all of its outputs.\n        let mut op_id_to_output_exprs: HashMap\u003cu32, Vec\u003c(u32, ExprId)\u003e\u003e = HashMap::new();\n        for (expr_idx, expr) in self.graph.nodes().iter().enumerate() {\n            if let Expr::NonPrimitiveOutput { call, output_idx } = expr {\n                // Look up the call expression to get the op_id\n                let Expr::NonPrimitiveCall { op_id, .. } = self.graph.get_expr(*call) else {\n                    return Err(CircuitBuilderError::MissingExprMapping {\n                        expr_id: *call,\n                        context: \"NonPrimitiveOutput.call must reference a NonPrimitiveCall\"\n                            .to_string(),\n                    });\n                };\n                op_id_to_output_exprs\n                    .entry(op_id.0)\n                    .or_default()\n                    .push((*output_idx, ExprId(expr_idx as u32)));\n            }\n        }\n        for outputs in op_id_to_output_exprs.values_mut() {\n            outputs.sort_by_key(|(output_idx, _)| *output_idx);\n        }\n        for (\u0026op_id_u32, outputs) in \u0026op_id_to_output_exprs {\n            // Enforce a simple invariant: output indices are a contiguous 0..N-1 range with no\n            // duplicates. This avoids silent mis-wiring due to gaps or repeated indices.\n            for (pos, (output_idx, _)) in outputs.iter().enumerate() {\n                if pos \u003e 0 \u0026\u0026 outputs[pos - 1].0 == *output_idx {\n                    return Err(CircuitBuilderError::MalformedNonPrimitiveOutputs {\n                        op_id: NonPrimitiveOpId(op_id_u32),\n                        details: format!(\"duplicate output_idx {output_idx}\"),\n                    });\n                }\n                if *output_idx != pos as u32 {\n                    return Err(CircuitBuilderError::MalformedNonPrimitiveOutputs {\n                        op_id: NonPrimitiveOpId(op_id_u32),\n                        details: format!(\n                            \"expected output_idx {expected}, got {output_idx}\",\n                            expected = pos as u32\n                        ),\n                    });\n                }\n            }\n        }\n\n        // Build DSU over expression IDs to honor connect(a, b)\n        let mut parents = build_connect_dsu(self.pending_connects);\n\n        // Track nodes that participate in any connect\n        let in_connect: HashSet\u003cusize\u003e = self\n            .pending_connects\n            .iter()\n            .flat_map(|(a, b)| [a.0 as usize, b.0 as usize])\n            .collect();\n\n        let mut ops = Vec::new();\n        let mut expr_to_widx: HashMap\u003cExprId, WitnessId\u003e = HashMap::new();\n        let mut public_rows: Vec\u003cWitnessId\u003e = vec![WitnessId(0); self.public_input_count];\n        let mut public_mappings = HashMap::new();\n\n        // Unified class slot map: DSU root -\u003e chosen out slot\n        let mut root_to_widx: HashMap\u003cusize, WitnessId\u003e = HashMap::new();\n\n        // Pass A: emit constants (once per Const node; Expr-level dedup ensures one per value)\n        for (expr_idx, expr) in self.graph.nodes().iter().enumerate() {\n            if let Expr::Const(val) = expr {\n                let id = ExprId(expr_idx as u32);\n                let w = self.witness_alloc.alloc();\n                ops.push(Op::Const { out: w, val: *val });\n                expr_to_widx.insert(id, w);\n\n                // If this Const participates in a connect class, bind the class to the const slot\n                if in_connect.contains(\u0026expr_idx) {\n                    let root = dsu_find(\u0026mut parents, expr_idx);\n                    root_to_widx.insert(root, w);\n                }\n            }\n        }\n\n        let mut alloc_witness_id_for_expr = |expr_idx: usize| {\n            if in_connect.contains(\u0026expr_idx) {\n                let root = dsu_find(\u0026mut parents, expr_idx);\n                *root_to_widx\n                    .entry(root)\n                    .or_insert_with(|| self.witness_alloc.alloc())\n            } else {\n                self.witness_alloc.alloc()\n            }\n        };\n\n        // Pass B: emit public inputs\n        for (expr_idx, expr) in self.graph.nodes().iter().enumerate() {\n            if let Expr::Public(pos) = expr {\n                let id = ExprId(expr_idx as u32);\n\n                let out_widx = alloc_witness_id_for_expr(expr_idx);\n\n                ops.push(Op::Public {\n                    out: out_widx,\n                    public_pos: *pos,\n                });\n                expr_to_widx.insert(id, out_widx);\n                public_rows[*pos] = out_widx;\n                public_mappings.insert(id, out_widx);\n            }\n        }\n\n        // Pass C: emit arithmetic and unconstrained ops in creation order; tie outputs to class slot if connected\n        let mut emitted_non_primitive_ops: HashSet\u003cu32\u003e = HashSet::new();\n\n        let mut hints_sequence = vec![];\n        let mut fillers_iter = self.hints_fillers.iter().cloned();\n        for (expr_idx, expr) in self.graph.nodes().iter().enumerate() {\n            let expr_id = ExprId(expr_idx as u32);\n            match expr {\n                Expr::Const(_) | Expr::Public(_) =\u003e { /* handled above */ }\n                Expr::Hint { is_last_hint } =\u003e {\n                    let expr_id = ExprId(expr_idx as u32);\n                    let out_widx = alloc_witness_id_for_expr(expr_idx);\n                    expr_to_widx.insert(expr_id, out_widx);\n                    hints_sequence.push(out_widx);\n                    if *is_last_hint {\n                        // Since new hints can only be added through `alloc_witness_hints` or `alloc_witness_hints_default_filler`,\n                        // there will always be exactly one filler for each sequence of expressions of the form\n                        // `Witness{false}, ..., Witness{false}, Witness{true}`.\n                        // Therefore, this error can only occur if the expression lowerer is not being used\n                        // with the circuit builder as intended.\n                        let filler = fillers_iter.next().ok_or_else(|| {\n                            CircuitBuilderError::MissingWitnessFiller {\n                                sequence: hints_sequence.clone(),\n                            }\n                        })?;\n                        let inputs = filler\n                            .inputs()\n                            .iter()\n                            .map(|expr_id| {\n                                expr_to_widx\n                                    .get(expr_id)\n                                    .ok_or_else(|| CircuitBuilderError::MissingExprMapping {\n                                        expr_id: *expr_id,\n                                        context: \"Unconstrained op\".to_string(),\n                                    })\n                                    .copied()\n                            })\n                            .collect::\u003cResult\u003cVec\u003cWitnessId\u003e, _\u003e\u003e()?;\n                        ops.push(Op::Unconstrained {\n                            inputs,\n                            outputs: hints_sequence,\n                            filler,\n                        });\n                        hints_sequence = vec![];\n                    }\n                }\n                Expr::Add { lhs, rhs } =\u003e {\n                    let out_widx = alloc_witness_id_for_expr(expr_idx);\n                    let a_widx =\n                        get_witness_id(\u0026expr_to_widx, *lhs, \u0026format!(\"Add lhs for {expr_id:?}\"))?;\n                    let b_widx =\n                        get_witness_id(\u0026expr_to_widx, *rhs, \u0026format!(\"Add rhs for {expr_id:?}\"))?;\n                    ops.push(Op::Add {\n                        a: a_widx,\n                        b: b_widx,\n                        out: out_widx,\n                    });\n                    expr_to_widx.insert(expr_id, out_widx);\n                }\n                Expr::Sub { lhs, rhs } =\u003e {\n                    let result_widx = alloc_witness_id_for_expr(expr_idx);\n                    let lhs_widx =\n                        get_witness_id(\u0026expr_to_widx, *lhs, \u0026format!(\"Sub lhs for {expr_id:?}\"))?;\n                    let rhs_widx =\n                        get_witness_id(\u0026expr_to_widx, *rhs, \u0026format!(\"Sub rhs for {expr_id:?}\"))?;\n                    // Encode lhs - rhs = result as result + rhs = lhs.\n                    ops.push(Op::Add {\n                        a: rhs_widx,\n                        b: result_widx,\n                        out: lhs_widx,\n                    });\n                    expr_to_widx.insert(expr_id, result_widx);\n                }\n                Expr::Mul { lhs, rhs } =\u003e {\n                    let out_widx = alloc_witness_id_for_expr(expr_idx);\n                    let a_widx =\n                        get_witness_id(\u0026expr_to_widx, *lhs, \u0026format!(\"Mul lhs for {expr_id:?}\"))?;\n                    let b_widx =\n                        get_witness_id(\u0026expr_to_widx, *rhs, \u0026format!(\"Mul rhs for {expr_id:?}\"))?;\n                    ops.push(Op::Mul {\n                        a: a_widx,\n                        b: b_widx,\n                        out: out_widx,\n                    });\n                    expr_to_widx.insert(expr_id, out_widx);\n                }\n                Expr::Div { lhs, rhs } =\u003e {\n                    // lhs / rhs = out  is encoded as rhs * out = lhs\n                    let b_widx = alloc_witness_id_for_expr(expr_idx);\n                    let out_widx =\n                        get_witness_id(\u0026expr_to_widx, *lhs, \u0026format!(\"Div lhs for {expr_id:?}\"))?;\n                    let a_widx =\n                        get_witness_id(\u0026expr_to_widx, *rhs, \u0026format!(\"Div rhs for {expr_id:?}\"))?;\n                    ops.push(Op::Mul {\n                        a: a_widx,\n                        b: b_widx,\n                        out: out_widx,\n                    });\n                    // The output of Div is the b_widx.\n                    expr_to_widx.insert(expr_id, b_widx);\n                }\n                Expr::NonPrimitiveCall { op_id, inputs: _ } =\u003e {\n                    // The `inputs` field encodes DAG dependencies for ordering purposes.\n                    // Actual input data is read from NonPrimitiveOperationData.\n                    if emitted_non_primitive_ops.insert(op_id.0) {\n                        let data = self\n                            .non_primitive_ops\n                            .get(op_id.0 as usize)\n                            .ok_or(CircuitBuilderError::MissingNonPrimitiveOp { op_id: *op_id })?;\n                        let outputs = op_id_to_output_exprs\n                            .get(\u0026op_id.0)\n                            .map(Vec::as_slice)\n                            .unwrap_or(\u0026[]);\n                        Self::emit_non_primitive_op(\n                            data,\n                            outputs,\n                            \u0026mut expr_to_widx,\n                            \u0026mut alloc_witness_id_for_expr,\n                            \u0026mut ops,\n                        )?;\n                    }\n                }\n                Expr::NonPrimitiveOutput {\n                    call,\n                    output_idx: _,\n                } =\u003e {\n                    // Look up the call expression to get the op_id\n                    let Expr::NonPrimitiveCall { op_id, .. } = self.graph.get_expr(*call) else {\n                        return Err(CircuitBuilderError::MissingExprMapping {\n                            expr_id: *call,\n                            context: \"NonPrimitiveOutput.call must reference a NonPrimitiveCall\"\n                                .to_string(),\n                        });\n                    };\n\n                    if emitted_non_primitive_ops.insert(op_id.0) {\n                        let data = self\n                            .non_primitive_ops\n                            .get(op_id.0 as usize)\n                            .ok_or(CircuitBuilderError::MissingNonPrimitiveOp { op_id: *op_id })?;\n                        let outputs = op_id_to_output_exprs\n                            .get(\u0026op_id.0)\n                            .map(Vec::as_slice)\n                            .unwrap_or(\u0026[]);\n                        Self::emit_non_primitive_op(\n                            data,\n                            outputs,\n                            \u0026mut expr_to_widx,\n                            \u0026mut alloc_witness_id_for_expr,\n                            \u0026mut ops,\n                        )?;\n                    }\n\n                    // This output node itself should now have a witness id assigned.\n                    expr_to_widx\n                        .entry(expr_id)\n                        .or_insert_with(|| alloc_witness_id_for_expr(expr_idx));\n                }\n            }\n        }\n\n        if !hints_sequence.is_empty() {\n            return Err(CircuitBuilderError::MalformedWitnessHintsSequence {\n                sequence: hints_sequence,\n            });\n        }\n\n        if fillers_iter.next().is_some() {\n            return Err(CircuitBuilderError::UnmatchedWitnessFiller {});\n        }\n\n        if emitted_non_primitive_ops.len() != self.non_primitive_ops.len() {\n            for data in self.non_primitive_ops {\n                if !emitted_non_primitive_ops.contains(\u0026data.op_id.0) {\n                    return Err(CircuitBuilderError::UnanchoredNonPrimitiveOp {\n                        op_id: data.op_id,\n                    });\n                }\n            }\n        }\n\n        let witness_count = self.witness_alloc.witness_count();\n        Ok((\n            ops,\n            public_rows,\n            expr_to_widx,\n            public_mappings,\n            witness_count,\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n\n    use super::*;\n\n    /// Helper to create an expression graph with a zero constant pre-allocated.\n    fn create_graph_with_zero() -\u003e ExpressionGraph\u003cBabyBear\u003e {\n        let mut graph = ExpressionGraph::new();\n        graph.add_expr(Expr::Const(BabyBear::ZERO));\n        graph\n    }\n\n    #[test]\n    fn test_dsu_utilities() {\n        // Single element is its own root when not in the map\n        let mut parents = HashMap::new();\n        assert_eq!(dsu_find(\u0026mut parents, 5), 5);\n\n        // Path compression: chain 1 -\u003e 2 -\u003e 3 where 3 is root\n        parents.clear();\n        parents.insert(1, 2);\n        parents.insert(2, 3);\n        parents.insert(3, 3);\n        assert_eq!(dsu_find(\u0026mut parents, 1), 3);\n        assert_eq!(parents[\u00261], 3); // Path compression applies\n\n        // Union merges two elements\n        parents.clear();\n        dsu_union(\u0026mut parents, 10, 20);\n        assert_eq!(dsu_find(\u0026mut parents, 10), dsu_find(\u0026mut parents, 20));\n\n        // Union is idempotent\n        parents.clear();\n        dsu_union(\u0026mut parents, 7, 7);\n        assert_eq!(dsu_find(\u0026mut parents, 7), 7);\n    }\n\n    #[test]\n    fn test_build_connect_dsu() {\n        // Empty connections\n        let connects = vec![];\n        let parents = build_connect_dsu(\u0026connects);\n        assert!(parents.is_empty());\n\n        // Single pair connection\n        let connects = vec![(ExprId(1), ExprId(2))];\n        let mut parents = build_connect_dsu(\u0026connects);\n        assert_eq!(dsu_find(\u0026mut parents, 1), dsu_find(\u0026mut parents, 2));\n\n        // Transitive chain: 0 -\u003e 1 -\u003e 2 -\u003e 3 all share same root\n        let connects = vec![\n            (ExprId(0), ExprId(1)),\n            (ExprId(1), ExprId(2)),\n            (ExprId(2), ExprId(3)),\n        ];\n        let mut parents = build_connect_dsu(\u0026connects);\n        let root = dsu_find(\u0026mut parents, 0);\n        assert_eq!(root, dsu_find(\u0026mut parents, 1));\n        assert_eq!(root, dsu_find(\u0026mut parents, 2));\n        assert_eq!(root, dsu_find(\u0026mut parents, 3));\n\n        // Multiple disjoint components: (0,1) separate from (2,3)\n        let connects = vec![(ExprId(0), ExprId(1)), (ExprId(2), ExprId(3))];\n        let mut parents = build_connect_dsu(\u0026connects);\n        let root01 = dsu_find(\u0026mut parents, 0);\n        assert_eq!(root01, dsu_find(\u0026mut parents, 1));\n        let root23 = dsu_find(\u0026mut parents, 2);\n        assert_eq!(root23, dsu_find(\u0026mut parents, 3));\n        assert_ne!(root01, root23);\n    }\n\n    #[test]\n    fn test_lowering() {\n        // Build a circuit exercising all primitive types and operations:\n        // - Multiple constants (zero, one, 3, 7)\n        // - Public inputs (positions 0, 1, 2)\n        // - Arithmetic operations: Add, Sub, Mul, Div\n        // - Circuit computes: ((p0 + p1) * c3 - c7) / p2\n        let mut graph = create_graph_with_zero();\n\n        // Constants\n        let c_zero = ExprId::ZERO; // Pre-allocated\n        let c_one = graph.add_expr(Expr::Const(BabyBear::ONE));\n        let c_three = graph.add_expr(Expr::Const(BabyBear::from_u64(3)));\n        let c_seven = graph.add_expr(Expr::Const(BabyBear::from_u64(7)));\n\n        // Public inputs\n        let p0 = graph.add_expr(Expr::Public(0));\n        let p1 = graph.add_expr(Expr::Public(1));\n        let p2 = graph.add_expr(Expr::Public(2));\n\n        // Operations: (p0 + p1) * c3 - c7\n        let sum = graph.add_expr(Expr::Add { lhs: p0, rhs: p1 });\n        let prod = graph.add_expr(Expr::Mul {\n            lhs: sum,\n            rhs: c_three,\n        });\n        let diff = graph.add_expr(Expr::Sub {\n            lhs: prod,\n            rhs: c_seven,\n        });\n\n        // Final division: diff / p2\n        let quot = graph.add_expr(Expr::Div { lhs: diff, rhs: p2 });\n\n        let connects = vec![];\n        let hints_fillers = vec![];\n        let alloc = WitnessAllocator::new();\n\n        let lowerer = ExpressionLowerer::new(\u0026graph, \u0026[], \u0026connects, 3, \u0026hints_fillers, alloc);\n        let (prims, public_rows, expr_map, public_map, witness_count) = lowerer.lower().unwrap();\n\n        // Verify Primitives\n        //\n        // Expected: 4 Const + 3 Public + 1 Add + 1 Mul + 1 Add (Sub) + 1 Mul (Div) = 11 total\n        assert_eq!(prims.len(), 11);\n\n        // Constants (Pass A): zero, one, three, seven\n        match \u0026prims[0] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 0);\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const at position 0\"),\n        }\n        match \u0026prims[1] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 1);\n                assert_eq!(*val, BabyBear::ONE);\n            }\n            _ =\u003e panic!(\"Expected Const at position 1\"),\n        }\n        match \u0026prims[2] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 2);\n                assert_eq!(*val, BabyBear::from_u64(3));\n            }\n            _ =\u003e panic!(\"Expected Const at position 2\"),\n        }\n        match \u0026prims[3] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 3);\n                assert_eq!(*val, BabyBear::from_u64(7));\n            }\n            _ =\u003e panic!(\"Expected Const at position 3\"),\n        }\n\n        // Public inputs (Pass B): p0, p1, p2\n        match \u0026prims[4] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 4);\n                assert_eq!(*public_pos, 0);\n            }\n            _ =\u003e panic!(\"Expected Public at position 4\"),\n        }\n        match \u0026prims[5] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 5);\n                assert_eq!(*public_pos, 1);\n            }\n            _ =\u003e panic!(\"Expected Public at position 5\"),\n        }\n        match \u0026prims[6] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 6);\n                assert_eq!(*public_pos, 2);\n            }\n            _ =\u003e panic!(\"Expected Public at position 6\"),\n        }\n\n        // Arithmetic operations (Pass C): Add, Mul, Add (encoding Sub), Mul (encoding Div)\n        // Add: sum = p0 + p1\n        match \u0026prims[7] {\n            Op::Add { a, b, out } =\u003e {\n                assert_eq!(*a, WitnessId(4)); // p0\n                assert_eq!(*b, WitnessId(5)); // p1\n                assert_eq!(out.0, 7); // sum\n            }\n            _ =\u003e panic!(\"Expected Add at position 7\"),\n        }\n\n        // Mul: prod = sum * c3\n        match \u0026prims[8] {\n            Op::Mul { a, b, out } =\u003e {\n                assert_eq!(*a, WitnessId(7)); // sum\n                assert_eq!(*b, WitnessId(2)); // c_three\n                assert_eq!(out.0, 8); // prod\n            }\n            _ =\u003e panic!(\"Expected Mul at position 8\"),\n        }\n\n        // Sub encoded as Add: diff + c7 = prod\n        match \u0026prims[9] {\n            Op::Add { a, b, out } =\u003e {\n                assert_eq!(*a, WitnessId(3)); // c_seven (rhs)\n                assert_eq!(*b, WitnessId(9)); // diff (result)\n                assert_eq!(*out, WitnessId(8)); // prod (lhs)\n            }\n            _ =\u003e panic!(\"Expected Add (Sub encoding) at position 9\"),\n        }\n\n        // Div encoded as Mul: p2 * quot = diff\n        match \u0026prims[10] {\n            Op::Mul { a, b, out } =\u003e {\n                assert_eq!(*a, WitnessId(6)); // p2 (divisor)\n                assert_eq!(*b, WitnessId(10)); // quot (result)\n                assert_eq!(*out, WitnessId(9)); // diff (dividend)\n            }\n            _ =\u003e panic!(\"Expected Mul (Div encoding) at position 10\"),\n        }\n\n        // Verify Public Rows\n        assert_eq!(public_rows.len(), 3);\n        assert_eq!(public_rows[0], WitnessId(4)); // p0\n        assert_eq!(public_rows[1], WitnessId(5)); // p1\n        assert_eq!(public_rows[2], WitnessId(6)); // p2\n\n        // Verify Expression to Witness Mapping\n        assert_eq!(expr_map.len(), 11); // All 11 expressions mapped\n        assert_eq!(expr_map[\u0026c_zero], WitnessId(0));\n        assert_eq!(expr_map[\u0026c_one], WitnessId(1));\n        assert_eq!(expr_map[\u0026c_three], WitnessId(2));\n        assert_eq!(expr_map[\u0026c_seven], WitnessId(3));\n        assert_eq!(expr_map[\u0026p0], WitnessId(4));\n        assert_eq!(expr_map[\u0026p1], WitnessId(5));\n        assert_eq!(expr_map[\u0026p2], WitnessId(6));\n        assert_eq!(expr_map[\u0026sum], WitnessId(7));\n        assert_eq!(expr_map[\u0026prod], WitnessId(8));\n        assert_eq!(expr_map[\u0026diff], WitnessId(9));\n        assert_eq!(expr_map[\u0026quot], WitnessId(10));\n\n        // Verify Public Mapping\n        assert_eq!(public_map.len(), 3);\n        assert_eq!(public_map[\u0026p0], WitnessId(4));\n        assert_eq!(public_map[\u0026p1], WitnessId(5));\n        assert_eq!(public_map[\u0026p2], WitnessId(6));\n\n        // Verify Witness Count\n        assert_eq!(witness_count, 11);\n    }\n\n    #[test]\n    fn test_witness_sharing() {\n        // Test witness sharing scenarios:\n        // 1. Constants connected to publics (const binds the shared witness)\n        // 2. Transitive connections among publics (all share one witness)\n        // 3. Operation results connected to other expressions\n        // 4. Multiple disjoint connection groups\n        //\n        // Circuit: c42 ~ p0, p1 ~ p2 ~ p3, (p0 + c1) ~ p4, c99 (standalone)\n        let mut graph = create_graph_with_zero();\n\n        // Constants\n        let c_zero = ExprId::ZERO;\n        let c_one = graph.add_expr(Expr::Const(BabyBear::ONE));\n        let c_42 = graph.add_expr(Expr::Const(BabyBear::from_u64(42)));\n        let c_99 = graph.add_expr(Expr::Const(BabyBear::from_u64(99)));\n\n        // Public inputs\n        let p0 = graph.add_expr(Expr::Public(0));\n        let p1 = graph.add_expr(Expr::Public(1));\n        let p2 = graph.add_expr(Expr::Public(2));\n        let p3 = graph.add_expr(Expr::Public(3));\n        let p4 = graph.add_expr(Expr::Public(4));\n\n        // Operation: sum = p0 + c1\n        let sum = graph.add_expr(Expr::Add {\n            lhs: p0,\n            rhs: c_one,\n        });\n\n        // Connections:\n        // Group A: c42 ~ p0 (const binds witness)\n        // Group B: p1 ~ p2 ~ p3 (transitive)\n        // Group C: sum ~ p4 (operation result shared)\n        let connects = vec![(c_42, p0), (p1, p2), (p2, p3), (sum, p4)];\n        let hints_fillers = vec![];\n        let alloc = WitnessAllocator::new();\n\n        let lowerer = ExpressionLowerer::new(\u0026graph, \u0026[], \u0026connects, 5, \u0026hints_fillers, alloc);\n        let (prims, public_rows, expr_map, public_map, witness_count) = lowerer.lower().unwrap();\n\n        // Verify Primitives\n        //\n        // 4 Const + 5 Public + 1 Add = 10 primitives\n        assert_eq!(prims.len(), 10);\n\n        // Constants\n        match \u0026prims[0] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 0);\n                assert_eq!(*val, BabyBear::ZERO);\n            }\n            _ =\u003e panic!(\"Expected Const(0) at position 0\"),\n        }\n        match \u0026prims[1] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 1);\n                assert_eq!(*val, BabyBear::ONE);\n            }\n            _ =\u003e panic!(\"Expected Const(1) at position 1\"),\n        }\n        match \u0026prims[2] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 2); // c42's witness (will be shared with p0)\n                assert_eq!(*val, BabyBear::from_u64(42));\n            }\n            _ =\u003e panic!(\"Expected Const(42) at position 2\"),\n        }\n        match \u0026prims[3] {\n            Op::Const { out, val } =\u003e {\n                assert_eq!(out.0, 3);\n                assert_eq!(*val, BabyBear::from_u64(99));\n            }\n            _ =\u003e panic!(\"Expected Const(99) at position 3\"),\n        }\n\n        // Public inputs\n        match \u0026prims[4] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 2); // Shares witness with c42\n                assert_eq!(*public_pos, 0);\n            }\n            _ =\u003e panic!(\"Expected Public(0) at position 4\"),\n        }\n        match \u0026prims[5] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 4); // New witness for p1 group\n                assert_eq!(*public_pos, 1);\n            }\n            _ =\u003e panic!(\"Expected Public(1) at position 5\"),\n        }\n        match \u0026prims[6] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 4); // Shares witness with p1\n                assert_eq!(*public_pos, 2);\n            }\n            _ =\u003e panic!(\"Expected Public(2) at position 6\"),\n        }\n        match \u0026prims[7] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 4); // Shares witness with p1, p2\n                assert_eq!(*public_pos, 3);\n            }\n            _ =\u003e panic!(\"Expected Public(3) at position 7\"),\n        }\n        match \u0026prims[8] {\n            Op::Public { out, public_pos } =\u003e {\n                assert_eq!(out.0, 5); // New witness for p4 group\n                assert_eq!(*public_pos, 4);\n            }\n            _ =\u003e panic!(\"Expected Public(4) at position 8\"),\n        }\n\n        // Add operation: sum = p0 + c1\n        match \u0026prims[9] {\n            Op::Add { a, b, out } =\u003e {\n                assert_eq!(*a, WitnessId(2)); // p0 (shares with c42)\n                assert_eq!(*b, WitnessId(1)); // c1\n                assert_eq!(*out, WitnessId(5)); // sum (shares with p4)\n            }\n            _ =\u003e panic!(\"Expected Add at position 9\"),\n        }\n\n        // Verify Public Rows\n        assert_eq!(public_rows.len(), 5);\n        assert_eq!(public_rows[0], WitnessId(2)); // p0 shares with c42\n        assert_eq!(public_rows[1], WitnessId(4)); // p1, p2, p3 all share\n        assert_eq!(public_rows[2], WitnessId(4));\n        assert_eq!(public_rows[3], WitnessId(4));\n        assert_eq!(public_rows[4], WitnessId(5)); // p4 shares with sum\n\n        // Verify Expression to Witness Mapping\n        assert_eq!(expr_map.len(), 10);\n\n        // Group A: c42 ~ p0 both map to witness 2\n        assert_eq!(expr_map[\u0026c_42], WitnessId(2));\n        assert_eq!(expr_map[\u0026p0], WitnessId(2));\n\n        // Group B: p1, p2, p3 all map to witness 4\n        assert_eq!(expr_map[\u0026p1], WitnessId(4));\n        assert_eq!(expr_map[\u0026p2], WitnessId(4));\n        assert_eq!(expr_map[\u0026p3], WitnessId(4));\n\n        // Group C: sum ~ p4 both map to witness 5\n        assert_eq!(expr_map[\u0026sum], WitnessId(5));\n        assert_eq!(expr_map[\u0026p4], WitnessId(5));\n\n        // Standalone expressions\n        assert_eq!(expr_map[\u0026c_zero], WitnessId(0));\n        assert_eq!(expr_map[\u0026c_one], WitnessId(1));\n        assert_eq!(expr_map[\u0026c_99], WitnessId(3));\n\n        // Verify Public Mapping\n        assert_eq!(public_map.len(), 5);\n        assert_eq!(public_map[\u0026p0], WitnessId(2));\n        assert_eq!(public_map[\u0026p1], WitnessId(4));\n        assert_eq!(public_map[\u0026p2], WitnessId(4));\n        assert_eq!(public_map[\u0026p3], WitnessId(4));\n        assert_eq!(public_map[\u0026p4], WitnessId(5));\n\n        // Verify Witness Count\n        //\n        // Witnesses: 0 (zero), 1 (one), 2 (c42/p0), 3 (c99), 4 (p1/p2/p3), 5 (sum/p4)\n        assert_eq!(witness_count, 6);\n    }\n\n    #[test]\n    fn test_error_handling() {\n        // Test 1: Missing expression in Add operand\n        let mut graph = create_graph_with_zero();\n        graph.add_expr(Expr::Add {\n            lhs: ExprId(99), // Non-existent\n            rhs: ExprId::ZERO,\n        });\n\n        let connects = vec![];\n        let hints_fillers = vec![];\n        let alloc = WitnessAllocator::new();\n        let lowerer = ExpressionLowerer::new(\u0026graph, \u0026[], \u0026connects, 0, \u0026hints_fillers, alloc);\n        let result = lowerer.lower();\n\n        assert!(result.is_err());\n        match result {\n            Err(CircuitBuilderError::MissingExprMapping { expr_id, context }) =\u003e {\n                assert_eq!(expr_id, ExprId(99));\n                assert!(context.contains(\"Add lhs\"));\n            }\n            _ =\u003e panic!(\"Expected MissingExprMapping error for Add lhs\"),\n        }\n\n        // Test 2: Missing expression in Mul operand\n        let mut graph = create_graph_with_zero();\n        graph.add_expr(Expr::Mul {\n            lhs: ExprId::ZERO,\n            rhs: ExprId(88), // Non-existent\n        });\n\n        let connects = vec![];\n        let hints_fillers = vec![];\n        let alloc = WitnessAllocator::new();\n        let lowerer = ExpressionLowerer::new(\u0026graph, \u0026[], \u0026connects, 0, \u0026hints_fillers, alloc);\n        let result = lowerer.lower();\n\n        assert!(result.is_err());\n        match result {\n            Err(CircuitBuilderError::MissingExprMapping { expr_id, context }) =\u003e {\n                assert_eq!(expr_id, ExprId(88));\n                assert!(context.contains(\"Mul rhs\"));\n            }\n            _ =\u003e panic!(\"Expected MissingExprMapping error for Mul rhs\"),\n        }\n\n        // Test 3: Helper function error propagation\n        let expr_map = HashMap::new();\n        let result = get_witness_id(\u0026expr_map, ExprId(77), \"test context\");\n\n        match result {\n            Err(CircuitBuilderError::MissingExprMapping { expr_id, context }) =\u003e {\n                assert_eq!(expr_id, ExprId(77));\n                assert_eq!(context, \"test context\");\n            }\n            _ =\u003e panic!(\"Expected MissingExprMapping error from get_witness_id\"),\n        }\n    }\n\n    // Property-based tests for DSU utilities and connect DSU construction\n    #[cfg(test)]\n    mod proptests {\n        use proptest::prelude::*;\n\n        use super::*;\n\n        // Strategy for generating lists of ExprId connect relations\n        fn connections(max_id: u32) -\u003e impl Strategy\u003cValue = Vec\u003c(ExprId, ExprId)\u003e\u003e {\n            prop::collection::vec((0..max_id, 0..max_id), 0..20).prop_map(|pairs| {\n                pairs\n                    .into_iter()\n                    .map(|(a, b)| (ExprId(a), ExprId(b)))\n                    .collect()\n            })\n        }\n\n        proptest! {\n            #[test]\n            fn dsu_find_idempotent(connects in connections(50)) {\n                let mut parents = build_connect_dsu(\u0026connects);\n                let test_ids: Vec\u003cusize\u003e = (0..50).collect();\n\n                for \u0026id in \u0026test_ids {\n                    let root1 = dsu_find(\u0026mut parents, id);\n                    let root2 = dsu_find(\u0026mut parents, id);\n                    prop_assert_eq!(root1, root2, \"dsu_find should be idempotent\");\n                }\n            }\n\n            #[test]\n            fn dsu_union_transitivity(connects in connections(30)) {\n                let mut parents = build_connect_dsu(\u0026connects);\n\n                // Check that all explicitly connected pairs have the same root\n                for (a, b) in \u0026connects {\n                    let ra = dsu_find(\u0026mut parents, a.0 as usize);\n                    let rb = dsu_find(\u0026mut parents, b.0 as usize);\n                    prop_assert_eq!(ra, rb, \"connected nodes should have same root\");\n                }\n            }\n\n            #[test]\n            fn dsu_union_commutative(a in 0u32..100, b in 0u32..100) {\n                let mut parents1 = HashMap::new();\n                let mut parents2 = HashMap::new();\n\n                dsu_union(\u0026mut parents1, a as usize, b as usize);\n                dsu_union(\u0026mut parents2, b as usize, a as usize);\n\n                let r1a = dsu_find(\u0026mut parents1, a as usize);\n                let r1b = dsu_find(\u0026mut parents1, b as usize);\n                let r2a = dsu_find(\u0026mut parents2, a as usize);\n                let r2b = dsu_find(\u0026mut parents2, b as usize);\n\n                prop_assert_eq!(r1a, r1b, \"union should connect a and b\");\n                prop_assert_eq!(r2a, r2b, \"union should connect b and a\");\n            }\n        }\n    }\n}\n","traces":[{"line":21,"address":[8049632,8050184,8050190],"length":1,"stats":{"Line":18}},{"line":22,"address":[5004812],"length":1,"stats":{"Line":18}},{"line":23,"address":[3105401],"length":1,"stats":{"Line":18}},{"line":24,"address":[8049764,8049932,8049697],"length":1,"stats":{"Line":52}},{"line":25,"address":[3848490],"length":1,"stats":{"Line":16}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[3970173],"length":1,"stats":{"Line":16}},{"line":29,"address":[3848599],"length":1,"stats":{"Line":15}},{"line":31,"address":[2219105],"length":1,"stats":{"Line":18}},{"line":32,"address":[10554264,10554035,10554129],"length":1,"stats":{"Line":54}},{"line":33,"address":[10956400,10956451],"length":1,"stats":{"Line":31}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[3854320],"length":1,"stats":{"Line":10}},{"line":41,"address":[8050252],"length":1,"stats":{"Line":10}},{"line":42,"address":[7330052],"length":1,"stats":{"Line":10}},{"line":43,"address":[10554491],"length":1,"stats":{"Line":10}},{"line":44,"address":[10956595],"length":1,"stats":{"Line":9}},{"line":50,"address":[5268551,5268240,5268557],"length":1,"stats":{"Line":11}},{"line":51,"address":[8049336],"length":1,"stats":{"Line":9}},{"line":52,"address":[10955704,10955632],"length":1,"stats":{"Line":21}},{"line":53,"address":[7286748],"length":1,"stats":{"Line":10}},{"line":54,"address":[3848216],"length":1,"stats":{"Line":10}},{"line":55,"address":[10955874,10955834],"length":1,"stats":{"Line":19}},{"line":57,"address":[8049574],"length":1,"stats":{"Line":11}},{"line":94,"address":[1591648],"length":1,"stats":{"Line":16}},{"line":112,"address":[2305584,2299696,2305220,2301294,2307182,2311108],"length":1,"stats":{"Line":1}},{"line":122,"address":[7292813,7286989,7292874,7287050],"length":1,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[3594581],"length":1,"stats":{"Line":1}},{"line":125,"address":[7287189,7293013,7299374,7298816,7298830,7299360],"length":1,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[2762071,2767504,2761980,2761855],"length":1,"stats":{"Line":2}},{"line":131,"address":[2895987],"length":1,"stats":{"Line":0}},{"line":132,"address":[1841936],"length":1,"stats":{"Line":0}},{"line":135,"address":[4898381,4921933,4910157,4916045,4904269],"length":1,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[7293274,7287450],"length":1,"stats":{"Line":1}},{"line":143,"address":[4903615,4909503,4915391,4927167,4921279],"length":1,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[1836629],"length":1,"stats":{"Line":0}},{"line":151,"address":[2300318,2306206],"length":1,"stats":{"Line":1}},{"line":152,"address":[1841561],"length":1,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[2198232],"length":1,"stats":{"Line":0}},{"line":155,"address":[7287635,7293459],"length":1,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[1841436,1836685,1836832],"length":1,"stats":{"Line":3}},{"line":162,"address":[1589993,1586387,1590052],"length":1,"stats":{"Line":3}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[7291652,7297476],"length":1,"stats":{"Line":0}},{"line":166,"address":[1590097],"length":1,"stats":{"Line":0}},{"line":169,"address":[1590379,1590479,1590027],"length":1,"stats":{"Line":2}},{"line":171,"address":[4929585,4929899,4928496,4914749,4929633,4926525,4927857,4928795,4902973,4929280,4927585,4928177,4929905,4908861,4927552,4927905,4929579,4929600,4927872,4928529,4928171,4927851,4928801,4920637,4929313],"length":1,"stats":{"Line":3}},{"line":172,"address":[2767880],"length":1,"stats":{"Line":1}},{"line":173,"address":[4927598,4927918,4928542,4929646,4929326],"length":1,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[2311702,2312054],"length":1,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[1837164],"length":1,"stats":{"Line":1}},{"line":184,"address":[1837211,1837303],"length":1,"stats":{"Line":1}},{"line":185,"address":[3595743],"length":1,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[3595629],"length":1,"stats":{"Line":0}},{"line":188,"address":[7288222,7294046],"length":1,"stats":{"Line":0}},{"line":191,"address":[4905045,4905549,4902621,4910933,4899157,4899561,4911337,4916821,4905449,4920285,4917225,4923113,4914397,4926173,4899661,4911437,4922709,4923213,4917325,4908509],"length":1,"stats":{"Line":2}},{"line":193,"address":[2891339,2895574,2895552],"length":1,"stats":{"Line":1}},{"line":194,"address":[1591468],"length":1,"stats":{"Line":0}},{"line":197,"address":[3596190],"length":1,"stats":{"Line":1}},{"line":200,"address":[2891694],"length":1,"stats":{"Line":1}},{"line":201,"address":[2199641,2199549],"length":1,"stats":{"Line":1}},{"line":202,"address":[2763777],"length":1,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[1838127],"length":1,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[2892138,2896048,2896070],"length":1,"stats":{"Line":1}},{"line":212,"address":[4900557,4918221,4924109,4906445,4912333],"length":1,"stats":{"Line":1}},{"line":219,"address":[3597106],"length":1,"stats":{"Line":1}},{"line":220,"address":[2764430,2764337],"length":1,"stats":{"Line":2}},{"line":221,"address":[2764697,2765156,2765221],"length":1,"stats":{"Line":3}},{"line":222,"address":[7290653,7296477],"length":1,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[1588978],"length":1,"stats":{"Line":0}},{"line":228,"address":[2893640,2893369],"length":1,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[1840013,1840058],"length":1,"stats":{"Line":2}},{"line":234,"address":[3598771],"length":1,"stats":{"Line":1}},{"line":236,"address":[3598977,3598368],"length":1,"stats":{"Line":0}},{"line":240,"address":[1839417],"length":1,"stats":{"Line":1}},{"line":241,"address":[2892904],"length":1,"stats":{"Line":1}},{"line":242,"address":[1588480],"length":1,"stats":{"Line":1}},{"line":243,"address":[2893075,2892984],"length":1,"stats":{"Line":2}},{"line":244,"address":[2309046,2303158],"length":1,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[2910500,2896224,2900503],"length":1,"stats":{"Line":17}},{"line":275,"address":[4973534,4930686,4959230,4987838,4944958],"length":1,"stats":{"Line":16}},{"line":276,"address":[2768171,2768253],"length":1,"stats":{"Line":32}},{"line":277,"address":[2910115,2896696],"length":1,"stats":{"Line":17}},{"line":279,"address":[2910155],"length":1,"stats":{"Line":1}},{"line":280,"address":[1605897],"length":1,"stats":{"Line":0}},{"line":281,"address":[3614866],"length":1,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[7328090,7313880],"length":1,"stats":{"Line":1}},{"line":287,"address":[2326837,2341123],"length":1,"stats":{"Line":1}},{"line":289,"address":[2341229,2326943],"length":1,"stats":{"Line":1}},{"line":292,"address":[2204576],"length":1,"stats":{"Line":15}},{"line":293,"address":[],"length":0,"stats":{"Line":4}},{"line":295,"address":[2896952],"length":1,"stats":{"Line":17}},{"line":298,"address":[7314935,7312609,7300743,7326819],"length":1,"stats":{"Line":2}},{"line":299,"address":[1855615,1855654],"length":1,"stats":{"Line":2}},{"line":300,"address":[7313468,7327678],"length":1,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[2781287,2781659],"length":1,"stats":{"Line":0}},{"line":305,"address":[3613928],"length":1,"stats":{"Line":1}},{"line":306,"address":[1605232],"length":1,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[7313031,7327241],"length":1,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[7313016,7327226],"length":1,"stats":{"Line":0}},{"line":318,"address":[4960121,4931577,4945849,4974425,4988691],"length":1,"stats":{"Line":15}},{"line":321,"address":[2897196],"length":1,"stats":{"Line":15}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[3601903,3615392,3615376],"length":1,"stats":{"Line":46}},{"line":327,"address":[1843621],"length":1,"stats":{"Line":16}},{"line":328,"address":[2769201],"length":1,"stats":{"Line":16}},{"line":329,"address":[1843734,1843801],"length":1,"stats":{"Line":32}},{"line":330,"address":[7301137,7315329],"length":1,"stats":{"Line":15}},{"line":333,"address":[1593110],"length":1,"stats":{"Line":16}},{"line":336,"address":[7301251,7301330,7315443,7315522],"length":1,"stats":{"Line":32}},{"line":337,"address":[],"length":0,"stats":{"Line":33}},{"line":338,"address":[3613330],"length":1,"stats":{"Line":17}},{"line":339,"address":[1855031],"length":1,"stats":{"Line":17}},{"line":340,"address":[2216595],"length":1,"stats":{"Line":17}},{"line":341,"address":[1855172],"length":1,"stats":{"Line":15}},{"line":344,"address":[2780731],"length":1,"stats":{"Line":17}},{"line":345,"address":[2908931],"length":1,"stats":{"Line":15}},{"line":346,"address":[2216795],"length":1,"stats":{"Line":15}},{"line":351,"address":[7328896,7301653,7315845,7328656],"length":1,"stats":{"Line":30}},{"line":352,"address":[1606354],"length":1,"stats":{"Line":15}},{"line":353,"address":[],"length":0,"stats":{"Line":15}},{"line":354,"address":[2341765,2341797,2341941,2341909],"length":1,"stats":{"Line":30}},{"line":355,"address":[1606425],"length":1,"stats":{"Line":15}},{"line":356,"address":[2782917,2782631,2782912],"length":1,"stats":{"Line":31}},{"line":358,"address":[7328935,7328695],"length":1,"stats":{"Line":15}},{"line":363,"address":[4989600,4932524,4961068,4975372,4946796],"length":1,"stats":{"Line":17}},{"line":364,"address":[3613041,3603025],"length":1,"stats":{"Line":33}},{"line":365,"address":[2216261],"length":1,"stats":{"Line":15}},{"line":367,"address":[2325069,2339373],"length":1,"stats":{"Line":15}},{"line":369,"address":[1854804],"length":1,"stats":{"Line":16}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[7312057,7326249],"length":1,"stats":{"Line":15}},{"line":373,"address":[2325186,2339490],"length":1,"stats":{"Line":15}},{"line":374,"address":[7326345,7312153],"length":1,"stats":{"Line":17}},{"line":375,"address":[4957362,4943090,4985938,4971634,5000061],"length":1,"stats":{"Line":16}},{"line":380,"address":[2898481],"length":1,"stats":{"Line":16}},{"line":382,"address":[2206304],"length":1,"stats":{"Line":18}},{"line":383,"address":[2329447,2315143,2329540,2315236],"length":1,"stats":{"Line":34}},{"line":384,"address":[3603315],"length":1,"stats":{"Line":16}},{"line":385,"address":[1845296],"length":1,"stats":{"Line":18}},{"line":386,"address":[1594558],"length":1,"stats":{"Line":16}},{"line":388,"address":[3605127],"length":1,"stats":{"Line":6}},{"line":389,"address":[2772363],"length":1,"stats":{"Line":6}},{"line":390,"address":[3605168,3605673],"length":1,"stats":{"Line":12}},{"line":391,"address":[2772904],"length":1,"stats":{"Line":6}},{"line":392,"address":[3605710],"length":1,"stats":{"Line":6}},{"line":393,"address":[2318729,2332013,2333033,2317709],"length":1,"stats":{"Line":12}},{"line":399,"address":[2209120,2218432,2210026,2208942],"length":1,"stats":{"Line":6}},{"line":400,"address":[2782471],"length":1,"stats":{"Line":0}},{"line":401,"address":[3615475],"length":1,"stats":{"Line":0}},{"line":404,"address":[2901591,2901691,2901393],"length":1,"stats":{"Line":12}},{"line":407,"address":[7305141,7328256,7328560,7319333],"length":1,"stats":{"Line":12}},{"line":408,"address":[2910739],"length":1,"stats":{"Line":6}},{"line":409,"address":[],"length":0,"stats":{"Line":6}},{"line":410,"address":[2782862,2782723,2782800],"length":1,"stats":{"Line":6}},{"line":411,"address":[2911011],"length":1,"stats":{"Line":0}},{"line":412,"address":[2218825],"length":1,"stats":{"Line":0}},{"line":414,"address":[2910770],"length":1,"stats":{"Line":6}},{"line":417,"address":[2901892],"length":1,"stats":{"Line":6}},{"line":418,"address":[2332684,2318380],"length":1,"stats":{"Line":6}},{"line":419,"address":[2318420,2332724],"length":1,"stats":{"Line":6}},{"line":420,"address":[1597404],"length":1,"stats":{"Line":6}},{"line":422,"address":[1597594],"length":1,"stats":{"Line":6}},{"line":425,"address":[2208409],"length":1,"stats":{"Line":15}},{"line":426,"address":[2208452,2210043],"length":1,"stats":{"Line":31}},{"line":427,"address":[1597778,1598817],"length":1,"stats":{"Line":17}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[2211067,2210504],"length":1,"stats":{"Line":15}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[7320939,7306747],"length":1,"stats":{"Line":15}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[4980496,4937648,4966192,4951920,4994657],"length":1,"stats":{"Line":15}},{"line":438,"address":[2317277,2331581],"length":1,"stats":{"Line":15}},{"line":439,"address":[2334214,2317320,2319910,2331624],"length":1,"stats":{"Line":29}},{"line":440,"address":[2335260,2334221,2319917,2320956],"length":1,"stats":{"Line":14}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[2320371,2320934,2335238,2334675],"length":1,"stats":{"Line":14}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[3608854],"length":1,"stats":{"Line":14}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[7322083,7307891],"length":1,"stats":{"Line":14}},{"line":452,"address":[],"length":0,"stats":{"Line":14}},{"line":453,"address":[],"length":0,"stats":{"Line":29}},{"line":454,"address":[],"length":0,"stats":{"Line":15}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[7323185,7308434,7322626,7308993],"length":1,"stats":{"Line":16}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[2777153],"length":1,"stats":{"Line":15}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[2321990,2336294],"length":1,"stats":{"Line":15}},{"line":465,"address":[2900853],"length":1,"stats":{"Line":8}},{"line":467,"address":[4935312,4992321,4954172,4963856,4949584,4978160,4982748,4968444,4939900,4996909],"length":1,"stats":{"Line":14}},{"line":468,"address":[7324282,7309059,7310090,7323251],"length":1,"stats":{"Line":7}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[3611116,3610553],"length":1,"stats":{"Line":7}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[2323004,2337308],"length":1,"stats":{"Line":7}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[7324233,7310041],"length":1,"stats":{"Line":7}},{"line":480,"address":[7318725,7304533],"length":1,"stats":{"Line":1}},{"line":483,"address":[7324311,7318748,7310119,7304556],"length":1,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":2}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[2323184,2337488],"length":1,"stats":{"Line":1}},{"line":487,"address":[7310187,7324379,7324497,7310305],"length":1,"stats":{"Line":1}},{"line":488,"address":[1853264],"length":1,"stats":{"Line":1}},{"line":489,"address":[],"length":0,"stats":{"Line":1}},{"line":490,"address":[7310441,7324633],"length":1,"stats":{"Line":1}},{"line":491,"address":[],"length":0,"stats":{"Line":1}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[1596540],"length":1,"stats":{"Line":1}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[1596563,1602733],"length":1,"stats":{"Line":2}},{"line":507,"address":[2779893],"length":1,"stats":{"Line":0}},{"line":508,"address":[7310868,7325060],"length":1,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[2907358,2907275],"length":1,"stats":{"Line":2}},{"line":515,"address":[7325165,7325274,7310973,7325374,7325801,7311082,7311182,7311609],"length":1,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[1602957],"length":1,"stats":{"Line":0}},{"line":518,"address":[3612182,3612064],"length":1,"stats":{"Line":0}},{"line":519,"address":[7311365,7325557],"length":1,"stats":{"Line":0}},{"line":520,"address":[2779511],"length":1,"stats":{"Line":0}},{"line":521,"address":[2779534],"length":1,"stats":{"Line":0}},{"line":522,"address":[4942174,4985022,4956446,4999145,4970718],"length":1,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[7325116,7311599,7325791,7310924],"length":1,"stats":{"Line":2}},{"line":534,"address":[7310947,7325139],"length":1,"stats":{"Line":1}},{"line":535,"address":[],"length":0,"stats":{"Line":1}},{"line":540,"address":[2206901],"length":1,"stats":{"Line":15}},{"line":541,"address":[7302796,7316988],"length":1,"stats":{"Line":0}},{"line":542,"address":[2899132],"length":1,"stats":{"Line":0}},{"line":546,"address":[1594843,1594901],"length":1,"stats":{"Line":31}},{"line":547,"address":[2208245],"length":1,"stats":{"Line":0}},{"line":550,"address":[3604105],"length":1,"stats":{"Line":16}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[2899736,2900327],"length":1,"stats":{"Line":0}},{"line":553,"address":[2316948,2331252],"length":1,"stats":{"Line":0}},{"line":554,"address":[1846641],"length":1,"stats":{"Line":0}},{"line":560,"address":[1595078,1595316],"length":1,"stats":{"Line":31}},{"line":561,"address":[1595515],"length":1,"stats":{"Line":18}},{"line":562,"address":[1846075],"length":1,"stats":{"Line":16}},{"line":563,"address":[2316419,2330723],"length":1,"stats":{"Line":16}},{"line":564,"address":[7317663,7303471],"length":1,"stats":{"Line":18}},{"line":565,"address":[1846211],"length":1,"stats":{"Line":16}},{"line":566,"address":[],"length":0,"stats":{"Line":0}}],"covered":181,"coverable":292},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","compiler","mod.rs"],"content":"//! Circuit compilation and lowering subsystem.\n\nmod expression_lowerer;\nmod optimizer;\n\npub use expression_lowerer::ExpressionLowerer;\nuse hashbrown::HashMap;\npub use optimizer::Optimizer;\n\nuse crate::{CircuitBuilderError, ExprId, WitnessId};\n\n// Utility functions\n\n/// Helper function to get WitnessId with descriptive error messages\nfn get_witness_id(\n    expr_to_widx: \u0026HashMap\u003cExprId, WitnessId\u003e,\n    expr_id: ExprId,\n    context: \u0026str,\n) -\u003e Result\u003cWitnessId, CircuitBuilderError\u003e {\n    expr_to_widx\n        .get(\u0026expr_id)\n        .copied()\n        .ok_or_else(|| CircuitBuilderError::MissingExprMapping {\n            expr_id,\n            context: context.into(),\n        })\n}\n","traces":[{"line":15,"address":[7020400],"length":1,"stats":{"Line":11}},{"line":21,"address":[10642952],"length":1,"stats":{"Line":9}},{"line":23,"address":[11045069,11045120,11045186],"length":1,"stats":{"Line":13}},{"line":24,"address":[4059137],"length":1,"stats":{"Line":1}},{"line":25,"address":[3415098],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","compiler","optimizer.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::op::Op;\n\n/// Responsible for performing optimization passes on primitive operations.\n#[derive(Debug, Default)]\npub struct Optimizer;\n\nimpl Optimizer {\n    /// Creates a new optimizer.\n    pub const fn new() -\u003e Self {\n        Self\n    }\n\n    /// Optimizes primitive operations.\n    ///\n    /// Future passes that can be added here:\n    /// - Dead code elimination\n    /// - Common subexpression elimination\n    /// - Instruction combining\n    /// - Constant folding\n    pub const fn optimize\u003cF\u003e(\u0026self, primitive_ops: Vec\u003cOp\u003cF\u003e\u003e) -\u003e Vec\u003cOp\u003cF\u003e\u003e {\n        // For now, return operations unchanged\n        // Future optimization passes will be added here\n        primitive_ops\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use super::*;\n\n    #[test]\n    fn test_optimizer_passthrough() {\n        use p3_baby_bear::BabyBear;\n        use p3_field::PrimeCharacteristicRing;\n\n        use crate::types::WitnessId;\n\n        let optimizer = Optimizer::new();\n\n        let ops = vec![\n            Op::Const {\n                out: WitnessId(0),\n                val: BabyBear::ZERO,\n            },\n            Op::Add {\n                a: WitnessId(0),\n                b: WitnessId(1),\n                out: WitnessId(2),\n            },\n        ];\n\n        let optimized = optimizer.optimize(ops.clone());\n        assert_eq!(optimized, ops);\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":15}},{"line":25,"address":[],"length":0,"stats":{"Line":17}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","config.rs"],"content":"use hashbrown::HashMap;\n\nuse crate::op::{NonPrimitiveOpConfig, NonPrimitiveOpType};\n\n/// Configuration for the circuit builder.\n#[derive(Debug)]\npub struct BuilderConfig\u003cF\u003e {\n    /// Enabled non-primitive operation types with their respective configuration.\n    enabled_ops: HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e,\n}\n\nimpl\u003cF\u003e Default for BuilderConfig\u003cF\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cF\u003e Clone for BuilderConfig\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            enabled_ops: self.enabled_ops.clone(),\n        }\n    }\n}\n\nimpl\u003cF\u003e BuilderConfig\u003cF\u003e {\n    /// Creates a new builder configuration.\n    pub fn new() -\u003e Self {\n        Self {\n            enabled_ops: HashMap::new(),\n        }\n    }\n\n    /// Enables a non-primitive operation type with its configuration.\n    pub fn enable_op(\u0026mut self, op: NonPrimitiveOpType, cfg: NonPrimitiveOpConfig\u003cF\u003e) {\n        self.enabled_ops.insert(op, cfg);\n    }\n\n    /// Checks whether an operation type is enabled.\n    pub fn is_op_enabled(\u0026self, op: \u0026NonPrimitiveOpType) -\u003e bool {\n        self.enabled_ops.contains_key(op)\n    }\n\n    /// Gets the configuration for an operation type, if enabled.\n    pub fn get_op_config(\u0026self, op: \u0026NonPrimitiveOpType) -\u003e Option\u003c\u0026NonPrimitiveOpConfig\u003cF\u003e\u003e {\n        self.enabled_ops.get(op)\n    }\n\n    /// Consumes the config and returns the enabled operations map.\n    pub fn into_enabled_ops(self) -\u003e HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e {\n        self.enabled_ops\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_builder_config_default() {\n        let config = BuilderConfig::\u003cF\u003e::default();\n        assert!(!config.is_op_enabled(\u0026NonPrimitiveOpType::Poseidon2Perm));\n    }\n\n    #[test]\n    fn test_builder_config_enable_op() {\n        let mut config = BuilderConfig::\u003cF\u003e::new();\n\n        config.enable_op(\n            NonPrimitiveOpType::Poseidon2Perm,\n            NonPrimitiveOpConfig::None,\n        );\n\n        assert!(config.is_op_enabled(\u0026NonPrimitiveOpType::Poseidon2Perm));\n    }\n}\n","traces":[{"line":13,"address":[7133712],"length":1,"stats":{"Line":1}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[7064048,7064240,7064112,7064304,7064176],"length":1,"stats":{"Line":21}},{"line":30,"address":[],"length":0,"stats":{"Line":20}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[7091596,7091660],"length":1,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[1537166],"length":1,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[3594176],"length":1,"stats":{"Line":18}},{"line":51,"address":[7091384,7091416],"length":1,"stats":{"Line":16}}],"covered":10,"coverable":14},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","errors.rs"],"content":"use alloc::string::String;\nuse alloc::vec::Vec;\n\nuse thiserror::Error;\n\nuse crate::op::NonPrimitiveOpType;\nuse crate::types::NonPrimitiveOpId;\nuse crate::{ExprId, WitnessId};\n\n/// Errors that can occur during circuit building/lowering.\n#[derive(Debug, Error)]\npub enum CircuitBuilderError {\n    /// Expression not found in the witness mapping during lowering.\n    #[error(\"Expression {expr_id:?} not found in witness mapping: {context}\")]\n    MissingExprMapping { expr_id: ExprId, context: String },\n\n    /// Non-primitive op received an unexpected number of input expressions.\n    #[error(\"{op} expects exactly {expected} witness expressions, got {got}\")]\n    NonPrimitiveOpArity {\n        op: \u0026'static str,\n        expected: String,\n        got: usize,\n    },\n\n    /// Non-primitive operation referenced by id was not found.\n    #[error(\"Non-primitive operation id {op_id:?} not found\")]\n    MissingNonPrimitiveOp { op_id: NonPrimitiveOpId },\n\n    /// Non-primitive output indices for an op are malformed (duplicates or gaps).\n    #[error(\"Non-primitive output indices malformed for op {op_id:?}: {details}\")]\n    MalformedNonPrimitiveOutputs {\n        op_id: NonPrimitiveOpId,\n        details: String,\n    },\n\n    /// Non-primitive operation exists in the builder but was never anchored in the expression DAG,\n    /// so the lowerer cannot place it in a well-defined execution order.\n    #[error(\"Non-primitive operation {op_id:?} is not anchored in the expression DAG\")]\n    UnanchoredNonPrimitiveOp { op_id: NonPrimitiveOpId },\n\n    /// Non-primitive operation rejected by the active policy/profile.\n    #[error(\"Operation {op:?} is not allowed by the current profile\")]\n    OpNotAllowed { op: NonPrimitiveOpType },\n\n    /// Non-primitive operation is recognized but not implemented in lowering.\n    #[error(\"Operation {op:?} is not implemented in lowering\")]\n    UnsupportedNonPrimitiveOp { op: NonPrimitiveOpType },\n\n    /// Mismatched non-primitive operation configuration\n    #[error(\"Invalid configuration for operation {op:?}\")]\n    InvalidNonPrimitiveOpConfiguration { op: NonPrimitiveOpType },\n\n    /// Merkle-path Poseidon2 rows require a direction bit.\n    #[error(\"Poseidon2Perm merkle_path=true requires mmcs_bit\")]\n    Poseidon2MerkleMissingMmcsBit,\n\n    /// Non-merkle Poseidon2 rows should not have mmcs_bit set.\n    #[error(\"Poseidon2Perm merkle_path=false must not have mmcs_bit (it has no effect)\")]\n    Poseidon2NonMerkleWithMmcsBit,\n\n    /// A sequence of expressions of type Witness is missing its filler.\n    #[error(\"Missing hint filler for expression {sequence:?}\")]\n    MissingWitnessFiller { sequence: Vec\u003cWitnessId\u003e },\n\n    /// A sequence of witness hints has no end.\n    #[error(\"Witness hint without last hint {sequence:?}.\")]\n    MalformedWitnessHintsSequence { sequence: Vec\u003cWitnessId\u003e },\n\n    /// Witness filler without any hints sequence.\n    #[error(\"Witness filler is missing a witness hints sequence\")]\n    UnmatchedWitnessFiller {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","expression_builder.rs"],"content":"//! Expression graph construction and constant pooling.\n//!\n//! The [`ExpressionBuilder`] is the layer for building arithmetic circuits.\n//!\n//! It manages a directed acyclic graph (DAG) of expressions where\n//! - nodes represent field operations,\n//! - edges represent dependencies between expressions.\n\nuse alloc::boxed::Box;\n#[cfg(debug_assertions)]\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::hash::Hash;\n\nuse hashbrown::HashMap;\nuse p3_field::PrimeCharacteristicRing;\n\nuse crate::expr::{Expr, ExpressionGraph};\nuse crate::op::WitnessHintsFiller;\nuse crate::types::{ExprId, NonPrimitiveOpId};\n#[cfg(debug_assertions)]\nuse crate::{AllocationEntry, AllocationType};\n\n/// Manages expression graph construction, constant pooling, and debug instrumentation.\n///\n/// The expression builder provides a high-level interface for constructing arithmetic\n/// circuits as directed acyclic graphs (DAGs).\n///\n/// Each node in the graph represents a field operation or a special value\n/// (constant, public input, witness hint).\n#[derive(Debug)]\npub struct ExpressionBuilder\u003cF\u003e {\n    /// The underlying expression graph storage.\n    ///\n    /// This graph holds all expression nodes in a flat vector, indexed by [`ExprId`].\n    ///\n    /// The graph is append-only: once an expression is added, it never moves or gets\n    /// removed, ensuring stable handles.\n    graph: ExpressionGraph\u003cF\u003e,\n\n    /// Constant deduplication pool.\n    ///\n    /// Maps field values to their unique [`ExprId`] in the graph.\n    ///\n    /// When a constant is requested via [`add_const`](Self::add_const), this pool is checked first.\n    ///\n    /// If the value exists, the cached ID is returned immediately, avoiding duplicate nodes.\n    const_pool: HashMap\u003cF, ExprId\u003e,\n\n    /// Pending equality constraints.\n    ///\n    /// Each entry `(a, b)` represents a constraint that expressions `a` and `b` must\n    /// evaluate to the same value. These constraints are resolved during the lowering\n    /// phase using Union-Find (DSU) to merge witness slots.\n    ///\n    /// Self-connections `(a, a)` are filtered out to avoid unnecessary work.\n    pending_connects: Vec\u003c(ExprId, ExprId)\u003e,\n\n    /// Witness hint fillers for computing unconstrained values.\n    ///\n    /// Each filler corresponds to a sequence of witness hints added via\n    /// [`add_witness_hints`](Self::add_witness_hints). The order in this vector\n    /// matches the order of hint sequences in the graph.\n    ///\n    /// During circuit execution, fillers compute concrete witness values from\n    /// their input expressions.\n    hints_fillers: Vec\u003cBox\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e\u003e,\n\n    /// Complete allocation history for debugging.\n    ///\n    /// Tracks every expression added to the graph, including metadata:\n    /// - Allocation type (Const, Add, Mul, etc.)\n    /// - Human-readable label\n    /// - Expression dependencies\n    /// - Scope context\n    ///\n    /// **Only present in debug builds.**\n    #[cfg(debug_assertions)]\n    allocation_log: Vec\u003cAllocationEntry\u003e,\n\n    /// Hierarchical scope stack for organizing allocations.\n    ///\n    /// Users can push/pop named scopes to organize the allocation log into logical\n    /// groups (e.g., \"fibonacci_step\", \"mmcs_verify\", etc.).\n    ///\n    /// The current scope is attached to each allocation.\n    ///\n    /// **Only present in debug builds.**\n    #[cfg(debug_assertions)]\n    scope_stack: Vec\u003c\u0026'static str\u003e,\n}\n\nimpl\u003cF\u003e ExpressionBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + Hash,\n{\n    /// Creates a new expression builder with zero constant pre-allocated.\n    ///\n    /// The zero constant is always the first node in the graph, accessible via\n    /// [`ExprId::ZERO`].\n    ///\n    /// # Postconditions\n    ///\n    /// After construction:\n    /// - The graph contains exactly one node: `Expr::Const(F::ZERO)`\n    /// - The constant pool contains one entry: `F::ZERO → ExprId::ZERO`\n    /// - All other collections (pending_connects, hints_fillers) are empty\n    pub fn new() -\u003e Self {\n        // Initialize an empty expression graph.\n        let mut graph = ExpressionGraph::new();\n\n        // Pre-allocate the zero constant as the first node.\n        //\n        // This ensures ExprId::ZERO (which is ExprId(0)) always refers to zero.\n        let zero_val = F::ZERO;\n        let zero_id = graph.add_expr(Expr::Const(zero_val.clone()));\n\n        // Pre-populate the constant pool with zero.\n        let const_pool = [(zero_val, zero_id)].into();\n\n        Self {\n            graph,\n            const_pool,\n            pending_connects: Vec::new(),\n            hints_fillers: Vec::new(),\n            #[cfg(debug_assertions)]\n            allocation_log: Vec::new(),\n            #[cfg(debug_assertions)]\n            scope_stack: Vec::new(),\n        }\n    }\n\n    /// Adds a constant to the expression graph with automatic deduplication.\n    ///\n    /// If this constant value was previously added, returns the existing [`ExprId`]\n    /// handle instead of creating a duplicate node. This ensures the graph contains\n    /// at most one node per unique constant value.\n    ///\n    /// # Arguments\n    ///\n    /// - `val`: The constant field value to add\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the constant. If `val` was seen before, returns the\n    /// cached ID. Otherwise, creates a new node and returns its ID.\n    ///\n    /// # Debug Behavior\n    ///\n    /// In debug builds, logs the allocation to the allocation log with:\n    /// - Type: `AllocationType::Const`\n    /// - Label: the provided label\n    /// - Dependencies: empty (constants have no dependencies)\n    /// - Scope: the current scope from the scope stack\n    ///\n    /// **Important**: Only new allocations are logged. Returning a cached constant\n    /// does not create a new log entry.\n    pub fn add_const(\u0026mut self, val: F, label: \u0026'static str) -\u003e ExprId {\n        // Check if this constant already exists in the pool.\n        if let Some(\u0026cached_id) = self.const_pool.get(\u0026val) {\n            // Found a cached entry. Return it immediately without allocating.\n            return cached_id;\n        }\n\n        // This is a new constant. Add it to the expression graph.\n        let expr_id = self.graph.add_expr(Expr::Const(val.clone()));\n\n        // Insert into the constant pool for future lookups.\n        self.const_pool.insert(val, expr_id);\n\n        // Log the allocation in debug builds only.\n        //\n        // In release builds, this entire call compiles to nothing.\n        #[cfg(debug_assertions)]\n        self.log_alloc(expr_id, label, || (AllocationType::Const, vec![]));\n        #[cfg(not(debug_assertions))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Adds a public input expression to the graph.\n    ///\n    /// Public inputs are values known to both the prover and verifier. They are\n    /// identified by their position in the public input vector.\n    ///\n    /// **Important**: Unlike constants, public inputs are **not** deduplicated. Each\n    /// call creates a new expression node, even if the position is the same. This is\n    /// intentional: multiple references to the same public input are treated as\n    /// independent expressions that happen to read from the same source.\n    ///\n    /// # Arguments\n    ///\n    /// - `pos`: Zero-based index into the public input vector\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// A new [`ExprId`] handle to the public input expression.\n    pub fn add_public(\u0026mut self, pos: usize, label: \u0026'static str) -\u003e ExprId {\n        // Create a new Public expression node in the graph.\n        //\n        // The `pos` field indicates which public input slot this expression reads from.\n        let expr_id = self.graph.add_expr(Expr::Public(pos));\n\n        // Log the allocation in debug builds.\n        //\n        // Public inputs have no dependencies (they are leaf nodes in the expression DAG).\n        #[cfg(debug_assertions)]\n        self.log_alloc(expr_id, label, || (AllocationType::Public, vec![]));\n        #[cfg(not(debug_assertions))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Adds a single witness hint to a sequence of hints.\n    ///\n    /// Witness hints represent unconstrained prover values. They are organized in\n    /// sequences where each hint knows whether it is the last in its sequence via\n    /// the `is_last_hint` flag.\n    ///\n    /// # Arguments\n    ///\n    /// - `is_last_hint`: Whether this hint concludes its sequence\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the witness hint expression.\n    ///\n    /// # Sequencing Invariant\n    ///\n    /// Hints within a sequence must be added consecutively, and exactly one hint\n    /// in each sequence must have `is_last_hint: true`. This allows the execution\n    /// engine to match hints with their corresponding fillers.\n    pub fn add_witness_hint_in_sequence(\n        \u0026mut self,\n        is_last_hint: bool,\n        label: \u0026'static str,\n    ) -\u003e ExprId {\n        // Create a new Witness expression node.\n        //\n        // The `is_last_hint` flag is stored in the node so the execution engine\n        // can identify sequence boundaries without external metadata.\n        let expr_id = self.graph.add_expr(Expr::Hint { is_last_hint });\n\n        // Log the allocation in debug builds.\n        //\n        // Witness hints are leaf nodes with no dependencies.\n        #[cfg(debug_assertions)]\n        self.log_alloc(expr_id, label, || (AllocationType::WitnessHint, vec![]));\n        #[cfg(not(debug_assertions))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Adds a sequence of witness hints with an associated filler.\n    ///\n    /// This is the primary method for adding unconstrained witness values to the circuit.\n    /// The filler object computes concrete witness values during circuit execution based\n    /// on its input expressions.\n    ///\n    /// # Arguments\n    ///\n    /// - `filler`: A witness hint filler implementing [`WitnessHintsFiller\u003cF\u003e`]\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// A vector of [`ExprId`] handles, one for each output of the filler.\n    ///\n    /// # Filler Registration\n    ///\n    /// The filler is stored in the `hints_fillers` vector in the order it was added.\n    /// During circuit execution, fillers are invoked in this order to compute witness\n    /// values.\n    #[must_use]\n    pub fn add_witness_hints\u003cW: 'static + WitnessHintsFiller\u003cF\u003e\u003e(\n        \u0026mut self,\n        filler: W,\n        label: \u0026'static str,\n    ) -\u003e Vec\u003cExprId\u003e {\n        // Query the number of outputs this filler will produce.\n        let n_outputs = filler.n_outputs();\n\n        // Pre-allocate the vector with exact capacity.\n        //\n        // This is possible since we know the exact size upfront.\n        let mut expr_ids = Vec::with_capacity(n_outputs);\n\n        // Add each hint in sequence.\n        //\n        // The last hint (i == n_outputs - 1) is marked with `is_last_hint: true`.\n        for i in 0..n_outputs {\n            expr_ids.push(self.add_witness_hint_in_sequence(i == n_outputs - 1, label));\n        }\n\n        // Register the filler for later use during execution.\n        //\n        // The order of fillers in this vector must match the order of hint sequences\n        // in the graph.\n        self.hints_fillers.push(Box::new(filler));\n\n        expr_ids\n    }\n\n    /// Adds an addition expression to the graph.\n    ///\n    /// Represents the field addition operation: `result = lhs + rhs`.\n    ///\n    /// # Arguments\n    ///\n    /// - `lhs`: Left operand expression\n    /// - `rhs`: Right operand expression\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the addition expression.\n    pub fn add_add(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.add_bin_op(\n            Expr::Add { lhs, rhs },\n            label,\n            #[cfg(debug_assertions)]\n            AllocationType::Add,\n            lhs,\n            rhs,\n        )\n    }\n\n    /// Adds a subtraction expression to the graph.\n    ///\n    /// Represents the field subtraction operation: `result = lhs - rhs`.\n    ///\n    /// **Note**: During lowering, subtraction is encoded as addition:\n    /// `lhs - rhs = result` becomes `result + rhs = lhs` in the Add table.\n    ///\n    /// # Arguments\n    ///\n    /// - `lhs`: Left operand (minuend)\n    /// - `rhs`: Right operand (subtrahend)\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the subtraction expression.\n    pub fn add_sub(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.add_bin_op(\n            Expr::Sub { lhs, rhs },\n            label,\n            #[cfg(debug_assertions)]\n            AllocationType::Sub,\n            lhs,\n            rhs,\n        )\n    }\n\n    /// Adds a multiplication expression to the graph.\n    ///\n    /// Represents the field multiplication operation: `result = lhs * rhs`.\n    ///\n    /// # Arguments\n    ///\n    /// - `lhs`: Left operand\n    /// - `rhs`: Right operand\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the multiplication expression.\n    pub fn add_mul(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.add_bin_op(\n            Expr::Mul { lhs, rhs },\n            label,\n            #[cfg(debug_assertions)]\n            AllocationType::Mul,\n            lhs,\n            rhs,\n        )\n    }\n\n    /// Adds a division expression to the graph.\n    ///\n    /// Represents the field division operation: `result = lhs / rhs`.\n    ///\n    /// **Note**: During lowering, division is encoded as multiplication:\n    /// `lhs / rhs = result` becomes `result * rhs = lhs` in the Mul table.\n    ///\n    /// # Arguments\n    ///\n    /// - `lhs`: Left operand (dividend)\n    /// - `rhs`: Right operand (divisor, must be non-zero)\n    /// - `label`: Human-readable label for debug logging\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the division expression.\n    pub fn add_div(\u0026mut self, lhs: ExprId, rhs: ExprId, label: \u0026'static str) -\u003e ExprId {\n        self.add_bin_op(\n            Expr::Div { lhs, rhs },\n            label,\n            #[cfg(debug_assertions)]\n            AllocationType::Div,\n            lhs,\n            rhs,\n        )\n    }\n\n    /// Adds a non-primitive output expression to the graph.\n    ///\n    /// This expression represents a value produced by a non-primitive operation.\n    /// The `call` parameter is the `ExprId` of the `NonPrimitiveCall` node, making\n    /// the dependency explicit in the DAG structure.\n    pub fn add_non_primitive_output(\n        \u0026mut self,\n        call: ExprId,\n        output_idx: u32,\n        label: \u0026'static str,\n    ) -\u003e ExprId {\n        let expr_id = self\n            .graph\n            .add_expr(Expr::NonPrimitiveOutput { call, output_idx });\n\n        #[cfg(debug_assertions)]\n        self.log_alloc(expr_id, label, || {\n            (AllocationType::NonPrimitiveOutput, vec![vec![call]])\n        });\n        #[cfg(not(debug_assertions))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Adds a non-primitive call anchor expression to the graph.\n    ///\n    /// This expression has no witness value, but provides an explicit point in the expression DAG\n    /// for the lowerer to emit the non-primitive op in the correct execution order.\n    ///\n    /// The `inputs` parameter contains all input expressions (flattened), making dependencies\n    /// explicit in the DAG structure. For stateful ops with chaining (e.g., `in_ctl=false`),\n    /// `inputs` may be empty since chained values are not in the witness table.\n    pub fn add_non_primitive_call(\n        \u0026mut self,\n        op_id: NonPrimitiveOpId,\n        op_type: crate::op::NonPrimitiveOpType,\n        inputs: Vec\u003cExprId\u003e,\n        label: \u0026'static str,\n    ) -\u003e ExprId {\n        #[cfg(debug_assertions)]\n        let dependencies: Vec\u003cVec\u003cExprId\u003e\u003e = inputs.iter().map(|\u0026id| vec![id]).collect();\n\n        let expr_id = self\n            .graph\n            .add_expr(Expr::NonPrimitiveCall { op_id, inputs });\n\n        #[cfg(debug_assertions)]\n        self.log_alloc(expr_id, label, || {\n            (AllocationType::NonPrimitiveOp(op_type), dependencies)\n        });\n        #[cfg(not(debug_assertions))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Internal helper for adding binary operations.\n    ///\n    /// # Arguments\n    ///\n    /// - `expr`: The binary expression variant to add (Add/Sub/Mul/Div)\n    /// - `label`: Human-readable label for debug logging\n    /// - `alloc_type`: Allocation type for debug logging (only exists in debug builds)\n    /// - `lhs`: Left operand dependency\n    /// - `rhs`: Right operand dependency\n    ///\n    /// # Returns\n    ///\n    /// An [`ExprId`] handle to the newly created expression.\n    #[inline(always)]\n    #[allow(unused_variables)]\n    fn add_bin_op(\n        \u0026mut self,\n        expr: Expr\u003cF\u003e,\n        label: \u0026'static str,\n        #[cfg(debug_assertions)] alloc_type: AllocationType,\n        lhs: ExprId,\n        rhs: ExprId,\n    ) -\u003e ExprId {\n        // Add the expression to the graph.\n        let expr_id = self.graph.add_expr(expr);\n\n        // Log the allocation with dependencies.\n        //\n        // Binary operations have two dependencies: one for lhs, one for rhs.\n        #[cfg(debug_assertions)]\n        self.log_alloc(expr_id, label, || (alloc_type, vec![vec![lhs], vec![rhs]]));\n        #[cfg(not(debug_assertions))]\n        self.log_alloc(expr_id, label, || ());\n\n        expr_id\n    }\n\n    /// Enforces equality between two expressions.\n    ///\n    /// Adds a pending constraint that expressions `a` and `b` must evaluate to\n    /// the same value. During the lowering phase, these constraints are resolved\n    /// using Union-Find (DSU) to merge the witness slots for `a` and `b`.\n    ///\n    /// # Arguments\n    ///\n    /// - `a`: First expression\n    /// - `b`: Second expression\n    ///\n    /// # Self-Connection Optimization\n    ///\n    /// If `a == b` (same expression), this is a no-op. No constraint is added\n    /// because an expression is trivially equal to itself.\n    ///\n    /// # Constraint Resolution\n    ///\n    /// Constraints are not resolved immediately. They are stored in the\n    /// `pending_connects` vector and processed during circuit compilation.\n    pub fn connect(\u0026mut self, a: ExprId, b: ExprId) {\n        // Skip self-connections as they are trivially satisfied.\n        if a != b {\n            self.pending_connects.push((a, b));\n        }\n    }\n\n    /// Returns an immutable reference to the underlying expression graph.\n    ///\n    /// The graph provides access to all expression nodes and their relationships.\n    ///\n    /// # Returns\n    ///\n    /// A reference to the [`ExpressionGraph`] containing all expressions.\n    #[inline]\n    pub const fn graph(\u0026self) -\u003e \u0026ExpressionGraph\u003cF\u003e {\n        \u0026self.graph\n    }\n\n    /// Returns a slice of pending equality constraints.\n    ///\n    /// Each constraint `(a, b)` represents an assertion that expressions `a` and `b`\n    /// must evaluate to the same value.\n    ///\n    /// # Returns\n    ///\n    /// A slice of `(ExprId, ExprId)` pairs representing pending connections.\n    #[inline]\n    pub fn pending_connects(\u0026self) -\u003e \u0026[(ExprId, ExprId)] {\n        \u0026self.pending_connects\n    }\n\n    /// Returns a slice of registered witness hint fillers.\n    ///\n    /// Fillers are stored in the order they were added via [`add_witness_hints`](Self::add_witness_hints).\n    ///\n    /// # Returns\n    ///\n    /// A slice of boxed [`WitnessHintsFiller`] trait objects.\n    #[inline]\n    pub fn hints_fillers(\u0026self) -\u003e \u0026[Box\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e] {\n        \u0026self.hints_fillers\n    }\n\n    /// Centralized logging helper for debug builds.\n    ///\n    /// # Arguments\n    ///\n    /// - `id`: The expression ID being logged\n    /// - `label`: Human-readable label\n    /// - `info_fn`: Closure that produces allocation metadata **only when needed**\n    #[cfg(debug_assertions)]\n    #[inline(always)]\n    fn log_alloc\u003cInfo\u003e(\u0026mut self, id: ExprId, label: \u0026'static str, info_fn: Info)\n    where\n        Info: FnOnce() -\u003e (AllocationType, Vec\u003cVec\u003cExprId\u003e\u003e),\n    {\n        // Execute the closure to get allocation metadata.\n        let (alloc_type, dependencies) = info_fn();\n\n        // Capture the current scope from the stack.\n        let scope = self.scope_stack.last().copied();\n\n        // Add an entry to the allocation log.\n        self.allocation_log.push(AllocationEntry {\n            expr_id: id,\n            alloc_type,\n            label,\n            dependencies,\n            scope,\n        });\n    }\n\n    /// No-op logging helper for release builds.\n    #[cfg(not(debug_assertions))]\n    #[inline(always)]\n    #[allow(clippy::needless_pass_by_ref_mut)]\n    fn log_alloc\u003cInfo\u003e(\u0026mut self, _id: ExprId, _label: \u0026'static str, _info_fn: Info)\n    where\n        Info: FnOnce(),\n    {\n        // Intentionally empty - compiles to nothing in release builds.\n    }\n\n    /// Logs a non-primitive operation allocation (debug builds only).\n    ///\n    /// Non-primitive operations (MMCS, FRI, Poseidon2, etc.) are not part of the\n    /// standard expression types but need to be tracked in the allocation log.\n    ///\n    /// # Arguments\n    ///\n    /// - `op_id`: The non-primitive operation ID\n    /// - `op_type`: The type of operation (e.g., `NonPrimitiveOpType::MmcsVerify`)\n    /// - `input_deps`: Input expression dependencies for this operation\n    /// - `output_deps`: Output expression dependencies for this operation\n    /// - `label`: Human-readable label\n    #[cfg(debug_assertions)]\n    pub fn log_non_primitive_op(\n        \u0026mut self,\n        op_id: crate::types::NonPrimitiveOpId,\n        op_type: crate::op::NonPrimitiveOpType,\n        input_deps: Vec\u003cVec\u003cExprId\u003e\u003e,\n        output_deps: Vec\u003cVec\u003cExprId\u003e\u003e,\n        label: \u0026'static str,\n    ) {\n        // Capture the current scope.\n        let scope = self.scope_stack.last().copied();\n\n        // Combine inputs and outputs for dependency tracking.\n        // Use a separator to distinguish inputs from outputs in the log.\n        let mut dependencies = input_deps;\n        dependencies.extend(output_deps);\n\n        // Add to allocation log.\n        //\n        // Non-primitive operations are stored with a special allocation type\n        // that includes the operation variant.\n        self.allocation_log.push(AllocationEntry {\n            expr_id: ExprId(op_id.0),\n            alloc_type: AllocationType::NonPrimitiveOp(op_type),\n            label,\n            dependencies,\n            scope,\n        });\n    }\n\n    /// Pushes a new scope onto the scope stack (debug builds only).\n    ///\n    /// Scopes provide hierarchical organization for the allocation log. Subsequent\n    /// allocations will be tagged with this scope until it is popped.\n    ///\n    /// # Arguments\n    ///\n    /// - `scope`: Human-readable scope name\n    #[allow(unused_variables)]\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn push_scope(\u0026mut self, scope: \u0026'static str) {\n        #[cfg(debug_assertions)]\n        self.scope_stack.push(scope);\n    }\n\n    /// Pops the current scope from the scope stack (debug builds only).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the scope stack is empty (mismatched push/pop).\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn pop_scope(\u0026mut self) {\n        #[cfg(debug_assertions)]\n        self.scope_stack.pop();\n    }\n\n    /// Returns the current scope (debug builds only).\n    ///\n    /// Returns the name of the most recently pushed scope, or `None` if no scope is active.\n    ///\n    /// # Returns\n    ///\n    /// - `Some(\u0026'static str)` - The name of the current scope\n    /// - `None` - No active scope\n    #[cfg(debug_assertions)]\n    pub fn current_scope(\u0026self) -\u003e Option\u003c\u0026'static str\u003e {\n        self.scope_stack.last().copied()\n    }\n\n    /// Returns a reference to the allocation log (debug builds only).\n    ///\n    /// Provides read-only access to all allocation entries recorded during circuit\n    /// construction. Useful for testing and verifying allocation behavior.\n    ///\n    /// # Returns\n    ///\n    /// A slice of [`AllocationEntry`] containing all recorded allocations.\n    #[cfg(debug_assertions)]\n    pub fn allocation_log(\u0026self) -\u003e \u0026[AllocationEntry] {\n        \u0026self.allocation_log\n    }\n\n    /// Dumps the allocation log to stdout (debug builds only).\n    ///\n    /// Prints a formatted view of all allocations, including their types, labels,\n    /// dependencies, and scopes. Useful for debugging circuit construction.\n    ///\n    /// # Output\n    ///\n    /// In debug builds, outputs a detailed allocation report. In release builds,\n    /// this method does nothing.\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn dump_allocation_log(\u0026self) {\n        #[cfg(debug_assertions)]\n        crate::alloc_entry::dump_allocation_log(\u0026self.allocation_log);\n    }\n\n    /// Lists all unique scopes in the allocation log.\n    ///\n    /// Returns a vector of scope names that appear in the allocation log,\n    /// with duplicates removed.\n    ///\n    /// # Returns\n    ///\n    /// - **Debug builds**: Vector of unique scope names\n    /// - **Release builds**: Empty vector (no scopes tracked)\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn list_scopes(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        #[cfg(debug_assertions)]\n        {\n            crate::alloc_entry::list_scopes(\u0026self.allocation_log)\n        }\n        #[cfg(not(debug_assertions))]\n        {\n            Vec::new()\n        }\n    }\n}\n\nimpl\u003cF\u003e Default for ExpressionBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + Hash,\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::Field;\n\n    use super::*;\n    use crate::CircuitError;\n\n    #[test]\n    fn test_new_builder_has_zero_constant() {\n        // New builder should pre-allocate zero constant\n        let builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        // Zero should be in the graph at ExprId::ZERO\n        assert_eq!(builder.graph().nodes().len(), 1);\n        match \u0026builder.graph().nodes()[0] {\n            Expr::Const(val) =\u003e assert_eq!(*val, BabyBear::ZERO),\n            _ =\u003e panic!(\"Expected Const(0) at ExprId::ZERO\"),\n        }\n\n        // Const pool should contain zero\n        let mut expected_const_pool = HashMap::new();\n        expected_const_pool.insert(BabyBear::ZERO, ExprId::ZERO);\n        assert_eq!(builder.const_pool, expected_const_pool);\n\n        // No pending connections\n        assert!(builder.pending_connects.is_empty());\n    }\n\n    #[test]\n    fn test_add_const_single() {\n        // Adding a single constant should work\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let c1 = builder.add_const(BabyBear::ONE, \"test_const\");\n\n        // Should have 2 nodes: zero + one\n        assert_eq!(builder.graph().nodes().len(), 2);\n        assert_eq!(c1, ExprId(1));\n\n        // Verify the constant was added to graph\n        match \u0026builder.graph().nodes()[1] {\n            Expr::Const(val) =\u003e assert_eq!(*val, BabyBear::ONE),\n            _ =\u003e panic!(\"Expected Const(1)\"),\n        }\n\n        // Const pool should have both zero and one\n        assert_eq!(builder.const_pool.len(), 2);\n    }\n\n    #[test]\n    fn test_add_const_deduplication() {\n        // Adding the same constant twice should return same ExprId\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let c1 = builder.add_const(BabyBear::from_u64(42), \"first\");\n        let c2 = builder.add_const(BabyBear::from_u64(42), \"second\");\n\n        // Should return same ExprId\n        assert_eq!(c1, c2);\n\n        // Should only have 2 nodes (zero + 42), not 3\n        assert_eq!(builder.graph().nodes().len(), 2);\n\n        // Const pool should only have 2 entries\n        assert_eq!(builder.const_pool.len(), 2);\n    }\n\n    #[test]\n    fn test_add_const_multiple_different() {\n        // Adding different constants should create distinct ExprIds\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let c1 = builder.add_const(BabyBear::from_u64(1), \"one\");\n        let c2 = builder.add_const(BabyBear::from_u64(2), \"two\");\n        let c3 = builder.add_const(BabyBear::from_u64(3), \"three\");\n\n        // All should be different\n        assert_ne!(c1, c2);\n        assert_ne!(c2, c3);\n        assert_ne!(c1, c3);\n\n        // Should have 4 nodes: zero + 1 + 2 + 3\n        assert_eq!(builder.graph().nodes().len(), 4);\n        assert_eq!(builder.const_pool.len(), 4);\n    }\n\n    #[test]\n    fn test_add_const_zero_deduplicates_with_prealloc() {\n        // Adding zero constant should return pre-allocated ExprId::ZERO\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let zero = builder.add_const(BabyBear::ZERO, \"explicit_zero\");\n\n        // Should return ExprId::ZERO (the pre-allocated one)\n        assert_eq!(zero, ExprId::ZERO);\n\n        // Should still have only 1 node\n        assert_eq!(builder.graph().nodes().len(), 1);\n        assert_eq!(builder.const_pool.len(), 1);\n    }\n\n    #[test]\n    fn test_add_public_single() {\n        // Adding a single public input\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let p0 = builder.add_public(0, \"public_0\");\n\n        // Should have 2 nodes: zero + public\n        assert_eq!(builder.graph().nodes().len(), 2);\n        assert_eq!(p0, ExprId(1));\n\n        // Verify it's a Public node\n        match \u0026builder.graph().nodes()[1] {\n            Expr::Public(pos) =\u003e assert_eq!(*pos, 0),\n            _ =\u003e panic!(\"Expected Public(0)\"),\n        }\n    }\n\n    #[test]\n    fn test_add_public_multiple() {\n        // Adding multiple public inputs with different positions\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let p0 = builder.add_public(0, \"p0\");\n        let p1 = builder.add_public(1, \"p1\");\n        let p2 = builder.add_public(2, \"p2\");\n\n        // All should be different\n        assert_ne!(p0, p1);\n        assert_ne!(p1, p2);\n\n        // Should have 4 nodes: zero + 3 publics\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        // Verify positions\n        match \u0026builder.graph().nodes()[1] {\n            Expr::Public(pos) =\u003e assert_eq!(*pos, 0),\n            _ =\u003e panic!(\"Expected Public(0)\"),\n        }\n        match \u0026builder.graph().nodes()[2] {\n            Expr::Public(pos) =\u003e assert_eq!(*pos, 1),\n            _ =\u003e panic!(\"Expected Public(1)\"),\n        }\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Public(pos) =\u003e assert_eq!(*pos, 2),\n            _ =\u003e panic!(\"Expected Public(2)\"),\n        }\n    }\n\n    #[test]\n    fn test_add_public_same_position_creates_different_nodes() {\n        // Adding public inputs with same position creates different nodes\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let p0_a = builder.add_public(0, \"first\");\n        let p0_b = builder.add_public(0, \"second\");\n\n        // Should be different ExprIds (no deduplication for Public)\n        assert_ne!(p0_a, p0_b);\n\n        // Should have 3 nodes\n        assert_eq!(builder.graph().nodes().len(), 3);\n    }\n\n    #[test]\n    fn test_add_operation() {\n        // Test Add operation\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::from_u64(2), \"a\");\n        let b = builder.add_const(BabyBear::from_u64(3), \"b\");\n        let _sum = builder.add_add(a, b, \"sum\");\n\n        // Should have 4 nodes: zero + 2 + 3 + add\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        // Verify Add node\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Add { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, a);\n                assert_eq!(*rhs, b);\n            }\n            _ =\u003e panic!(\"Expected Add operation\"),\n        }\n    }\n\n    #[test]\n    fn test_sub_operation() {\n        // Test Sub operation\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::from_u64(5), \"a\");\n        let b = builder.add_const(BabyBear::from_u64(3), \"b\");\n        let _diff = builder.add_sub(a, b, \"diff\");\n\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Sub { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, a);\n                assert_eq!(*rhs, b);\n            }\n            _ =\u003e panic!(\"Expected Sub operation\"),\n        }\n    }\n\n    #[test]\n    fn test_mul_operation() {\n        // Test Mul operation\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::from_u64(7), \"a\");\n        let b = builder.add_const(BabyBear::from_u64(6), \"b\");\n        let _prod = builder.add_mul(a, b, \"prod\");\n\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Mul { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, a);\n                assert_eq!(*rhs, b);\n            }\n            _ =\u003e panic!(\"Expected Mul operation\"),\n        }\n    }\n\n    #[test]\n    fn test_div_operation() {\n        // Test Div operation\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::from_u64(10), \"a\");\n        let b = builder.add_const(BabyBear::from_u64(2), \"b\");\n        let _quot = builder.add_div(a, b, \"quot\");\n\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        match \u0026builder.graph().nodes()[3] {\n            Expr::Div { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, a);\n                assert_eq!(*rhs, b);\n            }\n            _ =\u003e panic!(\"Expected Div operation\"),\n        }\n    }\n\n    #[derive(Debug, Clone)]\n    struct IdentityHint {\n        inputs: Vec\u003cExprId\u003e,\n        n_outputs: usize,\n    }\n\n    impl IdentityHint {\n        pub fn new(inputs: Vec\u003cExprId\u003e) -\u003e Self {\n            Self {\n                n_outputs: inputs.len(),\n                inputs,\n            }\n        }\n    }\n\n    impl\u003cF: Field\u003e WitnessHintsFiller\u003cF\u003e for IdentityHint {\n        fn inputs(\u0026self) -\u003e \u0026[ExprId] {\n            \u0026self.inputs\n        }\n\n        fn n_outputs(\u0026self) -\u003e usize {\n            self.n_outputs\n        }\n\n        fn compute_outputs(\u0026self, inputs_val: Vec\u003cF\u003e) -\u003e Result\u003cVec\u003cF\u003e, CircuitError\u003e {\n            Ok(inputs_val)\n        }\n    }\n\n    #[test]\n    fn test_build_with_witness_hint() {\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n        let a = builder.add_const(BabyBear::ZERO, \"a\");\n        let b = builder.add_const(BabyBear::ONE, \"b\");\n        let id_hint = IdentityHint::new(vec![a, b]);\n        let c = builder.add_witness_hints(id_hint, \"c\");\n        assert_eq!(c.len(), 2);\n\n        assert_eq!(builder.graph().nodes().len(), 4);\n\n        match (\u0026builder.graph().nodes()[2], \u0026builder.graph().nodes()[3]) {\n            (\n                Expr::Hint {\n                    is_last_hint: false,\n                },\n                Expr::Hint { is_last_hint: true },\n            ) =\u003e (),\n            _ =\u003e panic!(\"Expected Witness operation\"),\n        }\n    }\n\n    #[test]\n    fn test_nested_operations() {\n        // Test nested operations: (a + b) * (c - d)\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::from_u64(1), \"a\");\n        let b = builder.add_const(BabyBear::from_u64(2), \"b\");\n        let c = builder.add_const(BabyBear::from_u64(3), \"c\");\n        let d = builder.add_const(BabyBear::from_u64(4), \"d\");\n\n        let sum = builder.add_add(a, b, \"sum\");\n        let diff = builder.add_sub(c, d, \"diff\");\n        let _prod = builder.add_mul(sum, diff, \"prod\");\n\n        // zero + 4 consts + 3 ops = 8 nodes\n        assert_eq!(builder.graph().nodes().len(), 8);\n\n        // Verify final operation references intermediate results\n        match \u0026builder.graph().nodes()[7] {\n            Expr::Mul { lhs, rhs } =\u003e {\n                assert_eq!(*lhs, sum);\n                assert_eq!(*rhs, diff);\n            }\n            _ =\u003e panic!(\"Expected Mul operation\"),\n        }\n    }\n\n    #[test]\n    fn test_connect_different_expressions() {\n        // Connecting different expressions should add to pending_connects\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::ONE, \"a\");\n        let b = builder.add_const(BabyBear::from_u64(2), \"b\");\n\n        builder.connect(a, b);\n\n        // Should have one pending connection\n        assert_eq!(builder.pending_connects.len(), 1);\n        assert_eq!(builder.pending_connects[0], (a, b));\n    }\n\n    #[test]\n    fn test_connect_same_expression_no_op() {\n        // Connecting an expression to itself should be a no-op\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::ONE, \"a\");\n\n        builder.connect(a, a);\n\n        // Should not add to pending_connects\n        assert!(builder.pending_connects.is_empty());\n    }\n\n    #[test]\n    fn test_connect_multiple() {\n        // Multiple connections should all be tracked\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::from_u64(1), \"a\");\n        let b = builder.add_const(BabyBear::from_u64(2), \"b\");\n        let c = builder.add_const(BabyBear::from_u64(3), \"c\");\n\n        builder.connect(a, b);\n        builder.connect(b, c);\n\n        assert_eq!(builder.pending_connects.len(), 2);\n        assert_eq!(builder.pending_connects[0], (a, b));\n        assert_eq!(builder.pending_connects[1], (b, c));\n    }\n\n    #[test]\n    fn test_connect_with_operations() {\n        // Can connect operation results\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::ONE, \"a\");\n        let b = builder.add_const(BabyBear::from_u64(2), \"b\");\n        let sum = builder.add_add(a, b, \"sum\");\n        let c = builder.add_public(0, \"c\");\n\n        builder.connect(sum, c);\n\n        assert_eq!(builder.pending_connects.len(), 1);\n        assert_eq!(builder.pending_connects[0], (sum, c));\n    }\n\n    #[test]\n    fn test_graph_accessor() {\n        // graph() should return reference to underlying graph\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        builder.add_const(BabyBear::ONE, \"one\");\n\n        let graph = builder.graph();\n        assert_eq!(graph.nodes().len(), 2); // zero + one\n    }\n\n    #[test]\n    fn test_pending_connects_accessor() {\n        // pending_connects() should return slice of connections\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        let a = builder.add_const(BabyBear::ONE, \"a\");\n        let b = builder.add_const(BabyBear::from_u64(2), \"b\");\n\n        builder.connect(a, b);\n\n        let connects = builder.pending_connects();\n        assert_eq!(connects.len(), 1);\n        assert_eq!(connects[0], (a, b));\n    }\n\n    #[test]\n    #[cfg(debug_assertions)]\n    fn test_scope_stack() {\n        // Test scope push/pop functionality\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        // Initially no scope\n        assert!(builder.current_scope().is_none());\n\n        // Push a scope\n        builder.push_scope(\"test_scope\");\n        assert_eq!(builder.current_scope(), Some(\"test_scope\"));\n\n        // Push nested scope\n        builder.push_scope(\"nested_scope\");\n        assert_eq!(builder.current_scope(), Some(\"nested_scope\"));\n\n        // Pop scope\n        builder.pop_scope();\n        assert_eq!(builder.current_scope(), Some(\"test_scope\"));\n\n        // Pop last scope\n        builder.pop_scope();\n        assert!(builder.current_scope().is_none());\n    }\n\n    #[test]\n    #[cfg(debug_assertions)]\n    fn test_allocation_log() {\n        // Allocation log should track all allocations\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        // Initial log has zero const\n        assert_eq!(builder.allocation_log().len(), 0); // Zero is pre-allocated without logging\n\n        // Add a const\n        builder.add_const(BabyBear::ONE, \"test_const\");\n        assert_eq!(builder.allocation_log().len(), 1);\n\n        // Add a public\n        builder.add_public(0, \"test_public\");\n        assert_eq!(builder.allocation_log().len(), 2);\n\n        // Add an operation\n        let a = builder.add_const(BabyBear::from_u64(2), \"a\");\n        let b = builder.add_const(BabyBear::from_u64(3), \"b\");\n        builder.add_add(a, b, \"sum\");\n        assert_eq!(builder.allocation_log().len(), 5); // +3 more (2 consts + 1 add)\n    }\n\n    #[test]\n    #[cfg(debug_assertions)]\n    fn test_list_scopes() {\n        // list_scopes should return unique scopes\n        let mut builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n\n        builder.push_scope(\"scope_a\");\n        builder.add_const(BabyBear::ONE, \"in_a\");\n\n        builder.push_scope(\"scope_b\");\n        builder.add_const(BabyBear::from_u64(2), \"in_b\");\n\n        builder.pop_scope();\n        builder.add_const(BabyBear::from_u64(3), \"in_a_again\");\n\n        let scopes = builder.list_scopes();\n        assert!(scopes.contains(\u0026\"scope_a\"));\n        assert!(scopes.contains(\u0026\"scope_b\"));\n    }\n\n    #[test]\n    #[cfg(not(debug_assertions))]\n    fn test_list_scopes_release() {\n        // In release mode, list_scopes should return empty vec\n        let builder = ExpressionBuilder::\u003cBabyBear\u003e::new();\n        assert!(builder.list_scopes().is_empty());\n    }\n}\n","traces":[{"line":108,"address":[2293175,2293137,2292320],"length":1,"stats":{"Line":22}},{"line":110,"address":[1773649],"length":1,"stats":{"Line":22}},{"line":115,"address":[4614099],"length":1,"stats":{"Line":22}},{"line":116,"address":[8351120,8349229,8351968,8350130,8348397,8350178,8351064,8351912,8348349,8349277],"length":1,"stats":{"Line":42}},{"line":119,"address":[6540819,6539942],"length":1,"stats":{"Line":20}},{"line":124,"address":[],"length":0,"stats":{"Line":21}},{"line":125,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[8349631,8351431,8348749,8350584,8352279],"length":1,"stats":{"Line":21}},{"line":129,"address":[6541131,6540289],"length":1,"stats":{"Line":20}},{"line":159,"address":[3050854,3050000],"length":1,"stats":{"Line":14}},{"line":161,"address":[3050051,3050149],"length":1,"stats":{"Line":30}},{"line":163,"address":[6547428,6546584],"length":1,"stats":{"Line":10}},{"line":167,"address":[],"length":0,"stats":{"Line":30}},{"line":170,"address":[4211545,4210681],"length":1,"stats":{"Line":15}},{"line":176,"address":[4212126,4212206,4212112,4212192],"length":1,"stats":{"Line":30}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[8364298,8365150,8363390],"length":1,"stats":{"Line":16}},{"line":201,"address":[4447008],"length":1,"stats":{"Line":17}},{"line":205,"address":[3044323],"length":1,"stats":{"Line":17}},{"line":211,"address":[3044848,3044862],"length":1,"stats":{"Line":35}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[6539104],"length":1,"stats":{"Line":6}},{"line":247,"address":[6539159],"length":1,"stats":{"Line":6}},{"line":253,"address":[4205024,4205038],"length":1,"stats":{"Line":12}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[2999632,3000265],"length":1,"stats":{"Line":9}},{"line":287,"address":[2291125,2291045],"length":1,"stats":{"Line":18}},{"line":292,"address":[4203739],"length":1,"stats":{"Line":9}},{"line":297,"address":[6535084,6535744,6534412,6536364,6536292,6535672,6535012,6534340],"length":1,"stats":{"Line":18}},{"line":298,"address":[6535855,6536020,6535198,6534725,6536478,6534526,6536677,6535397],"length":1,"stats":{"Line":18}},{"line":305,"address":[4613111],"length":1,"stats":{"Line":10}},{"line":307,"address":[4613205],"length":1,"stats":{"Line":9}},{"line":323,"address":[4614912],"length":1,"stats":{"Line":16}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[3001923],"length":1,"stats":{"Line":15}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[1775840],"length":1,"stats":{"Line":16}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[3049299],"length":1,"stats":{"Line":16}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[1775168],"length":1,"stats":{"Line":15}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[4208931],"length":1,"stats":{"Line":15}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[4615584],"length":1,"stats":{"Line":7}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[6542915],"length":1,"stats":{"Line":7}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[6538080],"length":1,"stats":{"Line":1}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":1}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[6537809,6536784],"length":1,"stats":{"Line":1}},{"line":453,"address":[6536972,6537856,6537879,6536868],"length":1,"stats":{"Line":4}},{"line":455,"address":[6537241],"length":1,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":1}},{"line":460,"address":[6537248,6538016],"length":1,"stats":{"Line":2}},{"line":461,"address":[],"length":0,"stats":{"Line":1}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[8341008,8340384,8338512,8339136,8339760],"length":1,"stats":{"Line":0}},{"line":493,"address":[8361628,8359613,8354909,8339833,8340457,8339209,8358269,8353565,8355581,8356925,8356252,8357597,8360957,8341081,8352893,8354237,8360285,8338585,8358941],"length":1,"stats":{"Line":53}},{"line":499,"address":[4209710,4207022,4200870,4207694,4200848,4209038,4199713,4200337,4208366,4201526,4201504],"length":1,"stats":{"Line":87}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[4210224,4210304],"length":1,"stats":{"Line":16}},{"line":528,"address":[],"length":0,"stats":{"Line":16}},{"line":529,"address":[6546353,6546273],"length":1,"stats":{"Line":16}},{"line":541,"address":[8352704,8352720,8352688,8352736,8352752],"length":1,"stats":{"Line":19}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[2309264],"length":1,"stats":{"Line":18}},{"line":555,"address":[2999621],"length":1,"stats":{"Line":18}},{"line":566,"address":[4203520,4203504],"length":1,"stats":{"Line":17}},{"line":567,"address":[2999605],"length":1,"stats":{"Line":17}},{"line":579,"address":[4449308,4449260,4449440,4450379,4447526,4449920,4449870,4447558,4449899,4450350],"length":1,"stats":{"Line":0}},{"line":584,"address":[4620121,4612124,4610876,4615141,4615813,4616485,4617157,4618050,4618665,4619641,4619157,4613519],"length":1,"stats":{"Line":92}},{"line":587,"address":[2310529,2311201,2308854,2315038,2311943,2313463,2312545,2314134,2314635,2314062,2311873,2311271,2307541,2308784,2312615,2314563,2307611,2315110,2310599,2313533],"length":1,"stats":{"Line":190}},{"line":590,"address":[6551920,6530556,6551958,6533579,6533623,6549504,6533047,6542038,6544010,6549055,6538480,6552431,6537618,6542666,6539486,6537574,6542710,6547872,6549017,6549542,6550998,6547916,6531180,6546026,6550960,6552393,6533003,6543382,6544682,6550015,6548553,6551471,6546070,6530512,6539530,6531136,6545398,6544726,6547037,6548591,6543338,6541994,6550472,6544054,6545354,6550510,6546993,6538524,6551433,6549977],"length":1,"stats":{"Line":189}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[4618293,4619396,4620349,4616734,4613762,4616062,4618893,4611124,4612367,4617406,4615390,4619869],"length":1,"stats":{"Line":95}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[2999568],"length":1,"stats":{"Line":8}},{"line":664,"address":[2999586],"length":1,"stats":{"Line":8}},{"line":673,"address":[2315392],"length":1,"stats":{"Line":8}},{"line":675,"address":[2298885],"length":1,"stats":{"Line":8}},{"line":687,"address":[6534032],"length":1,"stats":{"Line":1}},{"line":688,"address":[6534037],"length":1,"stats":{"Line":1}},{"line":700,"address":[6534112],"length":1,"stats":{"Line":1}},{"line":701,"address":[6534117],"length":1,"stats":{"Line":1}},{"line":714,"address":[4204400],"length":1,"stats":{"Line":2}},{"line":716,"address":[2309285],"length":1,"stats":{"Line":2}},{"line":729,"address":[],"length":0,"stats":{"Line":1}},{"line":732,"address":[],"length":0,"stats":{"Line":1}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}}],"covered":73,"coverable":130},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","mod.rs"],"content":"//! Circuit builder module with specialized sub-components.\n\nmod circuit_builder;\npub mod compiler;\nmod config;\nmod errors;\nmod expression_builder;\nmod public_input_tracker;\n\npub use circuit_builder::{CircuitBuilder, NonPrimitiveOpParams, NonPrimitiveOperationData};\npub use config::BuilderConfig;\npub use errors::CircuitBuilderError;\npub use expression_builder::ExpressionBuilder;\npub use public_input_tracker::PublicInputTracker;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","builder","public_input_tracker.rs"],"content":"/// Manages public input declarations and tracking.\n#[derive(Debug, Clone, Default)]\npub struct PublicInputTracker {\n    /// The number of public inputs declared\n    count: usize,\n}\n\nimpl PublicInputTracker {\n    /// Creates a new public input tracker.\n    pub const fn new() -\u003e Self {\n        Self { count: 0 }\n    }\n\n    /// Allocates the next public input position.\n    ///\n    /// Returns the position of the newly allocated public input.\n    pub const fn alloc(\u0026mut self) -\u003e usize {\n        let pos = self.count;\n        self.count += 1;\n        pos\n    }\n\n    /// Returns the total count of public inputs.\n    pub const fn count(\u0026self) -\u003e usize {\n        self.count\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_public_input_tracker_basic() {\n        let mut tracker = PublicInputTracker::new();\n        assert_eq!(tracker.count(), 0);\n\n        let pos0 = tracker.alloc();\n        assert_eq!(pos0, 0);\n        assert_eq!(tracker.count(), 1);\n\n        let pos1 = tracker.alloc();\n        assert_eq!(pos1, 1);\n        assert_eq!(tracker.count(), 2);\n\n        let pos2 = tracker.alloc();\n        assert_eq!(pos2, 2);\n        assert_eq!(tracker.count(), 3);\n    }\n\n    #[test]\n    fn test_public_input_tracker_default() {\n        let tracker = PublicInputTracker::default();\n        assert_eq!(tracker.count(), 0);\n    }\n}\n","traces":[{"line":17,"address":[7355408],"length":1,"stats":{"Line":12}},{"line":18,"address":[10553389],"length":1,"stats":{"Line":12}},{"line":19,"address":[10955524,10955482],"length":1,"stats":{"Line":12}},{"line":24,"address":[3969552],"length":1,"stats":{"Line":11}},{"line":25,"address":[3358565],"length":1,"stats":{"Line":11}}],"covered":5,"coverable":5},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","circuit.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\nuse core::fmt::Debug;\nuse core::ops::{Add, Mul, Sub};\n\nuse hashbrown::HashMap;\nuse p3_field::Field;\nuse strum::EnumCount;\n\nuse crate::CircuitError;\nuse crate::op::{NonPrimitiveOpConfig, NonPrimitiveOpType, Op, PrimitiveOpType};\nuse crate::tables::{CircuitRunner, TraceGeneratorFn};\nuse crate::types::{ExprId, WitnessId};\n\n/// Trait encapsulating the required field operations for circuits\npub trait CircuitField:\n    Clone\n    + Default\n    + Add\u003cOutput = Self\u003e\n    + Sub\u003cOutput = Self\u003e\n    + Mul\u003cOutput = Self\u003e\n    + PartialEq\n    + Debug\n    + Field\n{\n}\n\nimpl\u003cF\u003e CircuitField for F where\n    F: Clone\n        + Default\n        + Add\u003cOutput = F\u003e\n        + Sub\u003cOutput = F\u003e\n        + Mul\u003cOutput = F\u003e\n        + PartialEq\n        + Debug\n        + Field\n{\n}\n\n/// Static circuit specification containing constraint system and metadata\n///\n/// This represents the compiled output of a `CircuitBuilder`. It contains:\n/// - Primitive operations (add, multiply, subtract, constants, public inputs)\n/// - Non-primitive operations (complex operations like MMCS verification)\n/// - Public input metadata and witness table structure\n///\n/// The circuit is static and serializable. Use `.runner()` to create\n/// a `CircuitRunner` for execution with specific input values.\n#[derive(Debug)]\npub struct Circuit\u003cF\u003e {\n    /// Number of witness table rows\n    pub witness_count: u32,\n    /// Operations in execution order (primitive + non-primitive).\n    pub ops: Vec\u003cOp\u003cF\u003e\u003e,\n    /// Public input witness indices\n    pub public_rows: Vec\u003cWitnessId\u003e,\n    /// Total number of public field elements\n    pub public_flat_len: usize,\n    /// Enabled non-primitive operation types with their respective configuration\n    pub enabled_ops: HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e,\n    /// Expression to witness index map\n    pub expr_to_widx: HashMap\u003cExprId, WitnessId\u003e,\n    /// Registered non-primitive trace generators.\n    pub non_primitive_trace_generators: HashMap\u003cNonPrimitiveOpType, TraceGeneratorFn\u003cF\u003e\u003e,\n}\n\nimpl\u003cF: Field + Clone\u003e Clone for Circuit\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            witness_count: self.witness_count,\n            ops: self.ops.clone(),\n            public_rows: self.public_rows.clone(),\n            public_flat_len: self.public_flat_len,\n            enabled_ops: self.enabled_ops.clone(),\n            expr_to_widx: self.expr_to_widx.clone(),\n            non_primitive_trace_generators: self.non_primitive_trace_generators.clone(),\n        }\n    }\n}\n\nimpl\u003cF: Field\u003e Circuit\u003cF\u003e {\n    /// Create a new circuit with the given witness count and expression to witness index map.\n    pub fn new(witness_count: u32, expr_to_widx: HashMap\u003cExprId, WitnessId\u003e) -\u003e Self {\n        Self {\n            witness_count,\n            ops: Vec::new(),\n            public_rows: Vec::new(),\n            public_flat_len: 0,\n            enabled_ops: HashMap::new(),\n            expr_to_widx,\n            non_primitive_trace_generators: HashMap::new(),\n        }\n    }\n\n    /// Generates preprocessed columns for all primitive operation types.\n    ///\n    /// Returns a `Vec\u003cVec\u003cF\u003e\u003e` with one entry per [`PrimitiveOpType`]:\n    ///\n    /// | Index | Operation | Column Layout                             | Width (per op) |\n    /// |-------|-----------|-------------------------------------------|----------------|\n    /// | 0     | Witness   | `[idx_0, mul_0, idx_1, mul_1, ...]`       | 2              |\n    /// | 1     | Const     | `[out_0, out_1, ...]`                     | 1              |\n    /// | 2     | Public    | `[out_0, out_1, ...]`                     | 1              |\n    /// | 3     | Add       | `[a_0, b_0, out_0, a_1, b_1, out_1, ...]` | 3              |\n    /// | 4     | Mul       | `[a_0, b_0, out_0, a_1, b_1, out_1, ...]` | 3              |\n    ///\n    /// Note that `mul_i` in the Witness table preprocessed column indicates how many times\n    /// each witness index appears in the circuit.\n    /// We do not generate multiplicities for the other tables, as the multiplicity is always 1 for active operations\n    /// (0 for padding). Multiplicities are therefore generated by the tables themselves.\n    ///\n    // TODO: Centralize the multiplicity logic to make reads/writes less error-prone.\n    pub fn generate_preprocessed_columns(\u0026self) -\u003e Result\u003cVec\u003cVec\u003cF\u003e\u003e, CircuitError\u003e {\n        // Allocate one empty vector per primitive operation type (Witness, Const, Public, Add, Mul).\n        let mut preprocessed = vec![vec![]; PrimitiveOpType::COUNT];\n\n        // We know that the Witness table has at least one entry for index 0 (multiplicity 0 at the start).\n        preprocessed[PrimitiveOpType::Witness as usize].push(F::ZERO);\n        let witness_table_idx = PrimitiveOpType::Witness as usize;\n\n        // Process each primitive operation, extracting its witness indices.\n        for op in \u0026self.ops {\n            match op {\n                // Const: stores a constant value at witness[out].\n                // Preprocessed data: the output witness index.\n                Op::Const { out, .. } =\u003e {\n                    let table_idx = PrimitiveOpType::Const as usize;\n                    preprocessed[table_idx].extend(\u0026[F::from_u32(out.0)]);\n\n                    // Since the values in `PublicAir` are looked up in `WitnessAir`,\n                    // we need to take the values into account in `WitnessAir`s preprocessed multiplicities.\n                    if out.0 \u003e= preprocessed[witness_table_idx].len() as u32 {\n                        preprocessed[witness_table_idx].resize(out.0 as usize + 1, F::from_u32(0));\n                    }\n                    preprocessed[witness_table_idx][out.0 as usize] += F::ONE;\n                }\n                // Public: loads a public input into witness[out].\n                // Preprocessed data: the output witness index.\n                Op::Public { out, .. } =\u003e {\n                    let table_idx = PrimitiveOpType::Public as usize;\n                    preprocessed[table_idx].extend(\u0026[F::from_u32(out.0)]);\n\n                    // Since the values in `PublicAir` are looked up in `WitnessAir`,\n                    // we need to take the values into account in `WitnessAir`s preprocessed multiplicities.\n                    if out.0 \u003e= preprocessed[witness_table_idx].len() as u32 {\n                        preprocessed[witness_table_idx].resize(out.0 as usize + 1, F::from_u32(0));\n                    }\n                    preprocessed[witness_table_idx][out.0 as usize] += F::ONE;\n                }\n                // Add: computes witness[out] = witness[a] + witness[b].\n                // Preprocessed data: input indices a, b and output index out.\n                Op::Add { a, b, out } =\u003e {\n                    let table_idx = PrimitiveOpType::Add as usize;\n                    preprocessed[table_idx].extend(\u0026[\n                        F::from_u32(a.0),\n                        F::from_u32(b.0),\n                        F::from_u32(out.0),\n                    ]);\n\n                    // We need to update the multiplicities for `a`, `b`, and `out` in `WitnessAir`.\n                    for \u0026widx in \u0026[a.0, b.0, out.0] {\n                        if widx \u003e= preprocessed[witness_table_idx].len() as u32 {\n                            preprocessed[witness_table_idx]\n                                .resize(widx as usize + 1, F::from_u32(0));\n                        }\n                        preprocessed[witness_table_idx][widx as usize] += F::ONE;\n                    }\n                }\n\n                // Mul: computes witness[out] = witness[a] * witness[b].\n                // Preprocessed data: input indices a, b and output index out.\n                Op::Mul { a, b, out } =\u003e {\n                    let table_idx = PrimitiveOpType::Mul as usize;\n                    preprocessed[table_idx].extend(\u0026[\n                        F::from_u32(a.0),\n                        F::from_u32(b.0),\n                        F::from_u32(out.0),\n                    ]);\n\n                    // We need to update the multiplicities for `a`, `b`, and `out` in `WitnessAir`.\n                    for \u0026widx in \u0026[a.0, b.0, out.0] {\n                        if widx \u003e= preprocessed[witness_table_idx].len() as u32 {\n                            preprocessed[witness_table_idx]\n                                .resize(widx as usize + 1, F::from_u32(0));\n                        }\n                        preprocessed[witness_table_idx][widx as usize] += F::ONE;\n                    }\n                }\n                // Unconstrained: sets arbitrary witness values via hints.\n                // No preprocessed column data, but outputs affect max_idx.\n                Op::Unconstrained { outputs, .. } =\u003e {\n                    // We need to update the multiplicities for all `outputs` in `WitnessAir`. Since these are only hints, they are not recorded in any other table yet.\n                    for out in outputs {\n                        let out_idx = out.0;\n                        if out_idx \u003e= preprocessed[witness_table_idx].len() as u32 {\n                            preprocessed[witness_table_idx].resize(out_idx as usize + 1, F::ZERO);\n                        }\n                    }\n                }\n                Op::NonPrimitiveOpWithExecutor {\n                    executor,\n                    inputs,\n                    outputs,\n                    ..\n                } =\u003e {\n                    // Delegate preprocessing to the non-primitive operation.\n                    executor.preprocess(inputs, outputs, \u0026mut preprocessed);\n                }\n            }\n        }\n\n        Ok(preprocessed)\n    }\n}\n\nimpl\u003cF: CircuitField\u003e Circuit\u003cF\u003e {\n    /// Create a circuit runner for execution and trace generation\n    pub fn runner(self) -\u003e CircuitRunner\u003cF\u003e {\n        CircuitRunner::new(self)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use hashbrown::HashMap;\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n    use strum::EnumCount;\n\n    use super::*;\n    use crate::op::{DefaultHint, PrimitiveOpType};\n    use crate::types::WitnessId;\n\n    type F = BabyBear;\n\n    fn make_circuit(ops: Vec\u003cOp\u003cF\u003e\u003e) -\u003e Circuit\u003cF\u003e {\n        let mut circuit = Circuit::new(0, HashMap::new());\n        circuit.ops = ops;\n        circuit\n    }\n\n    #[test]\n    fn test_empty_circuit() {\n        let circuit: Circuit\u003cF\u003e = make_circuit(vec![]);\n        let result = circuit.generate_preprocessed_columns().unwrap();\n\n        assert_eq!(result.len(), PrimitiveOpType::COUNT);\n        assert_eq!(result[PrimitiveOpType::Witness as usize], vec![F::ZERO]);\n        assert!(result[PrimitiveOpType::Const as usize].is_empty());\n        assert!(result[PrimitiveOpType::Public as usize].is_empty());\n        assert!(result[PrimitiveOpType::Add as usize].is_empty());\n        assert!(result[PrimitiveOpType::Mul as usize].is_empty());\n    }\n\n    #[test]\n    fn test_mixed_operations() {\n        // Test covering various operation types and behaviors:\n        // - Each operation type populates its correct column\n        // - Multiplicities in Witness table are accurate\n        // - Column data preserves operation order\n        // - Unconstrained affects the Witness table preprocessing but produces no column data\n        let ops = vec![\n            Op::Const {\n                out: WitnessId(0),\n                val: F::from_u64(100),\n            },\n            Op::Public {\n                out: WitnessId(1),\n                public_pos: 0,\n            },\n            Op::Const {\n                out: WitnessId(2),\n                val: F::from_u64(200),\n            },\n            Op::Add {\n                a: WitnessId(0),\n                b: WitnessId(1),\n                out: WitnessId(3),\n            },\n            Op::Add {\n                a: WitnessId(3),\n                b: WitnessId(2),\n                out: WitnessId(4),\n            },\n            Op::Mul {\n                a: WitnessId(4),\n                b: WitnessId(2),\n                out: WitnessId(5),\n            },\n            // Unconstrained with highest index determines witness table size\n            Op::Unconstrained {\n                inputs: vec![],\n                outputs: vec![WitnessId(10)],\n                filler: DefaultHint::boxed_default(),\n            },\n        ];\n\n        let circuit = make_circuit(ops);\n        let result = circuit.generate_preprocessed_columns().unwrap();\n\n        // Const column: output indices in order\n        assert_eq!(\n            result[PrimitiveOpType::Const as usize],\n            vec![F::ZERO, F::from_u32(2)]\n        );\n\n        // Public column: output index\n        assert_eq!(\n            result[PrimitiveOpType::Public as usize],\n            vec![F::from_u32(1)]\n        );\n\n        // Add column: (a, b, out) triplets concatenated\n        assert_eq!(\n            result[PrimitiveOpType::Add as usize],\n            vec![\n                F::ZERO,\n                F::from_u32(1),\n                F::from_u32(3),\n                F::from_u32(3),\n                F::from_u32(2),\n                F::from_u32(4)\n            ]\n        );\n\n        // Mul column: (a, b, out) triplet\n        assert_eq!(\n            result[PrimitiveOpType::Mul as usize],\n            vec![F::from_u32(4), F::from_u32(2), F::from_u32(5)]\n        );\n\n        // We should have the following multiplicities in the Witness table, for indices 0 to 10:\n        // 2, 2, 3, 2, 2, 1, 0, 0, 0, 0, 0\n        let mut expected_multiplicities = vec![\n            F::from_u16(2),\n            F::from_u16(2),\n            F::from_u16(3),\n            F::from_u16(2),\n            F::from_u16(2),\n            F::from_u16(1),\n        ];\n        expected_multiplicities.extend(vec![F::ZERO; 5]); // Indices\n        assert_eq!(\n            result[PrimitiveOpType::Witness as usize],\n            expected_multiplicities\n        );\n    }\n\n    #[test]\n    fn test_input_indices_contribute_to_max_idx() {\n        // Ensures input indices that exceed outputs are tracked for witness table size\n        let ops = vec![Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(15), // Highest index is an input, not output\n            out: WitnessId(5),\n        }];\n\n        let circuit = make_circuit(ops);\n        let result = circuit.generate_preprocessed_columns().unwrap();\n\n        // Elements 0, 15 and 5 have multiplicity 1; others 0.\n        let expected_witness: Vec\u003cF\u003e = (0..=15)\n            .map(|i| {\n                if i == 0 || i == 5 || i == 15 {\n                    F::ONE\n                } else {\n                    F::ZERO\n                }\n            })\n            .collect();\n        assert_eq!(result[PrimitiveOpType::Witness as usize], expected_witness);\n    }\n}\n","traces":[{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[2195934],"length":1,"stats":{"Line":1}},{"line":71,"address":[2195949],"length":1,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[2196017],"length":1,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[2857605,2857136,2857626],"length":1,"stats":{"Line":17}},{"line":86,"address":[2179830],"length":1,"stats":{"Line":15}},{"line":87,"address":[2857243],"length":1,"stats":{"Line":17}},{"line":89,"address":[1878457],"length":1,"stats":{"Line":15}},{"line":91,"address":[2428318],"length":1,"stats":{"Line":17}},{"line":113,"address":[6065808,6081968,6065782,6065776,6070066,6077920,6070060,6070080,6073979,6077905,6077899,6074000,6061728,6081974,6073985],"length":1,"stats":{"Line":7}},{"line":115,"address":[3756455],"length":1,"stats":{"Line":8}},{"line":118,"address":[],"length":0,"stats":{"Line":16}},{"line":119,"address":[3756695,3756629],"length":1,"stats":{"Line":8}},{"line":122,"address":[3756672,3756729],"length":1,"stats":{"Line":16}},{"line":123,"address":[6480086],"length":1,"stats":{"Line":7}},{"line":126,"address":[],"length":0,"stats":{"Line":7}},{"line":127,"address":[],"length":0,"stats":{"Line":14}},{"line":128,"address":[],"length":0,"stats":{"Line":14}},{"line":132,"address":[],"length":0,"stats":{"Line":7}},{"line":133,"address":[6067205,6071433,6075353,6063101,6079293],"length":1,"stats":{"Line":5}},{"line":135,"address":[6071583,6067164,6071392,6079252,6079445,6075312,6075503,6063253,6063060,6067357],"length":1,"stats":{"Line":14}},{"line":139,"address":[6078605,6062413,6070748,6066501,6074668],"length":1,"stats":{"Line":7}},{"line":140,"address":[6481264,6480352,6481226],"length":1,"stats":{"Line":14}},{"line":141,"address":[6481234,6481293],"length":1,"stats":{"Line":14}},{"line":145,"address":[6071778,6067604,6063469,6075698,6079661],"length":1,"stats":{"Line":7}},{"line":146,"address":[],"length":0,"stats":{"Line":7}},{"line":148,"address":[6071867,6075978,6067886,6063558,6079750,6067693,6075787,6063751,6079943,6072058],"length":1,"stats":{"Line":14}},{"line":152,"address":[],"length":0,"stats":{"Line":7}},{"line":153,"address":[3758454,3757210,3758492],"length":1,"stats":{"Line":14}},{"line":154,"address":[3758614,3758462],"length":1,"stats":{"Line":14}},{"line":155,"address":[6481768],"length":1,"stats":{"Line":7}},{"line":156,"address":[3758545],"length":1,"stats":{"Line":7}},{"line":157,"address":[6072232,6063945,6068095,6076152,6080137],"length":1,"stats":{"Line":7}},{"line":161,"address":[3758674],"length":1,"stats":{"Line":7}},{"line":162,"address":[6482121],"length":1,"stats":{"Line":7}},{"line":163,"address":[],"length":0,"stats":{"Line":12}},{"line":164,"address":[6482279],"length":1,"stats":{"Line":6}},{"line":166,"address":[3758954,3759143],"length":1,"stats":{"Line":14}},{"line":172,"address":[6066665,6078769,6070912,6074832,6062577],"length":1,"stats":{"Line":6}},{"line":173,"address":[],"length":0,"stats":{"Line":12}},{"line":174,"address":[3759362,3759210],"length":1,"stats":{"Line":12}},{"line":175,"address":[],"length":0,"stats":{"Line":6}},{"line":176,"address":[3759293],"length":1,"stats":{"Line":6}},{"line":177,"address":[6482564],"length":1,"stats":{"Line":6}},{"line":181,"address":[6081026,6069095,6064834,6073085,6077005],"length":1,"stats":{"Line":6}},{"line":182,"address":[],"length":0,"stats":{"Line":6}},{"line":183,"address":[3759731,3759841],"length":1,"stats":{"Line":12}},{"line":184,"address":[],"length":0,"stats":{"Line":6}},{"line":186,"address":[6073521,6065108,6077279,6073359,6081300,6069369,6065281,6069542,6077441,6081473],"length":1,"stats":{"Line":12}},{"line":191,"address":[6480601],"length":1,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[6077614,6081664,6065472,6073694,6069748],"length":1,"stats":{"Line":1}},{"line":195,"address":[3760044],"length":1,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[3760243,3757446],"length":1,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":7}},{"line":218,"address":[6484640,6484608],"length":1,"stats":{"Line":15}},{"line":219,"address":[6484648,6484616],"length":1,"stats":{"Line":18}}],"covered":61,"coverable":68},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","errors.rs"],"content":"use alloc::string::String;\n\nuse thiserror::Error;\n\nuse crate::op::NonPrimitiveOpType;\nuse crate::types::NonPrimitiveOpId;\nuse crate::{CircuitBuilderError, ExprId, WitnessId};\n\n/// Errors that can occur during circuit execution and trace generation.\n#[derive(Debug, Error)]\npub enum CircuitError {\n    /// Public input length mismatch.\n    #[error(\"Public input length mismatch: expected {expected}, got {got}\")]\n    PublicInputLengthMismatch { expected: usize, got: usize },\n\n    /// Circuit missing public_rows mapping.\n    #[error(\"Circuit missing public_rows mapping\")]\n    MissingPublicRowsMapping,\n\n    /// NonPrimitiveOpId out of range.\n    #[error(\"NonPrimitiveOpId {op_id} out of range (circuit has {max_ops} complex ops)\")]\n    NonPrimitiveOpIdOutOfRange { op_id: u32, max_ops: usize },\n\n    /// Public input not set for a WitnessId.\n    #[error(\"Public input not set for WitnessId({witness_id})\")]\n    PublicInputNotSet { witness_id: WitnessId },\n\n    /// Witness not set for a WitnessId.\n    #[error(\"Witness not set for WitnessId({witness_id})\")]\n    WitnessNotSet { witness_id: WitnessId },\n\n    /// WitnessId out of bounds.\n    #[error(\"WitnessId({witness_id}) out of bounds\")]\n    WitnessIdOutOfBounds { witness_id: WitnessId },\n\n    /// Witness conflict: trying to reassign to a different value.\n    #[error(\n        \"Witness conflict: WitnessId({witness_id}) already set to {existing}, cannot reassign to {new}\"\n    )]\n    WitnessConflict {\n        witness_id: WitnessId,\n        existing: String,\n        new: String,\n    },\n\n    /// Witness not set for an index during trace generation.\n    #[error(\"Witness not set for index {index}\")]\n    WitnessNotSetForIndex { index: usize },\n\n    /// Non-primitive op attempted to read a witness value that was not set.\n    #[error(\"Witness value not set for non-primitive operation {operation_index}\")]\n    NonPrimitiveOpWitnessNotSet { operation_index: NonPrimitiveOpId },\n\n    /// Missing private data for a non-primitive operation.\n    #[error(\"Missing private data for non-primitive operation {operation_index}\")]\n    NonPrimitiveOpMissingPrivateData { operation_index: NonPrimitiveOpId },\n\n    /// Division by zero encountered.\n    #[error(\"Division by zero encountered\")]\n    DivisionByZero,\n\n    /// Invalid bit value in SampleBits bit decomposition (must be 0 or 1).\n    #[error(\n        \"Invalid bit value in SampleBits bit decomposition for WitnessId({input_witness_id}): {bit_value} (must be 0 or 1)\"\n    )]\n    InvalidBitValue {\n        input_witness_id: WitnessId,\n        bit_value: String,\n    },\n\n    /// Bit decomposition doesn't reconstruct to the input value.\n    #[error(\n        \"Bit decomposition for WitnessId({input_witness_id}) doesn't match input: expected {expected}, reconstructed {reconstructed}\"\n    )]\n    BitDecompositionMismatch {\n        input_witness_id: WitnessId,\n        expected: String,\n        reconstructed: String,\n    },\n\n    /// Mismatched non-primitive operation configuration\n    #[error(\"Invalid configuration for operation {op:?}\")]\n    InvalidNonPrimitiveOpConfiguration { op: NonPrimitiveOpType },\n\n    /// Non-primitive operation has incorrect input/output layout.\n    #[error(\"Incorrect layout for operation {op:?}: expected {expected}, got {got}\")]\n    NonPrimitiveOpLayoutMismatch {\n        op: NonPrimitiveOpType,\n        expected: String,\n        got: usize,\n    },\n\n    /// Incorrect size of private data provided for a non-primitive operation.\n    #[error(\n        \"Incorrect size of private data provided for operation {op:?}: expected {expected}, got {got}\"\n    )]\n    IncorrectNonPrimitiveOpPrivateDataSize {\n        op: NonPrimitiveOpType,\n        expected: String,\n        got: usize,\n    },\n\n    /// Non primitive private data is not correct\n    #[error(\n        \"Incorrect private data provided for op {op:?} (operation {operation_index}): expected {expected}, got {got}\"\n    )]\n    IncorrectNonPrimitiveOpPrivateData {\n        op: NonPrimitiveOpType,\n        operation_index: NonPrimitiveOpId,\n        expected: String,\n        got: String,\n    },\n\n    /// ExprId not found.\n    #[error(\"ExprId {expr_id} not found\")]\n    ExprIdNotFound { expr_id: ExprId },\n\n    /// Invalid Circuit\n    #[error(\"Failed to build circuit: {error}\")]\n    InvalidCircuit { error: CircuitBuilderError },\n\n    /// Unconstrained operation is given an incorrect number of inputs.\n    #[error(\"Unconstrained operation input length mismatch: expected {op} {expected}, got {got}\")]\n    UnconstrainedOpInputLengthMismatch {\n        op: String,\n        expected: usize,\n        got: usize,\n    },\n\n    /// Requested bit length exceeds the maximum allowed for binary decomposition.\n    #[error(\"Too many bits for binary decomposition: expected at most {expected}, got {n_bits}\")]\n    BinaryDecompositionTooManyBits { expected: usize, n_bits: usize },\n\n    /// Invalid preprocessed values\n    #[error(\"Preprocessed values should be base field elements\")]\n    InvalidPreprocessedValues,\n\n    /// Poseidon2 chaining requires previous state but none was available.\n    #[error(\n        \"Poseidon2 chain missing previous state for operation {operation_index} (new_start=false but no previous permutation)\"\n    )]\n    Poseidon2ChainMissingPreviousState { operation_index: NonPrimitiveOpId },\n\n    /// Poseidon2 merkle path mode requires a sibling input limb (which limbs are required depends on `mmcs_bit`).\n    #[error(\n        \"Poseidon2 merkle path missing sibling input for operation {operation_index}, limb {limb}\"\n    )]\n    Poseidon2MerkleMissingSiblingInput {\n        operation_index: NonPrimitiveOpId,\n        limb: usize,\n    },\n\n    /// Poseidon2 operation is missing required input limb.\n    #[error(\n        \"Poseidon2 operation {operation_index} missing input for limb {limb} (new_start=true requires all inputs)\"\n    )]\n    Poseidon2MissingInput {\n        operation_index: NonPrimitiveOpId,\n        limb: usize,\n    },\n}\n\nimpl From\u003cCircuitBuilderError\u003e for CircuitError {\n    fn from(error: CircuitBuilderError) -\u003e Self {\n        Self::InvalidCircuit { error }\n    }\n}\n","traces":[{"line":164,"address":[3892784],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","expr.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::types::{ExprId, NonPrimitiveOpId};\n\n/// Expression DAG for field operations\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum Expr\u003cF\u003e {\n    /// Constant field element\n    Const(F),\n    /// Public input at declaration position\n    Public(usize),\n    /// Witness hints — allocates a `WitnessId` representing a\n    /// non-deterministic hint. The boolean flag indicates whether\n    /// this is the last witness in a sequence of related hints,\n    /// where each sequence is produced through a shared generation process.\n    Hint { is_last_hint: bool },\n    /// Addition of two expressions\n    Add { lhs: ExprId, rhs: ExprId },\n    /// Subtraction of two expressions\n    Sub { lhs: ExprId, rhs: ExprId },\n    /// Multiplication of two expressions\n    Mul { lhs: ExprId, rhs: ExprId },\n    /// Division of two expressions\n    Div { lhs: ExprId, rhs: ExprId },\n    /// Anchor node for a non-primitive operation in the expression DAG.\n    ///\n    /// This node has no witness value itself, but it fixes the relative execution order\n    /// of non-primitive ops w.r.t. other expressions during lowering.\n    ///\n    /// The `inputs` field contains all input expressions (flattened from witness_exprs),\n    /// making dependencies explicit in the DAG structure. This enables proper topological\n    /// analysis and ensures the lowerer emits ops after their inputs are available.\n    ///\n    /// For stateful ops (e.g., Poseidon2 perm chaining with `in_ctl=false`), `inputs` may\n    /// be empty since chained values flow internally and are not materialized in the\n    /// witness table. Execution order for such ops is determined by their position in\n    /// the ops list during lowering.\n    NonPrimitiveCall {\n        op_id: NonPrimitiveOpId,\n        inputs: Vec\u003cExprId\u003e,\n    },\n    /// Output of a non-primitive operation.\n    ///\n    /// This node represents a value produced by a non-primitive op. The `call` field\n    /// points to the `NonPrimitiveCall` expression node, making the dependency explicit\n    /// in the DAG structure. `output_idx` selects which output of that op this refers to.\n    NonPrimitiveOutput { call: ExprId, output_idx: u32 },\n}\n\n/// Graph for storing expression DAG nodes\n#[derive(Debug, Clone, Default)]\npub struct ExpressionGraph\u003cF\u003e {\n    nodes: Vec\u003cExpr\u003cF\u003e\u003e,\n}\n\nimpl\u003cF\u003e ExpressionGraph\u003cF\u003e {\n    pub const fn new() -\u003e Self {\n        Self { nodes: Vec::new() }\n    }\n\n    /// Add an expression to the graph, returning its ID\n    pub fn add_expr(\u0026mut self, expr: Expr\u003cF\u003e) -\u003e ExprId {\n        let id = ExprId(self.nodes.len() as u32);\n        self.nodes.push(expr);\n        id\n    }\n\n    /// Get an expression by ID\n    pub fn get_expr(\u0026self, id: ExprId) -\u003e \u0026Expr\u003cF\u003e {\n        \u0026self.nodes[id.0 as usize]\n    }\n\n    /// Get all nodes in the graph\n    pub fn nodes(\u0026self) -\u003e \u0026[Expr\u003cF\u003e] {\n        \u0026self.nodes\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Mock extension field element for testing\n    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n    struct MockExtField(u64);\n\n    #[test]\n    fn test_expression_graph() {\n        let mut graph = ExpressionGraph::\u003cMockExtField\u003e::new();\n\n        let const_expr = Expr::Const(MockExtField(42));\n        let public_expr = Expr::Public(0);\n\n        let const_id = graph.add_expr(const_expr.clone());\n        let public_id = graph.add_expr(public_expr.clone());\n\n        assert_eq!(const_id, ExprId::ZERO);\n        assert_eq!(public_id, ExprId(1));\n\n        assert_eq!(graph.get_expr(const_id), \u0026const_expr);\n        assert_eq!(graph.get_expr(public_id), \u0026public_expr);\n\n        let add_expr = Expr::Add {\n            lhs: const_id,\n            rhs: public_id,\n        };\n        let add_id = graph.add_expr(add_expr.clone());\n        assert_eq!(add_id, ExprId(2));\n        assert_eq!(graph.get_expr(add_id), \u0026add_expr);\n    }\n\n    #[cfg(test)]\n    mod proptests {\n        use proptest::prelude::*;\n\n        use super::*;\n\n        proptest! {\n            #[test]\n            fn expr_get_returns_added(vals in prop::collection::vec(any::\u003cu64\u003e().prop_map(MockExtField), 1..30)) {\n                let mut graph = ExpressionGraph::\u003cMockExtField\u003e::new();\n                let mut ids = Vec::new();\n\n                for val in \u0026vals {\n                    let expr = Expr::Const(val.clone());\n                    let id = graph.add_expr(expr.clone());\n                    ids.push(id);\n                }\n\n                for (id, val) in ids.iter().zip(vals.iter()) {\n                    let retrieved = graph.get_expr(*id);\n                    prop_assert_eq!(retrieved, \u0026Expr::Const(val.clone()), \"get should return added expression\");\n                }\n            }\n\n            #[test]\n            fn expr_primitive_ops(val1 in any::\u003cu64\u003e().prop_map(MockExtField), val2 in any::\u003cu64\u003e().prop_map(MockExtField)) {\n                let mut graph = ExpressionGraph::\u003cMockExtField\u003e::new();\n\n                let id1 = graph.add_expr(Expr::Const(val1));\n                let id2 = graph.add_expr(Expr::Const(val2));\n\n                let add_id = graph.add_expr(Expr::Add { lhs: id1, rhs: id2 });\n                match graph.get_expr(add_id) {\n                    Expr::Add { lhs, rhs } =\u003e {\n                        prop_assert_eq!(*lhs, id1);\n                        prop_assert_eq!(*rhs, id2);\n                    }\n                    _ =\u003e prop_assert!(false, \"expected Add expr\"),\n                }\n\n                let sub_id = graph.add_expr(Expr::Sub { lhs: id1, rhs: id2 });\n                match graph.get_expr(sub_id) {\n                    Expr::Sub { lhs, rhs } =\u003e {\n                        prop_assert_eq!(*lhs, id1);\n                        prop_assert_eq!(*rhs, id2);\n                    }\n                    _ =\u003e prop_assert!(false, \"expected Sub expr\"),\n                }\n\n                let mul_id = graph.add_expr(Expr::Mul { lhs: id1, rhs: id2 });\n                match graph.get_expr(mul_id) {\n                    Expr::Mul { lhs, rhs } =\u003e {\n                        prop_assert_eq!(*lhs, id1);\n                        prop_assert_eq!(*rhs, id2);\n                    }\n                    _ =\u003e prop_assert!(false, \"expected Mul expr\"),\n                }\n\n                let div_id = graph.add_expr(Expr::Div { lhs: id1, rhs: id2 });\n                match graph.get_expr(div_id) {\n                    Expr::Div { lhs, rhs } =\u003e {\n                        prop_assert_eq!(*lhs, id1);\n                        prop_assert_eq!(*rhs, id2);\n                    }\n                    _ =\u003e prop_assert!(false, \"expected Div expr\"),\n                }\n            }\n\n            #[test]\n            fn expr_public_positions(positions in prop::collection::vec(0usize..100, 0..20)) {\n                let mut graph = ExpressionGraph::\u003cMockExtField\u003e::new();\n                let mut ids = Vec::new();\n\n                for \u0026pos in \u0026positions {\n                    let id = graph.add_expr(Expr::Public(pos));\n                    ids.push(id);\n                }\n\n                for (\u0026id, \u0026expected_pos) in ids.iter().zip(positions.iter()) {\n                    match graph.get_expr(id) {\n                        Expr::Public(pos) =\u003e {\n                            prop_assert_eq!(*pos, expected_pos, \"public position should match\");\n                        }\n                        _ =\u003e prop_assert!(false, \"expected Public expr\"),\n                    }\n                }\n            }\n\n            #[test]\n            fn expr_equality(val in any::\u003cu64\u003e().prop_map(MockExtField)) {\n                let expr1 = Expr::Const(val.clone());\n                let expr2 = Expr::Const(val.clone());\n                let expr3 = Expr::Const(MockExtField(val.0 + 1));\n\n                prop_assert_eq!(\u0026expr1, \u0026expr2, \"same expressions should be equal\");\n                prop_assert_ne!(\u0026expr1, \u0026expr3, \"different expressions should not be equal\");\n            }\n        }\n    }\n}\n","traces":[{"line":57,"address":[1895232],"length":1,"stats":{"Line":23}},{"line":58,"address":[2465085],"length":1,"stats":{"Line":23}},{"line":62,"address":[4446848,4446980,4447002],"length":1,"stats":{"Line":22}},{"line":63,"address":[7075347,7075253,7075413,7075187,7075027,7075093],"length":1,"stats":{"Line":43}},{"line":64,"address":[2808793],"length":1,"stats":{"Line":21}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[2465312],"length":1,"stats":{"Line":2}},{"line":70,"address":[4467837],"length":1,"stats":{"Line":2}},{"line":74,"address":[2808688],"length":1,"stats":{"Line":16}},{"line":75,"address":[1895301],"length":1,"stats":{"Line":16}}],"covered":9,"coverable":10},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","lib.rs"],"content":"#![no_std]\nextern crate alloc;\n\n#[cfg(debug_assertions)]\npub mod alloc_entry;\n\npub mod builder;\npub mod circuit;\npub mod errors;\npub mod expr;\npub mod op;\npub mod ops;\npub mod policy;\npub mod tables;\npub mod test_utils;\npub mod types;\npub mod utils;\n\n// Re-export public API\n#[cfg(debug_assertions)]\npub use alloc_entry::{AllocationEntry, AllocationType};\npub use builder::{CircuitBuilder, CircuitBuilderError};\npub use circuit::{Circuit, CircuitField};\npub use errors::CircuitError;\npub use expr::{Expr, ExpressionGraph};\npub use op::{NonPrimitiveOpPrivateData, NonPrimitiveOpType, Op};\npub use ops::Poseidon2PermOps;\npub use tables::{CircuitRunner, Traces};\npub use types::{ExprId, NonPrimitiveOpId, WitnessAllocator, WitnessId};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","op.rs"],"content":"use alloc::boxed::Box;\nuse alloc::sync::Arc;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::fmt::Debug;\nuse core::hash::Hash;\n\nuse hashbrown::HashMap;\nuse p3_field::Field;\nuse strum_macros::EnumCount;\n\nuse crate::tables::Poseidon2PermPrivateData;\nuse crate::types::{NonPrimitiveOpId, WitnessId};\nuse crate::{CircuitError, ExprId};\n\n/// Circuit operations.\n///\n/// Operations are distinguised as primitive and non-primitive:\n///\n/// # Primitive operations\n///\n/// Primitive operations that represent basic field arithmetic\n///\n/// These operations form the core computational primitives after expression lowering.\n/// All primitive operations:\n/// - Operate on witness table slots (WitnessId)\n/// - Can be heavily optimized (constant folding, CSE, etc.)\n/// - Are executed in topological order during circuit evaluation\n/// - Form a directed acyclic graph (DAG) of dependencies\n///\n/// # Non-primitive operations\n///\n/// Non-primitive operations may represent complex computations that would require too many,\n/// primitive operations to be expressed equivalently.\n///\n/// They can be user-defined and selected at runtime, have private data that does not appear\n/// in the central Witness bus, and are subject to their own optimization passes.\n#[derive(Debug)]\npub enum Op\u003cF\u003e {\n    /// Load a constant value into the witness table\n    ///\n    /// Sets `witness[out] = val`. Used for literal constants and\n    /// supports constant pooling optimization where identical constants\n    /// reuse the same witness slot.\n    Const { out: WitnessId, val: F },\n\n    /// Load a public input value into the witness table\n    ///\n    /// Sets `witness[out] = public_inputs[public_pos]`. Public inputs\n    /// are values known to both prover and verifier, typically used\n    /// for circuit inputs and expected outputs.\n    Public { out: WitnessId, public_pos: usize },\n\n    /// Field addition: witness[out] = witness[a] + witness[b]\n    Add {\n        a: WitnessId,\n        b: WitnessId,\n        out: WitnessId,\n    },\n\n    /// Field multiplication: witness[out] = witness[a] * witness[b]\n    Mul {\n        a: WitnessId,\n        b: WitnessId,\n        out: WitnessId,\n    },\n\n    /// Load unconstrained values into the witness table\n    ///\n    /// Sets `witness[output]`, for each `output` in `outputs`, to arbitrary values\n    /// defined by `filler`.\n    Unconstrained {\n        inputs: Vec\u003cWitnessId\u003e,\n        outputs: Vec\u003cWitnessId\u003e,\n        filler: Box\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e,\n    },\n\n    /// Non-primitive operation with executor-based dispatch\n    NonPrimitiveOpWithExecutor {\n        inputs: Vec\u003cVec\u003cWitnessId\u003e\u003e,\n        outputs: Vec\u003cVec\u003cWitnessId\u003e\u003e,\n        executor: Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e,\n        /// For private data lookup and error reporting\n        op_id: NonPrimitiveOpId,\n    },\n}\n\n#[derive(EnumCount)]\npub enum PrimitiveOpType {\n    Witness = 0,\n    Const = 1,\n    Public = 2,\n    Add = 3,\n    Mul = 4,\n}\n\n#[allow(clippy::fallible_impl_from)]\nimpl From\u003cusize\u003e for PrimitiveOpType {\n    fn from(value: usize) -\u003e Self {\n        match value {\n            0 =\u003e Self::Witness,\n            1 =\u003e Self::Const,\n            2 =\u003e Self::Public,\n            3 =\u003e Self::Add,\n            4 =\u003e Self::Mul,\n            _ =\u003e panic!(\"Invalid PrimitiveOpType value: {}\", value),\n        }\n    }\n}\n\n// Custom Clone implementation for Op\nimpl\u003cF: Field + Clone\u003e Clone for Op\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::Const { out, val } =\u003e Self::Const {\n                out: *out,\n                val: *val,\n            },\n            Self::Public { out, public_pos } =\u003e Self::Public {\n                out: *out,\n                public_pos: *public_pos,\n            },\n            Self::Add { a, b, out } =\u003e Self::Add {\n                a: *a,\n                b: *b,\n                out: *out,\n            },\n            Self::Mul { a, b, out } =\u003e Self::Mul {\n                a: *a,\n                b: *b,\n                out: *out,\n            },\n            Self::Unconstrained {\n                inputs,\n                outputs,\n                filler,\n            } =\u003e Self::Unconstrained {\n                inputs: inputs.clone(),\n                outputs: outputs.clone(),\n                filler: filler.clone(),\n            },\n            Self::NonPrimitiveOpWithExecutor {\n                inputs,\n                outputs,\n                executor,\n                op_id,\n            } =\u003e Self::NonPrimitiveOpWithExecutor {\n                inputs: inputs.clone(),\n                outputs: outputs.clone(),\n                executor: executor.boxed(),\n                op_id: *op_id,\n            },\n        }\n    }\n}\n\n// Custom PartialEq implementation for Op\nimpl\u003cF: Field + PartialEq\u003e PartialEq for Op\u003cF\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        match (self, other) {\n            (Self::Const { out: o1, val: v1 }, Self::Const { out: o2, val: v2 }) =\u003e {\n                o1 == o2 \u0026\u0026 v1 == v2\n            }\n            (\n                Self::Public {\n                    out: o1,\n                    public_pos: p1,\n                },\n                Self::Public {\n                    out: o2,\n                    public_pos: p2,\n                },\n            ) =\u003e o1 == o2 \u0026\u0026 p1 == p2,\n            (\n                Self::Add {\n                    a: a1,\n                    b: b1,\n                    out: o1,\n                },\n                Self::Add {\n                    a: a2,\n                    b: b2,\n                    out: o2,\n                },\n            ) =\u003e a1 == a2 \u0026\u0026 b1 == b2 \u0026\u0026 o1 == o2,\n            (\n                Self::Mul {\n                    a: a1,\n                    b: b1,\n                    out: o1,\n                },\n                Self::Mul {\n                    a: a2,\n                    b: b2,\n                    out: o2,\n                },\n            ) =\u003e a1 == a2 \u0026\u0026 b1 == b2 \u0026\u0026 o1 == o2,\n            (\n                Self::NonPrimitiveOpWithExecutor {\n                    inputs: i1,\n                    outputs: o1,\n                    executor: e1,\n                    op_id: id1,\n                },\n                Self::NonPrimitiveOpWithExecutor {\n                    inputs: i2,\n                    outputs: o2,\n                    executor: e2,\n                    op_id: id2,\n                },\n            ) =\u003e i1 == i2 \u0026\u0026 o1 == o2 \u0026\u0026 e1.op_type() == e2.op_type() \u0026\u0026 id1 == id2,\n            _ =\u003e false,\n        }\n    }\n}\n\n/// Non-primitive operation types\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum NonPrimitiveOpType {\n    /// Poseidon2 permutation operation (one Poseidon2 call / table row).\n    Poseidon2Perm,\n}\n\n/// Type alias for the Poseidon2 permutation execution closure.\n///\n/// The closure takes 4 extension field limbs and returns 4 output limbs.\npub type Poseidon2PermExec\u003cF\u003e = Arc\u003cdyn Fn(\u0026[F; 4]) -\u003e [F; 4] + Send + Sync\u003e;\n\n/// Configuration for Poseidon2 permutation operations.\n///\n/// Contains an execution closure that computes the Poseidon2 permutation.\n/// The closure takes 4 extension field limbs and returns 4 output limbs.\npub struct Poseidon2PermConfig\u003cF\u003e {\n    /// Execution closure: converts [F;4] extension limbs to [Base;16],\n    /// runs the permutation, and converts back to [F;4].\n    pub exec: Poseidon2PermExec\u003cF\u003e,\n}\n\nimpl\u003cF\u003e Clone for Poseidon2PermConfig\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            exec: Arc::clone(\u0026self.exec),\n        }\n    }\n}\n\nimpl\u003cF\u003e Debug for Poseidon2PermConfig\u003cF\u003e {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        f.debug_struct(\"Poseidon2PermConfig\")\n            .field(\"exec\", \u0026\"\u003cclosure\u003e\")\n            .finish()\n    }\n}\n\n/// Non-primitive operation configuration.\n///\n/// Contains operation-specific configuration data, such as execution closures.\npub enum NonPrimitiveOpConfig\u003cF\u003e {\n    /// No configuration needed (placeholder for future operations).\n    None,\n    /// Poseidon2 permutation configuration with exec closure.\n    Poseidon2Perm(Poseidon2PermConfig\u003cF\u003e),\n}\n\nimpl\u003cF\u003e Clone for NonPrimitiveOpConfig\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        match self {\n            Self::None =\u003e Self::None,\n            Self::Poseidon2Perm(cfg) =\u003e Self::Poseidon2Perm(cfg.clone()),\n        }\n    }\n}\n\nimpl\u003cF\u003e Debug for NonPrimitiveOpConfig\u003cF\u003e {\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        match self {\n            Self::None =\u003e write!(f, \"None\"),\n            Self::Poseidon2Perm(cfg) =\u003e f.debug_tuple(\"Poseidon2Perm\").field(cfg).finish(),\n        }\n    }\n}\n\n// Compare/Hash by variant only (ignore closure contents)\nimpl\u003cF\u003e PartialEq for NonPrimitiveOpConfig\u003cF\u003e {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        matches!(\n            (self, other),\n            (Self::None, Self::None) | (Self::Poseidon2Perm(_), Self::Poseidon2Perm(_))\n        )\n    }\n}\n\nimpl\u003cF\u003e Eq for NonPrimitiveOpConfig\u003cF\u003e {}\n\nimpl\u003cF\u003e Hash for NonPrimitiveOpConfig\u003cF\u003e {\n    fn hash\u003cH: core::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        core::mem::discriminant(self).hash(state);\n    }\n}\n\n/// Non-primitive operations representing complex cryptographic constraints.\n///\n/// These operations implement sophisticated cryptographic primitives that:\n/// - Have dedicated AIR tables for constraint verification\n/// - Take witness values as public interface\n/// - May require separate private data for complete specification\n/// - Are NOT subject to primitive optimizations (CSE, constant folding)\n/// - Enable modular addition of complex functionality\n///\n/// Non-primitive operations are isolated from primitive optimizations to:\n/// 1. Maintain clean separation between basic arithmetic and complex crypto\n/// 2. Allow specialized constraint systems for each operation type\n/// 3. Enable parallel development of different cryptographic primitives\n/// 4. Avoid optimization passes breaking complex constraint relationships\n///\n/// Private auxiliary data for non-primitive operations\n///\n/// This data is NOT part of the witness table but provides additional\n/// parameters needed to fully specify complex operations. Private data:\n/// - Is set during circuit execution via `NonPrimitiveOpId`\n/// - Contains sensitive information like cryptographic witnesses\n/// - Is used by AIR tables to generate the appropriate constraints\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum NonPrimitiveOpPrivateData\u003cF\u003e {\n    Poseidon2Perm(Poseidon2PermPrivateData\u003cF\u003e),\n}\n\n/// Execution context providing operations access to witness table, private data, and configs\n///\n/// This context is passed to operation executors to give them access to all necessary\n/// runtime state without exposing internal implementation details.\npub struct ExecutionContext\u003c'a, F\u003e {\n    /// Mutable reference to witness table for reading/writing values\n    witness: \u0026'a mut [Option\u003cF\u003e],\n    /// Private data map for non-primitive operations\n    non_primitive_op_private_data: \u0026'a [Option\u003cNonPrimitiveOpPrivateData\u003cF\u003e\u003e],\n    /// Operation configurations\n    enabled_ops: \u0026'a HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e,\n    /// Current operation's NonPrimitiveOpId for error reporting\n    operation_id: NonPrimitiveOpId,\n    /// Global chaining state for Poseidon2 permutation.\n    /// Stores the output of the last Poseidon2 permutation for chaining.\n    last_poseidon: \u0026'a mut Option\u003c[F; 4]\u003e,\n}\n\nimpl\u003c'a, F: Field\u003e ExecutionContext\u003c'a, F\u003e {\n    /// Create a new execution context\n    pub const fn new(\n        witness: \u0026'a mut [Option\u003cF\u003e],\n        non_primitive_op_private_data: \u0026'a [Option\u003cNonPrimitiveOpPrivateData\u003cF\u003e\u003e],\n        enabled_ops: \u0026'a HashMap\u003cNonPrimitiveOpType, NonPrimitiveOpConfig\u003cF\u003e\u003e,\n        operation_id: NonPrimitiveOpId,\n        last_poseidon: \u0026'a mut Option\u003c[F; 4]\u003e,\n    ) -\u003e Self {\n        Self {\n            witness,\n            non_primitive_op_private_data,\n            enabled_ops,\n            operation_id,\n            last_poseidon,\n        }\n    }\n\n    /// Get witness value at the given index\n    pub fn get_witness(\u0026self, widx: WitnessId) -\u003e Result\u003cF, CircuitError\u003e {\n        self.witness\n            .get(widx.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .cloned()\n            .ok_or(CircuitError::WitnessNotSet { witness_id: widx })\n    }\n\n    /// Set witness value at the given index\n    pub fn set_witness(\u0026mut self, widx: WitnessId, value: F) -\u003e Result\u003c(), CircuitError\u003e {\n        if widx.0 as usize \u003e= self.witness.len() {\n            return Err(CircuitError::WitnessIdOutOfBounds { witness_id: widx });\n        }\n\n        // Check for conflicting reassignment\n        if let Some(existing_value) = self.witness[widx.0 as usize]\n            \u0026\u0026 existing_value != value\n        {\n            return Err(CircuitError::WitnessConflict {\n                witness_id: widx,\n                existing: format!(\"{existing_value:?}\"),\n                new: format!(\"{value:?}\"),\n            });\n        }\n\n        self.witness[widx.0 as usize] = Some(value);\n        Ok(())\n    }\n\n    /// Get private data for the current operation\n    pub fn get_private_data(\u0026self) -\u003e Result\u003c\u0026NonPrimitiveOpPrivateData\u003cF\u003e, CircuitError\u003e {\n        self.non_primitive_op_private_data\n            .get(self.operation_id.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .ok_or(CircuitError::NonPrimitiveOpMissingPrivateData {\n                operation_index: self.operation_id,\n            })\n    }\n\n    /// Get operation configuration by type\n    pub fn get_config(\n        \u0026self,\n        op_type: \u0026NonPrimitiveOpType,\n    ) -\u003e Result\u003c\u0026NonPrimitiveOpConfig\u003cF\u003e, CircuitError\u003e {\n        self.enabled_ops.get(op_type).ok_or_else(|| {\n            CircuitError::InvalidNonPrimitiveOpConfiguration {\n                op: op_type.clone(),\n            }\n        })\n    }\n\n    /// Get the current operation ID\n    pub const fn operation_id(\u0026self) -\u003e NonPrimitiveOpId {\n        self.operation_id\n    }\n\n    /// Get the last Poseidon2 permutation output for chaining.\n    ///\n    /// Returns `None` if no Poseidon2 permutation has been executed yet.\n    pub const fn last_poseidon2(\u0026self) -\u003e Option\u003c[F; 4]\u003e {\n        *self.last_poseidon\n    }\n\n    /// Set the last Poseidon2 permutation output for chaining.\n    ///\n    /// This should be called after each Poseidon2 permutation execution.\n    pub const fn set_last_poseidon2(\u0026mut self, output: [F; 4]) {\n        *self.last_poseidon = Some(output);\n    }\n}\n\n/// Trait for executable non-primitive operations\n///\n/// This trait enables dynamic dispatch and allows each operation to control\n/// its own execution logic with full access to the execution context.\npub trait NonPrimitiveExecutor\u003cF: Field\u003e: Debug {\n    /// Execute the operation with full context access\n    ///\n    /// # Arguments\n    /// * `inputs` - Input witness indices\n    /// * `outputs` - Output witness indices\n    /// * `ctx` - Execution context with access to witness table, private data, and configs\n    fn execute(\n        \u0026self,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        outputs: \u0026[Vec\u003cWitnessId\u003e],\n        ctx: \u0026mut ExecutionContext\u003c'_, F\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e;\n\n    /// Get operation type identifier (for config lookup, error reporting)\n    fn op_type(\u0026self) -\u003e \u0026NonPrimitiveOpType;\n\n    /// Allow downcasting to concrete executor types\n    fn as_any(\u0026self) -\u003e \u0026dyn core::any::Any;\n\n    /// Update the preprocessed values related to this operation. This consists of:\n    /// - the preprocessed values for the associated table\n    /// - the multiplicity for the `Witness` table.\n    fn preprocess(\n        \u0026self,\n        _inputs: \u0026[Vec\u003cWitnessId\u003e],\n        _outputs: \u0026[Vec\u003cWitnessId\u003e],\n        _preprocessed_tables: \u0026mut Vec\u003cVec\u003cF\u003e\u003e,\n    ) {\n    }\n\n    /// Clone as trait object\n    fn boxed(\u0026self) -\u003e Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e;\n}\n\n// Implement Clone for Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e\nimpl\u003cF: Field\u003e Clone for Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        self.boxed()\n    }\n}\n\n/// A trait for defining how unconstrained data (hints) is set.\npub trait WitnessHintsFiller\u003cF\u003e: Debug + WitnessFillerClone\u003cF\u003e {\n    /// Return the `ExprId` of the inputs\n    fn inputs(\u0026self) -\u003e \u0026[ExprId];\n    /// Return number of outputs filled by this filler\n    fn n_outputs(\u0026self) -\u003e usize;\n    /// Compute the output given the inputs\n    /// # Arguments\n    /// * `inputs` - Input witness\n    fn compute_outputs(\u0026self, inputs_val: Vec\u003cF\u003e) -\u003e Result\u003cVec\u003cF\u003e, CircuitError\u003e;\n}\n\nimpl\u003cF\u003e Clone for Box\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        self.clone_box()\n    }\n}\n\n#[derive(Debug, Clone, Default)]\npub struct DefaultHint {\n    pub n_outputs: usize,\n}\n\nimpl DefaultHint {\n    pub fn boxed_default\u003cF: Default + Clone\u003e() -\u003e Box\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e {\n        Box::new(Self::default())\n    }\n}\n\nimpl\u003cF: Default + Clone\u003e WitnessHintsFiller\u003cF\u003e for DefaultHint {\n    fn inputs(\u0026self) -\u003e \u0026[ExprId] {\n        \u0026[]\n    }\n\n    fn n_outputs(\u0026self) -\u003e usize {\n        self.n_outputs\n    }\n\n    fn compute_outputs(\u0026self, _inputs_val: Vec\u003cF\u003e) -\u003e Result\u003cVec\u003cF\u003e, CircuitError\u003e {\n        Ok(vec![F::default(); self.n_outputs])\n    }\n}\n\n// Object-safe \"clone into Box\" helper\npub trait WitnessFillerClone\u003cF\u003e {\n    fn clone_box(\u0026self) -\u003e Box\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e;\n}\n\nimpl\u003cF, T\u003e WitnessFillerClone\u003cF\u003e for T\nwhere\n    T: WitnessHintsFiller\u003cF\u003e + Clone + 'static,\n{\n    fn clone_box(\u0026self) -\u003e Box\u003cdyn WitnessHintsFiller\u003cF\u003e\u003e {\n        Box::new(self.clone())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_op_partial_eq_different_variants() {\n        // Create operations of completely different types\n        let const_op = Op::Const {\n            out: WitnessId(0),\n            val: F::from_u64(5),\n        };\n\n        let add_op = Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(2),\n        };\n\n        // Operations of different variants should never be equal\n        assert_ne!(const_op, add_op);\n    }\n\n    #[test]\n    fn test_op_partial_eq_same_variant_different_values() {\n        // Create two addition operations with different witness indices\n        let add_op1: Op\u003cF\u003e = Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(2),\n        };\n\n        let add_op2: Op\u003cF\u003e = Op::Add {\n            a: WitnessId(3),\n            b: WitnessId(4),\n            out: WitnessId(5),\n        };\n\n        // Same variant but different values should not be equal\n        assert_ne!(add_op1, add_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_add_same_values() {\n        // Create two identical addition operations\n        let a = WitnessId(0);\n        let b = WitnessId(1);\n        let out = WitnessId(2);\n\n        let add_op1: Op\u003cF\u003e = Op::Add { a, b, out };\n        let add_op2: Op\u003cF\u003e = Op::Add { a, b, out };\n\n        // Identical operations should be equal\n        assert_eq!(add_op1, add_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_const_different_values() {\n        // Create two constant operations with different values\n        let out = WitnessId(0);\n        let val1 = F::from_u64(10);\n        let val2 = F::from_u64(20);\n\n        let const_op1: Op\u003cF\u003e = Op::Const { out, val: val1 };\n        let const_op2: Op\u003cF\u003e = Op::Const { out, val: val2 };\n\n        // Same output but different values should not be equal\n        assert_ne!(const_op1, const_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_const_different_outputs() {\n        // Create two constant operations with same value but different outputs\n        let val = F::from_u64(42);\n        let out1 = WitnessId(0);\n        let out2 = WitnessId(1);\n\n        let const_op1: Op\u003cF\u003e = Op::Const { out: out1, val };\n        let const_op2: Op\u003cF\u003e = Op::Const { out: out2, val };\n\n        // Same value but different outputs should not be equal\n        assert_ne!(const_op1, const_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_const_same_values() {\n        // Create two identical constant operations\n        let out = WitnessId(0);\n        let val = F::from_u64(99);\n\n        let const_op1: Op\u003cF\u003e = Op::Const { out, val };\n        let const_op2: Op\u003cF\u003e = Op::Const { out, val };\n\n        // Identical constant operations should be equal\n        assert_eq!(const_op1, const_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_public_different_positions() {\n        // Create two public input operations with different positions\n        let out = WitnessId(0);\n        let pos1 = 0;\n        let pos2 = 1;\n\n        let public_op1: Op\u003cF\u003e = Op::Public {\n            out,\n            public_pos: pos1,\n        };\n        let public_op2: Op\u003cF\u003e = Op::Public {\n            out,\n            public_pos: pos2,\n        };\n\n        // Same output but different positions should not be equal\n        assert_ne!(public_op1, public_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_public_same_values() {\n        // Create two identical public input operations\n        let out = WitnessId(5);\n        let public_pos = 3;\n\n        let public_op1: Op\u003cF\u003e = Op::Public { out, public_pos };\n        let public_op2: Op\u003cF\u003e = Op::Public { out, public_pos };\n\n        // Identical public operations should be equal\n        assert_eq!(public_op1, public_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_mul_different_values() {\n        // Create two multiplication operations with different witness indices\n        let mul_op1: Op\u003cF\u003e = Op::Mul {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(2),\n        };\n\n        let mul_op2: Op\u003cF\u003e = Op::Mul {\n            a: WitnessId(10),\n            b: WitnessId(11),\n            out: WitnessId(12),\n        };\n\n        // Different witness indices should not be equal\n        assert_ne!(mul_op1, mul_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_mul_same_values() {\n        // Create two identical multiplication operations\n        let a = WitnessId(7);\n        let b = WitnessId(8);\n        let out = WitnessId(9);\n\n        let mul_op1: Op\u003cF\u003e = Op::Mul { a, b, out };\n        let mul_op2: Op\u003cF\u003e = Op::Mul { a, b, out };\n\n        // Identical multiplication operations should be equal\n        assert_eq!(mul_op1, mul_op2);\n    }\n\n    #[test]\n    fn test_op_partial_eq_add_partial_match() {\n        // Create two addition operations where only some fields match\n        let add_op1: Op\u003cF\u003e = Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(2),\n        };\n\n        let add_op2: Op\u003cF\u003e = Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(99), // Different output\n        };\n\n        // Partial match is not enough for equality\n        assert_ne!(add_op1, add_op2);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Invalid PrimitiveOpType value\")]\n    fn test_primitive_op_type_invalid_conversion() {\n        // Attempt to convert an invalid index to an operation type\n        //\n        // This should panic\n        let _ = PrimitiveOpType::from(999);\n    }\n\n    #[test]\n    fn test_execution_context_get_witness() {\n        // Create a witness table with known test values\n        let val = F::from_u64(42);\n        let mut witness = vec![Some(val), Some(F::from_u64(100))];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        // Create an execution context for operations to access the witness\n        let ctx = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Read a value from the witness table\n        let result = ctx.get_witness(WitnessId(0));\n\n        // Verify the read operation succeeded and returned the correct value\n        assert_eq!(result.unwrap(), val);\n    }\n\n    #[test]\n    fn test_execution_context_get_witness_unset() {\n        // Create a witness table where some values are not yet set\n        let mut witness = vec![None, Some(F::from_u64(100))];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        // Create execution context\n        let ctx = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Attempt to read a value that hasn't been set yet\n        let result = ctx.get_witness(WitnessId(0));\n\n        // Reading unset values should produce an error\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(witness_id, WitnessId(0));\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_set_witness() {\n        // Create an empty witness table to be populated\n        let mut witness = vec![None, None];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        // Create execution context with mutable access to witness\n        let mut ctx = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Write a computed value into the witness table\n        let val = F::from_u64(99);\n        let result = ctx.set_witness(WitnessId(0), val);\n\n        // Verify the write operation succeeded\n        assert!(result.is_ok());\n\n        // Verify the value was actually written to the witness table\n        assert_eq!(witness[0], Some(val));\n    }\n\n    #[test]\n    fn test_execution_context_set_witness_conflict() {\n        // Create a witness table with an existing value\n        let existing_val = F::from_u64(50);\n        let mut witness = vec![Some(existing_val)];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        // Create execution context\n        let mut ctx = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Attempt to write a different value to the same slot\n        //\n        // This represents a conflicting constraint in the circuit\n        let new_val = F::from_u64(99);\n        let result = ctx.set_witness(WitnessId(0), new_val);\n\n        // Conflicting writes must be detected and reported as errors\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::WitnessConflict { witness_id, .. }) =\u003e {\n                assert_eq!(witness_id, WitnessId(0));\n            }\n            _ =\u003e panic!(\"Expected WitnessConflict error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_set_witness_idempotent() {\n        // Create a witness table with an existing value\n        let val = F::from_u64(50);\n        let mut witness = vec![Some(val)];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        // Create execution context\n        let mut ctx = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Write the same value again to the same slot\n        //\n        // This is allowed and represents consistent constraints\n        let result = ctx.set_witness(WitnessId(0), val);\n\n        // Idempotent writes should succeed without error\n        assert!(result.is_ok());\n        assert_eq!(witness[0], Some(val));\n    }\n\n    #[test]\n    fn test_execution_context_set_witness_out_of_bounds() {\n        // Create a small witness table with limited capacity\n        let mut witness = vec![None];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        // Create execution context\n        let mut ctx = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Attempt to write to an index beyond the table bounds\n        let result = ctx.set_witness(WitnessId(10), F::from_u64(1));\n\n        // Out of bounds writes must be caught to prevent memory corruption\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::WitnessIdOutOfBounds { witness_id }) =\u003e {\n                assert_eq!(witness_id, WitnessId(10));\n            }\n            _ =\u003e panic!(\"Expected WitnessIdOutOfBounds error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_get_private_data() {\n        // Create private auxiliary data for a verification operation\n        let poseidon2_data: Poseidon2PermPrivateData\u003cF\u003e = Poseidon2PermPrivateData {\n            sibling: [F::ZERO, F::ZERO],\n        };\n        let private_data = vec![Some(NonPrimitiveOpPrivateData::Poseidon2Perm(\n            poseidon2_data.clone(),\n        ))];\n\n        // Create execution context with access to private data\n        let mut witness = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n        let ctx = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Operations can access their private data through the context\n        let result = ctx.get_private_data();\n\n        // Verify private data access succeeded\n        assert_eq!(\n            *result.unwrap(),\n            NonPrimitiveOpPrivateData::Poseidon2Perm(poseidon2_data)\n        );\n    }\n\n    #[test]\n    fn test_execution_context_get_private_data_missing() {\n        // Create an execution context without private data\n        let private_data = vec![];\n        let mut witness = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        // Create execution context\n        let ctx: ExecutionContext\u003c'_, F\u003e = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Attempt to access private data that wasn't provided\n        let result = ctx.get_private_data();\n\n        // Missing private data should be reported as an error\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::NonPrimitiveOpMissingPrivateData { operation_index }) =\u003e {\n                assert_eq!(operation_index, op_id);\n            }\n            _ =\u003e panic!(\"Expected NonPrimitiveOpMissingPrivateData error\"),\n        }\n    }\n\n    #[test]\n    fn test_execution_context_get_config() {\n        // Create a configuration map for operation parameters\n        let mut configs = HashMap::new();\n        let op_type = NonPrimitiveOpType::Poseidon2Perm;\n        configs.insert(op_type.clone(), NonPrimitiveOpConfig::None);\n\n        // Create execution context with configurations\n        let mut witness = vec![];\n        let private_data = vec![];\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n        let ctx: ExecutionContext\u003c'_, F\u003e = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Operations can query their configuration at runtime\n        let result = ctx.get_config(\u0026op_type);\n\n        // Verify configuration lookup succeeded\n        assert_eq!(*result.unwrap(), NonPrimitiveOpConfig::None);\n    }\n\n    #[test]\n    fn test_execution_context_get_config_missing() {\n        // Create an empty configuration map\n        let configs = HashMap::new();\n        let mut witness = vec![];\n        let private_data = vec![];\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        // Create execution context\n        let ctx: ExecutionContext\u003c'_, F\u003e = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Attempt to access a configuration that wasn't registered\n        let op_type = NonPrimitiveOpType::Poseidon2Perm;\n        let result = ctx.get_config(\u0026op_type);\n\n        // Missing configurations indicate setup errors\n        assert!(result.is_err());\n        match result {\n            Err(CircuitError::InvalidNonPrimitiveOpConfiguration { op }) =\u003e {\n                assert_eq!(op, op_type);\n            }\n            _ =\u003e panic!(\"Expected InvalidNonPrimitiveOpConfiguration error\"),\n        }\n    }\n\n    #[test]\n    fn test_default_hint_compute_outputs() {\n        // Create a default hint that produces multiple outputs\n        let hint = DefaultHint { n_outputs: 3 };\n\n        // Compute default values for all outputs\n        let result = hint.compute_outputs(vec![]);\n\n        // Verify the correct number of default-initialized values\n        let outputs: Vec\u003cF\u003e = result.unwrap();\n        assert_eq!(outputs.len(), 3);\n        assert_eq!(outputs[0], F::default());\n        assert_eq!(outputs[1], F::default());\n        assert_eq!(outputs[2], F::default());\n    }\n\n    #[test]\n    fn test_execution_context_operation_id() {\n        // Create execution context with a specific operation identifier\n        let mut witness = vec![];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let expected_id = NonPrimitiveOpId(42);\n        let mut last_poseidon = None;\n        let ctx: ExecutionContext\u003c'_, F\u003e = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            expected_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Retrieve the operation ID from the context\n        let retrieved_id = ctx.operation_id();\n\n        // Verify the ID is correctly preserved\n        assert_eq!(retrieved_id, expected_id);\n    }\n\n    #[test]\n    fn test_execution_context_poseidon2_chaining() {\n        // Test the Poseidon2 chaining state accessors\n        let mut witness = vec![];\n        let private_data = vec![];\n        let configs = HashMap::new();\n        let op_id = NonPrimitiveOpId(0);\n        let mut last_poseidon = None;\n\n        let mut ctx = ExecutionContext::new(\n            \u0026mut witness,\n            \u0026private_data,\n            \u0026configs,\n            op_id,\n            \u0026mut last_poseidon,\n        );\n\n        // Initially, last_poseidon should be None\n        assert!(ctx.last_poseidon2().is_none());\n\n        // Set the last Poseidon2 output\n        let output = [F::ONE, F::from_u64(2), F::from_u64(3), F::from_u64(4)];\n        ctx.set_last_poseidon2(output);\n\n        // Verify the output was stored\n        assert_eq!(ctx.last_poseidon2(), Some(output));\n    }\n}\n","traces":[{"line":99,"address":[3940448],"length":1,"stats":{"Line":3}},{"line":100,"address":[6720969],"length":1,"stats":{"Line":3}},{"line":101,"address":[11042757],"length":1,"stats":{"Line":2}},{"line":102,"address":[2693404],"length":1,"stats":{"Line":2}},{"line":103,"address":[3412723],"length":1,"stats":{"Line":2}},{"line":104,"address":[3940602],"length":1,"stats":{"Line":2}},{"line":105,"address":[10640705],"length":1,"stats":{"Line":3}},{"line":106,"address":[10640590],"length":1,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":16}},{"line":114,"address":[1754686],"length":1,"stats":{"Line":18}},{"line":116,"address":[6716673,6715569],"length":1,"stats":{"Line":16}},{"line":117,"address":[1945348],"length":1,"stats":{"Line":18}},{"line":120,"address":[1945445],"length":1,"stats":{"Line":17}},{"line":121,"address":[2702552],"length":1,"stats":{"Line":17}},{"line":124,"address":[4020316,4019214],"length":1,"stats":{"Line":16}},{"line":125,"address":[1945535],"length":1,"stats":{"Line":17}},{"line":126,"address":[4019220,4020322],"length":1,"stats":{"Line":16}},{"line":129,"address":[4019305,4020407],"length":1,"stats":{"Line":16}},{"line":130,"address":[9589596,9587420,9590698,9588522,9586340],"length":1,"stats":{"Line":15}},{"line":131,"address":[6715853,6716927],"length":1,"stats":{"Line":15}},{"line":133,"address":[4020483,4019381],"length":1,"stats":{"Line":6}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[9587515,9589691,9586438,9588617,9590793],"length":1,"stats":{"Line":6}},{"line":139,"address":[6717037,6715963],"length":1,"stats":{"Line":6}},{"line":140,"address":[3577999],"length":1,"stats":{"Line":6}},{"line":142,"address":[6715978,6717052],"length":1,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[2106198],"length":1,"stats":{"Line":0}},{"line":149,"address":[2702952],"length":1,"stats":{"Line":0}},{"line":150,"address":[3024914],"length":1,"stats":{"Line":0}},{"line":151,"address":[9588014,9591298,9589122,9586949,9590190],"length":1,"stats":{"Line":0}},{"line":159,"address":[6717696,6717786],"length":1,"stats":{"Line":1}},{"line":160,"address":[6717729,6717793],"length":1,"stats":{"Line":2}},{"line":161,"address":[6718099],"length":1,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[6718224],"length":1,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[6718353],"length":1,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[6718553],"length":1,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[6718727],"length":1,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[1967536],"length":1,"stats":{"Line":0}},{"line":242,"address":[1967541],"length":1,"stats":{"Line":0}},{"line":248,"address":[6720512],"length":1,"stats":{"Line":0}},{"line":249,"address":[6720526],"length":1,"stats":{"Line":0}},{"line":250,"address":[6720549],"length":1,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[1967581],"length":1,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[6720765],"length":1,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[6721220,6721182,6721151],"length":1,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[2945904],"length":1,"stats":{"Line":1}},{"line":365,"address":[3931312,3931424],"length":1,"stats":{"Line":1}},{"line":366,"address":[2042955],"length":1,"stats":{"Line":1}},{"line":367,"address":[6609938,6610050],"length":1,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":6}},{"line":370,"address":[],"length":0,"stats":{"Line":2}},{"line":374,"address":[1734848,1735569,1735575],"length":1,"stats":{"Line":1}},{"line":375,"address":[],"length":0,"stats":{"Line":2}},{"line":376,"address":[3931695,3932606],"length":1,"stats":{"Line":1}},{"line":380,"address":[2665903,2665977],"length":1,"stats":{"Line":5}},{"line":381,"address":[1735047],"length":1,"stats":{"Line":2}},{"line":383,"address":[2945364],"length":1,"stats":{"Line":1}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[1912872],"length":1,"stats":{"Line":1}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":390,"address":[1735639,1735078,1735607],"length":1,"stats":{"Line":3}},{"line":391,"address":[3509637],"length":1,"stats":{"Line":2}},{"line":395,"address":[2044048],"length":1,"stats":{"Line":1}},{"line":396,"address":[1913514],"length":1,"stats":{"Line":2}},{"line":397,"address":[9400914,9400802,9401026,9400690,9400578],"length":1,"stats":{"Line":2}},{"line":398,"address":[1735775,1735840,1735849],"length":1,"stats":{"Line":4}},{"line":399,"address":[2666883],"length":1,"stats":{"Line":1}},{"line":400,"address":[6612112,6612224],"length":1,"stats":{"Line":1}},{"line":405,"address":[3508576],"length":1,"stats":{"Line":1}},{"line":409,"address":[2042864,2042820],"length":1,"stats":{"Line":2}},{"line":410,"address":[1734685],"length":1,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":1}},{"line":417,"address":[9400288,9400256,9400240,9400272,9400224],"length":1,"stats":{"Line":1}},{"line":418,"address":[2666757],"length":1,"stats":{"Line":1}},{"line":424,"address":[2044000],"length":1,"stats":{"Line":1}},{"line":425,"address":[2666785],"length":1,"stats":{"Line":1}},{"line":431,"address":[9401408,9401328,9401264,9401472,9401552],"length":1,"stats":{"Line":1}},{"line":432,"address":[1735877],"length":1,"stats":{"Line":1}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":6}},{"line":496,"address":[],"length":0,"stats":{"Line":6}},{"line":506,"address":[6609584],"length":1,"stats":{"Line":1}},{"line":507,"address":[6609585],"length":1,"stats":{"Line":1}},{"line":512,"address":[],"length":0,"stats":{"Line":1}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[6728944],"length":1,"stats":{"Line":1}},{"line":517,"address":[6728949],"length":1,"stats":{"Line":1}},{"line":520,"address":[],"length":0,"stats":{"Line":1}},{"line":521,"address":[6728780,6728831],"length":1,"stats":{"Line":2}},{"line":534,"address":[4172736],"length":1,"stats":{"Line":8}},{"line":535,"address":[3875174],"length":1,"stats":{"Line":8}}],"covered":78,"coverable":147},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","ops","mod.rs"],"content":"pub mod poseidon2_perm;\n\npub use poseidon2_perm::{Poseidon2PermCall, Poseidon2PermExecutor, Poseidon2PermOps};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","ops","poseidon2_perm.rs"],"content":"//! Poseidon2 permutation non-primitive operation (one Poseidon2 call per row).\n//!\n//! This operation is designed to support both standard hashing and specific logic required for\n//! Merkle path verification within a circuit. Its features include:\n//!\n//! - **Hashing**: Performs a standard Poseidon2 permutation.\n//! - **Chaining**: Can start a new hash computation or continue from the output of the previous row\n//!   (controlled by `new_start`).\n//! - **Merkle Path Verification**: When `merkle_path` is enabled, it supports logic for verifying\n//!   a path up a Merkle tree. This involves conditionally arranging inputs (sibling vs. computed hash)\n//!   based on a direction bit (`mmcs_bit`).\n//! - **Index Accumulation**: Supports accumulating path indices (`mmcs_index_sum`) to verify the\n//!   leaf's position in the tree.\n//!\n//! Only supports extension degree D=4 for now.\n\nuse alloc::boxed::Box;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\n\nuse p3_field::{Field, PrimeCharacteristicRing};\nuse strum::EnumCount;\n\nuse crate::CircuitError;\nuse crate::builder::{CircuitBuilder, NonPrimitiveOpParams};\nuse crate::op::{\n    ExecutionContext, NonPrimitiveExecutor, NonPrimitiveOpConfig, NonPrimitiveOpPrivateData,\n    NonPrimitiveOpType, PrimitiveOpType,\n};\nuse crate::types::{ExprId, NonPrimitiveOpId, WitnessId};\n\n/// User-facing arguments for adding a Poseidon2 perm row.\npub struct Poseidon2PermCall {\n    /// Flag indicating whether a new chain is started.\n    pub new_start: bool,\n    /// Flag indicating whether we are verifying a Merkle path\n    pub merkle_path: bool,\n    /// MMCS direction bit input (base field, boolean).\n    ///\n    /// Required when `merkle_path = true`. When `merkle_path = false`, this may be omitted and\n    /// defaults to 0 (not exposed via CTL).\n    pub mmcs_bit: Option\u003cExprId\u003e,\n    /// Optional CTL exposure for each input limb (one extension element).\n    /// If `None`, the limb is not exposed via CTL (in_ctl = 0).\n    /// Note: For Merkle mode, unexposed limbs are provided via Poseidon2PermPrivateData (the sibling).\n    pub inputs: [Option\u003cExprId\u003e; 4],\n    /// Output exposure flags for limbs 0 and 1.\n    ///\n    /// When `out_ctl[i]` is true, this call allocates an output witness expression for limb `i`\n    /// (returned from `add_poseidon2_perm`) and exposes it via CTL. Limbs 2–3 are never exposed.\n    pub out_ctl: [bool; 2],\n    /// Optional MMCS index accumulator value to expose.\n    pub mmcs_index_sum: Option\u003cExprId\u003e,\n}\n\n/// Convenience helpers to build calls with defaults.\nimpl Default for Poseidon2PermCall {\n    fn default() -\u003e Self {\n        Self {\n            new_start: false,\n            merkle_path: false,\n            mmcs_bit: None,\n            inputs: [None, None, None, None],\n            out_ctl: [false, false],\n            mmcs_index_sum: None,\n        }\n    }\n}\n\npub trait Poseidon2PermOps\u003cF: Clone + PrimeCharacteristicRing + Eq\u003e {\n    /// Add a Poseidon2 perm row (one permutation).\n    ///\n    /// - `new_start`: if true, this row starts a new chain (no chaining from previous row).\n    /// - `merkle_path`: if true, Merkle-path chaining semantics apply (chained digest placement depends on `mmcs_bit`).\n    /// - `mmcs_bit`: Merkle direction bit witness for this row (used when `merkle_path` is true).\n    /// - `inputs`: optional CTL exposure per limb (extension element, length 4 if provided).\n    ///   Unexposed limbs in Merkle mode are provided separately via `Poseidon2PermPrivateData`.\n    /// - `out_ctl`: whether to allocate/expose output limbs 0–1 via CTL.\n    /// - `mmcs_index_sum`: optional exposure of the MMCS index accumulator (base field element).\n    fn add_poseidon2_perm(\n        \u0026mut self,\n        call: Poseidon2PermCall,\n    ) -\u003e Result\u003c(NonPrimitiveOpId, [Option\u003cExprId\u003e; 2]), crate::CircuitBuilderError\u003e;\n}\n\nimpl\u003cF\u003e Poseidon2PermOps\u003cF\u003e for CircuitBuilder\u003cF\u003e\nwhere\n    F: Clone + PrimeCharacteristicRing + Eq + core::hash::Hash,\n{\n    fn add_poseidon2_perm(\n        \u0026mut self,\n        call: Poseidon2PermCall,\n    ) -\u003e Result\u003c(NonPrimitiveOpId, [Option\u003cExprId\u003e; 2]), crate::CircuitBuilderError\u003e {\n        let op_type = NonPrimitiveOpType::Poseidon2Perm;\n        self.ensure_op_enabled(op_type.clone())?;\n        if call.merkle_path \u0026\u0026 call.mmcs_bit.is_none() {\n            return Err(crate::CircuitBuilderError::Poseidon2MerkleMissingMmcsBit);\n        }\n        if !call.merkle_path \u0026\u0026 call.mmcs_bit.is_some() {\n            return Err(crate::CircuitBuilderError::Poseidon2NonMerkleWithMmcsBit);\n        }\n\n        // Build input_exprs layout: [in0, in1, in2, in3, mmcs_index_sum, mmcs_bit]\n        let mut input_exprs: Vec\u003cVec\u003cExprId\u003e\u003e = Vec::with_capacity(6);\n\n        for limb in call.inputs.iter() {\n            if let Some(val) = limb {\n                input_exprs.push(vec![*val]);\n            } else {\n                input_exprs.push(Vec::new());\n            }\n        }\n\n        if let Some(idx_sum) = call.mmcs_index_sum {\n            input_exprs.push(vec![idx_sum]);\n        } else {\n            input_exprs.push(Vec::new());\n        }\n\n        if let Some(bit) = call.mmcs_bit {\n            input_exprs.push(vec![bit]);\n        } else {\n            input_exprs.push(Vec::new());\n        }\n\n        let output_0 = call.out_ctl.first().copied().unwrap_or(false);\n        let output_1 = call.out_ctl.get(1).copied().unwrap_or(false);\n\n        let (op_id, _call_expr_id, outputs) = self.push_non_primitive_op_with_outputs(\n            op_type,\n            input_exprs,\n            vec![\n                output_0.then_some(\"poseidon2_perm_out0\"),\n                output_1.then_some(\"poseidon2_perm_out1\"),\n            ],\n            Some(NonPrimitiveOpParams::Poseidon2Perm {\n                new_start: call.new_start,\n                merkle_path: call.merkle_path,\n            }),\n            \"poseidon2_perm\",\n        );\n        Ok((op_id, [outputs[0], outputs[1]]))\n    }\n}\n\n/// Executor for Poseidon2 perm operations.\n///\n#[derive(Debug, Clone)]\npub struct Poseidon2PermExecutor {\n    op_type: NonPrimitiveOpType,\n    pub new_start: bool,\n    pub merkle_path: bool,\n}\n\nimpl Poseidon2PermExecutor {\n    pub const fn new(new_start: bool, merkle_path: bool) -\u003e Self {\n        Self {\n            op_type: NonPrimitiveOpType::Poseidon2Perm,\n            new_start,\n            merkle_path,\n        }\n    }\n}\n\nimpl\u003cF: Field\u003e NonPrimitiveExecutor\u003cF\u003e for Poseidon2PermExecutor {\n    fn execute(\n        \u0026self,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        outputs: \u0026[Vec\u003cWitnessId\u003e],\n        ctx: \u0026mut ExecutionContext\u003c'_, F\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        // Input layout: [in0, in1, in2, in3, mmcs_index_sum, mmcs_bit]\n        // Output layout: [out0, out1]\n        if inputs.len() != 6 {\n            return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                op: self.op_type.clone(),\n                expected: \"6 input vectors\".to_string(),\n                got: inputs.len(),\n            });\n        }\n        if outputs.len() != 2 {\n            return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                op: self.op_type.clone(),\n                expected: \"2 output vectors\".to_string(),\n                got: outputs.len(),\n            });\n        }\n\n        // Get the exec closure from config\n        let config = ctx.get_config(\u0026self.op_type)?;\n        let exec = match config {\n            NonPrimitiveOpConfig::Poseidon2Perm(cfg) =\u003e \u0026cfg.exec,\n            NonPrimitiveOpConfig::None =\u003e {\n                return Err(CircuitError::InvalidNonPrimitiveOpConfiguration {\n                    op: self.op_type.clone(),\n                });\n            }\n        };\n\n        // Get private data if available\n        let private_data = ctx.get_private_data().ok();\n        let private_inputs: Option\u003c\u0026[F]\u003e = private_data.map(|pd| match pd {\n            NonPrimitiveOpPrivateData::Poseidon2Perm(data) =\u003e \u0026data.sibling[..],\n        });\n\n        // Get mmcs_bit (required when merkle_path=true; defaults to false otherwise).\n        // mmcs_bit is at inputs[5].\n        let mmcs_bit = if inputs[5].len() == 1 {\n            let wid = inputs[5][0];\n            let val = ctx.get_witness(wid)?;\n            if val == F::ZERO {\n                false\n            } else if val == F::ONE {\n                true\n            } else {\n                return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                    op: self.op_type.clone(),\n                    operation_index: ctx.operation_id(),\n                    expected: \"boolean mmcs_bit (0 or 1)\".to_string(),\n                    got: format!(\"{val:?}\"),\n                });\n            }\n        } else if self.merkle_path {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                op: self.op_type.clone(),\n                operation_index: ctx.operation_id(),\n                expected: \"mmcs_bit must be provided when merkle_path=true\".to_string(),\n                got: \"missing mmcs_bit\".to_string(),\n            });\n        } else {\n            false\n        };\n\n        // Resolve input limbs\n        let mut resolved_inputs = [F::ZERO; 4];\n        for (limb, resolved) in resolved_inputs.iter_mut().enumerate() {\n            *resolved = self.resolve_input_limb(limb, inputs, private_inputs, ctx, mmcs_bit)?;\n        }\n\n        // Execute the permutation\n        let output = exec(\u0026resolved_inputs);\n\n        // Update chaining state\n        ctx.set_last_poseidon2(output);\n\n        // Write outputs to witness if CTL exposure is requested\n        for (out_idx, out_slot) in outputs.iter().enumerate() {\n            if out_slot.len() == 1 {\n                let wid = out_slot[0];\n                ctx.set_witness(wid, output[out_idx])?;\n            } else if !out_slot.is_empty() {\n                return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                    op: self.op_type.clone(),\n                    expected: \"0 or 1 witness per output limb\".to_string(),\n                    got: out_slot.len(),\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    fn op_type(\u0026self) -\u003e \u0026NonPrimitiveOpType {\n        \u0026self.op_type\n    }\n\n    fn as_any(\u0026self) -\u003e \u0026dyn core::any::Any {\n        self\n    }\n\n    fn preprocess(\n        \u0026self,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        outputs: \u0026[Vec\u003cWitnessId\u003e],\n        preprocessed_tables: \u0026mut Vec\u003cVec\u003cF\u003e\u003e,\n    ) {\n        let witness_table_idx = PrimitiveOpType::Witness as usize;\n        let update_witness_table = |witness_ids: \u0026[WitnessId], p_ts: \u0026mut Vec\u003cVec\u003cF\u003e\u003e| {\n            for witness_id in witness_ids {\n                let idx = witness_id.0 as usize;\n                if idx \u003e= p_ts[witness_table_idx].len() {\n                    p_ts[witness_table_idx].resize(idx + 1, F::from_u32(0));\n                }\n                p_ts[witness_table_idx][idx] += F::ONE;\n            }\n        };\n\n        // We need to populate in_ctl and out_ctl for this operation.\n        let idx = PrimitiveOpType::COUNT + self.op_type.clone() as usize;\n        if preprocessed_tables.len() \u003c= idx {\n            preprocessed_tables.resize(idx + 1, vec![]);\n        }\n\n        // The inputs have shape:\n        // inputs[0..3]: input limbs, inputs[4]: mmcs_index_sum, inputs[5]: mmcs_bit\n        // The outputs have shape:\n        // outputs[0..1]: output limbs exposed via CTL\n        // The shape of one preprocessed row is:\n        // [in_idx0, in_ctl_0, normal_chain_sel[0], merkle_chain_sel[0], in_idx1, in1_ctl, normal_chain_sel[1], merkle_chain_sel[1], ..., out_idx0, out_ctl_0, out_idx1, out_ctl_1, mmcs_index_sum_ctl_idx, new_start, merkle_path]\n\n        // First, let's add the input indices and `in_ctl` values.\n        for (limb_idx, inp) in inputs[0..4].iter().enumerate() {\n            if inp.is_empty() {\n                // Private input\n                preprocessed_tables[idx].push(F::ZERO); // in_idx\n                preprocessed_tables[idx].push(F::ZERO); // in_ctl\n            } else {\n                // Exposed input\n                preprocessed_tables[idx].push(F::from_u32(inp[0].0)); // in_idx\n                preprocessed_tables[idx].push(F::ONE); // in_ctl\n\n                // In this case, we are reading the input limbs from the witness table,\n                // so we need to update the associated witness table multiplicities.\n                update_witness_table(inp, preprocessed_tables);\n            }\n            let normal_chain_sel =\n                if !self.new_start \u0026\u0026 !self.merkle_path \u0026\u0026 inputs[limb_idx].is_empty() {\n                    F::ONE\n                } else {\n                    F::ZERO\n                };\n\n            preprocessed_tables[idx].push(normal_chain_sel);\n\n            let merkle_chain_sel =\n                if !self.new_start \u0026\u0026 self.merkle_path \u0026\u0026 inputs[limb_idx].is_empty() {\n                    F::ONE\n                } else {\n                    F::ZERO\n                };\n            preprocessed_tables[idx].push(merkle_chain_sel);\n        }\n\n        for out in outputs[0..2].iter() {\n            if out.is_empty() {\n                // Private output\n                preprocessed_tables[idx].push(F::ZERO); // out_idx\n                preprocessed_tables[idx].push(F::ZERO); // out_ctl\n            } else {\n                // Exposed output\n                preprocessed_tables[idx].push(F::from_u32(out[0].0)); // out_idx\n                preprocessed_tables[idx].push(F::ONE); // out_ctl\n\n                // In this case, we are reading the output limbs from the witness table,\n                // so we need to update the associated witness table multiplicities.\n                update_witness_table(out, preprocessed_tables);\n            }\n        }\n\n        // mmcs_index_sum\n        if inputs[4].is_empty() {\n            preprocessed_tables[idx].push(F::ZERO);\n        } else {\n            preprocessed_tables[idx].push(F::ONE);\n            // In this case, we are reading the MMCS index sum from the witness table,\n            // so we need to update the associated witness table multiplicities.\n            update_witness_table(\u0026inputs[4], preprocessed_tables);\n        }\n\n        // We need to insert `new_start` and `merkle_path` as well.\n        preprocessed_tables[idx].push(if self.new_start { F::ONE } else { F::ZERO });\n        preprocessed_tables[idx].push(if self.merkle_path { F::ONE } else { F::ZERO });\n    }\n\n    fn boxed(\u0026self) -\u003e Box\u003cdyn NonPrimitiveExecutor\u003cF\u003e\u003e {\n        Box::new(self.clone())\n    }\n}\n\nimpl Poseidon2PermExecutor {\n    /// Resolve input limb value using a layered priority system:\n    /// 1. Layer 1: Private inputs (lowest priority) - sibling placed based on mmcs_bit\n    /// 2. Layer 2: Chaining from previous permutation (if new_start=false)\n    /// 3. Layer 3: CTL (witness) values (highest priority, overwrites previous layers)\n    fn resolve_input_limb\u003cF: Field\u003e(\n        \u0026self,\n        limb: usize,\n        inputs: \u0026[Vec\u003cWitnessId\u003e],\n        private_inputs: Option\u003c\u0026[F]\u003e,\n        ctx: \u0026ExecutionContext\u003c'_, F\u003e,\n        mmcs_bit: bool,\n    ) -\u003e Result\u003cF, CircuitError\u003e {\n        // Build up the input array with layered priorities\n        let mut resolved = [None; 4];\n\n        // Layer 1: Private inputs (lowest priority)\n        // Private inputs are only used in Merkle mode (merkle_path \u0026\u0026 !new_start).\n        // The sibling (exactly 2 limbs) is placed based on mmcs_bit:\n        // - mmcs_bit=0: sibling in 2-3\n        // - mmcs_bit=1: sibling in 0-1\n        if let Some(private) = private_inputs {\n            // Note: validation ensures private_inputs is only provided for Merkle mode\n            debug_assert!(self.merkle_path \u0026\u0026 !self.new_start);\n            let start = if mmcs_bit { 0 } else { 2 };\n            resolved[start] = Some(private[0]);\n            resolved[start + 1] = Some(private[1]);\n        }\n\n        // Layer 2: Chaining from previous permutation (medium priority)\n        if !self.new_start {\n            let prev = ctx.last_poseidon2().ok_or_else(|| {\n                CircuitError::Poseidon2ChainMissingPreviousState {\n                    operation_index: ctx.operation_id(),\n                }\n            })?;\n\n            if !self.merkle_path {\n                // Normal chaining: all 4 limbs come from previous output\n                for i in 0..4 {\n                    resolved[i] = Some(prev[i]);\n                }\n            } else {\n                // Merkle path chaining:\n                // Previous digest (prev[0..1]) is placed based on mmcs_bit:\n                // - mmcs_bit=0: chain into input limbs 0-1\n                // - mmcs_bit=1: chain into input limbs 2-3\n                if mmcs_bit {\n                    resolved[2] = Some(prev[0]);\n                    resolved[3] = Some(prev[1]);\n                } else {\n                    resolved[0] = Some(prev[0]);\n                    resolved[1] = Some(prev[1]);\n                }\n            }\n        }\n\n        // Layer 3: CTL (witness) values (highest priority)\n        for i in 0..4 {\n            if inputs.len() \u003e i \u0026\u0026 inputs[i].len() == 1 {\n                let wid = inputs[i][0];\n                let val = ctx.get_witness(wid)?;\n                resolved[i] = Some(val);\n            }\n        }\n\n        // Return the resolved value\n        resolved[limb].ok_or_else(|| {\n            if self.merkle_path \u0026\u0026 !self.new_start {\n                let is_required_sibling =\n                    matches!((mmcs_bit, limb), (false, 2 | 3) | (true, 0 | 1));\n                if is_required_sibling {\n                    return CircuitError::Poseidon2MerkleMissingSiblingInput {\n                        operation_index: ctx.operation_id(),\n                        limb,\n                    };\n                }\n            }\n            CircuitError::Poseidon2MissingInput {\n                operation_index: ctx.operation_id(),\n                limb,\n            }\n        })\n    }\n}\n","traces":[{"line":59,"address":[4057520],"length":1,"stats":{"Line":0}},{"line":64,"address":[3941347],"length":1,"stats":{"Line":0}},{"line":65,"address":[5323187],"length":1,"stats":{"Line":0}},{"line":91,"address":[6991406,6991148,6988912],"length":1,"stats":{"Line":1}},{"line":95,"address":[6988959],"length":1,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":1}},{"line":97,"address":[6989134,6989164],"length":1,"stats":{"Line":1}},{"line":98,"address":[6989183],"length":1,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[6989312],"length":1,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[6989421,6989272],"length":1,"stats":{"Line":2}},{"line":108,"address":[6991180,6989570],"length":1,"stats":{"Line":2}},{"line":109,"address":[6991245,6991202],"length":1,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[6989597],"length":1,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[6989919,6990121],"length":1,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[6990817,6990749],"length":1,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[6990574,6990483,6990432,6990361],"length":1,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[6990539],"length":1,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[6990739],"length":1,"stats":{"Line":1}},{"line":139,"address":[6990744],"length":1,"stats":{"Line":1}},{"line":143,"address":[6990957,6990881],"length":1,"stats":{"Line":2}},{"line":157,"address":[2683952],"length":1,"stats":{"Line":1}},{"line":167,"address":[6579167,6577552,6582434,6582440,6579173,6580720],"length":1,"stats":{"Line":0}},{"line":175,"address":[3010647],"length":1,"stats":{"Line":0}},{"line":176,"address":[6577750,6580927],"length":1,"stats":{"Line":0}},{"line":177,"address":[2303996],"length":1,"stats":{"Line":0}},{"line":178,"address":[3010693],"length":1,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[7518318,7511278,7514686,7521714,7524882],"length":1,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[3011064,3010841],"length":1,"stats":{"Line":0}},{"line":192,"address":[6581339,6578156],"length":1,"stats":{"Line":0}},{"line":193,"address":[7514901,7511493,7525091,7521923,7518533],"length":1,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[2362885],"length":1,"stats":{"Line":0}},{"line":202,"address":[7518549,7511509,7521939,7525107,7514917],"length":1,"stats":{"Line":0}},{"line":203,"address":[2824762,2827456],"length":1,"stats":{"Line":0}},{"line":204,"address":[1548969],"length":1,"stats":{"Line":0}},{"line":209,"address":[3669335,3671579,3672486,3668393,3668303,3671489],"length":1,"stats":{"Line":0}},{"line":210,"address":[3011422,3011468,3011576],"length":1,"stats":{"Line":0}},{"line":211,"address":[3011505,3011594],"length":1,"stats":{"Line":0}},{"line":212,"address":[3011717,3011944,3011837],"length":1,"stats":{"Line":0}},{"line":213,"address":[6578754,6582021],"length":1,"stats":{"Line":0}},{"line":214,"address":[4132332],"length":1,"stats":{"Line":0}},{"line":215,"address":[2825456],"length":1,"stats":{"Line":0}},{"line":217,"address":[6582297,6579030],"length":1,"stats":{"Line":0}},{"line":218,"address":[7512154,7515686,7522503,7519194,7525671],"length":1,"stats":{"Line":0}},{"line":219,"address":[2363451],"length":1,"stats":{"Line":0}},{"line":220,"address":[1547041],"length":1,"stats":{"Line":0}},{"line":221,"address":[2363577,2363497],"length":1,"stats":{"Line":0}},{"line":224,"address":[4132067],"length":1,"stats":{"Line":0}},{"line":225,"address":[6583986,6580580],"length":1,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[1547589],"length":1,"stats":{"Line":0}},{"line":228,"address":[2363898],"length":1,"stats":{"Line":0}},{"line":229,"address":[6579397,6582545],"length":1,"stats":{"Line":0}},{"line":232,"address":[2305582],"length":1,"stats":{"Line":0}},{"line":236,"address":[2305573],"length":1,"stats":{"Line":0}},{"line":237,"address":[1547664,1547446,1548759],"length":1,"stats":{"Line":0}},{"line":238,"address":[6579567,6582889,6580439,6583806],"length":1,"stats":{"Line":0}},{"line":242,"address":[4133283],"length":1,"stats":{"Line":0}},{"line":245,"address":[2306142],"length":1,"stats":{"Line":0}},{"line":248,"address":[6579850,6579760,6583175,6583085],"length":1,"stats":{"Line":0}},{"line":249,"address":[2306397],"length":1,"stats":{"Line":0}},{"line":250,"address":[3013122],"length":1,"stats":{"Line":0}},{"line":251,"address":[2364794,2364743],"length":1,"stats":{"Line":0}},{"line":252,"address":[2826695],"length":1,"stats":{"Line":0}},{"line":253,"address":[2365108],"length":1,"stats":{"Line":0}},{"line":254,"address":[2306724],"length":1,"stats":{"Line":0}},{"line":255,"address":[2365005],"length":1,"stats":{"Line":0}},{"line":256,"address":[3670296,3673663],"length":1,"stats":{"Line":0}},{"line":261,"address":[2364690],"length":1,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[3013976],"length":1,"stats":{"Line":0}},{"line":268,"address":[2303824],"length":1,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[6572368,6574768],"length":1,"stats":{"Line":0}},{"line":278,"address":[3007733,3007820],"length":1,"stats":{"Line":0}},{"line":279,"address":[2361632,2359348],"length":1,"stats":{"Line":0}},{"line":280,"address":[3667105,3667090,3666718,3666703],"length":1,"stats":{"Line":0}},{"line":281,"address":[7509006,7509854,7508596,7510244,7509402],"length":1,"stats":{"Line":0}},{"line":282,"address":[6576802,6577212],"length":1,"stats":{"Line":0}},{"line":283,"address":[2361953],"length":1,"stats":{"Line":0}},{"line":285,"address":[6576861,6577271],"length":1,"stats":{"Line":0}},{"line":290,"address":[2301089],"length":1,"stats":{"Line":0}},{"line":291,"address":[1543627],"length":1,"stats":{"Line":0}},{"line":292,"address":[2821482],"length":1,"stats":{"Line":0}},{"line":303,"address":[3007843,3008003],"length":1,"stats":{"Line":0}},{"line":304,"address":[2821625],"length":1,"stats":{"Line":0}},{"line":306,"address":[6576269,6574188],"length":1,"stats":{"Line":0}},{"line":307,"address":[2361120],"length":1,"stats":{"Line":0}},{"line":310,"address":[3009235],"length":1,"stats":{"Line":0}},{"line":311,"address":[2302628],"length":1,"stats":{"Line":0}},{"line":315,"address":[2822904],"length":1,"stats":{"Line":0}},{"line":317,"address":[7506178,7498552,7498525,7500834,7503552,7506132,7508168,7503628,7508141,7500788],"length":1,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[4130509],"length":1,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[3009869,3009823],"length":1,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[2303249],"length":1,"stats":{"Line":0}},{"line":330,"address":[6576497,6574559],"length":1,"stats":{"Line":0}},{"line":332,"address":[1545297],"length":1,"stats":{"Line":0}},{"line":335,"address":[7497445,7504720,7497504,7507061,7501776,7507120,7499317,7504661,7499376,7501717],"length":1,"stats":{"Line":0}},{"line":336,"address":[3664857,3662986],"length":1,"stats":{"Line":0}},{"line":338,"address":[6573814,6576017],"length":1,"stats":{"Line":0}},{"line":339,"address":[1544754],"length":1,"stats":{"Line":0}},{"line":342,"address":[2822381],"length":1,"stats":{"Line":0}},{"line":343,"address":[2302254],"length":1,"stats":{"Line":0}},{"line":347,"address":[7502808,7498125,7500194,7505538,7507741],"length":1,"stats":{"Line":0}},{"line":352,"address":[4129489],"length":1,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[3664938,3663067],"length":1,"stats":{"Line":0}},{"line":358,"address":[7497744,7502032,7499598,7499688,7502152,7504942,7507360,7497693,7505032,7507309],"length":1,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[2822252],"length":1,"stats":{"Line":0}},{"line":366,"address":[7510656,7510512,7510608,7510560,7510704],"length":1,"stats":{"Line":0}},{"line":367,"address":[2823989],"length":1,"stats":{"Line":0}},{"line":376,"address":[4117936,4117943],"length":1,"stats":{"Line":0}},{"line":385,"address":[6524978],"length":1,"stats":{"Line":0}},{"line":392,"address":[2805924,2806520],"length":1,"stats":{"Line":0}},{"line":394,"address":[2806002,2806029],"length":1,"stats":{"Line":0}},{"line":395,"address":[6527814,6525216],"length":1,"stats":{"Line":0}},{"line":396,"address":[2285577,2285773],"length":1,"stats":{"Line":0}},{"line":397,"address":[2355940,2356146,2355900],"length":1,"stats":{"Line":0}},{"line":401,"address":[2355631],"length":1,"stats":{"Line":0}},{"line":402,"address":[1537088,1535670,1535829],"length":1,"stats":{"Line":0}},{"line":403,"address":[1537137],"length":1,"stats":{"Line":0}},{"line":404,"address":[7487600,7487664,7487536,7487728,7488032],"length":1,"stats":{"Line":0}},{"line":408,"address":[2806761],"length":1,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[4119104,4119159,4118858],"length":1,"stats":{"Line":0}},{"line":419,"address":[3659582,3657269],"length":1,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[2807095],"length":1,"stats":{"Line":0}},{"line":423,"address":[4119079],"length":1,"stats":{"Line":0}},{"line":429,"address":[2356246,2357218],"length":1,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[2997080,2996955],"length":1,"stats":{"Line":0}},{"line":432,"address":[1536698,1536612],"length":1,"stats":{"Line":0}},{"line":433,"address":[2997186,2997298],"length":1,"stats":{"Line":0}},{"line":438,"address":[2997328,2996691],"length":1,"stats":{"Line":0}},{"line":439,"address":[1536867,1536932],"length":1,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[2287953],"length":1,"stats":{"Line":0}},{"line":442,"address":[7488222,7488462,7488702,7488942,7487918],"length":1,"stats":{"Line":0}},{"line":443,"address":[7487962,7488266,7488746,7488986,7488506],"length":1,"stats":{"Line":0}},{"line":444,"address":[3660974,3660734],"length":1,"stats":{"Line":0}},{"line":445,"address":[2808579],"length":1,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[4119809],"length":1,"stats":{"Line":0}},{"line":451,"address":[2997382],"length":1,"stats":{"Line":0}}],"covered":24,"coverable":170},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","policy.rs"],"content":"use hashbrown::HashSet;\n\nuse crate::op::NonPrimitiveOpType;\n\n/// Policy trait to gate non-primitive ops availability.\npub trait NonPrimPolicy {\n    fn is_allowed(\u0026self, op: NonPrimitiveOpType) -\u003e bool;\n}\n\n/// Default profile: non-primitive ops are not supported.\npub struct DefaultProfile;\n\nimpl NonPrimPolicy for DefaultProfile {\n    #[inline]\n    fn is_allowed(\u0026self, _op: NonPrimitiveOpType) -\u003e bool {\n        false\n    }\n}\n\n/// Allow all non-primitive ops.\npub struct AllowAllProfile;\n\nimpl NonPrimPolicy for AllowAllProfile {\n    #[inline]\n    fn is_allowed(\u0026self, _op: NonPrimitiveOpType) -\u003e bool {\n        true\n    }\n}\n\n/// Runtime policy defining the list of allowed non-primitive ops.\npub struct RuntimeAllowlist {\n    allowed: HashSet\u003cNonPrimitiveOpType\u003e,\n}\n\nimpl RuntimeAllowlist {\n    pub fn from_slice(ops: \u0026[NonPrimitiveOpType]) -\u003e Self {\n        Self {\n            allowed: ops.iter().cloned().collect(),\n        }\n    }\n\n    pub fn insert(\u0026mut self, op: NonPrimitiveOpType) {\n        self.allowed.insert(op);\n    }\n}\n\nimpl NonPrimPolicy for RuntimeAllowlist {\n    #[inline]\n    fn is_allowed(\u0026self, op: NonPrimitiveOpType) -\u003e bool {\n        self.allowed.contains(\u0026op)\n    }\n}\n","traces":[{"line":15,"address":[8111360],"length":1,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[5297264],"length":1,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[5279760],"length":1,"stats":{"Line":0}},{"line":38,"address":[4014192],"length":1,"stats":{"Line":0}},{"line":42,"address":[3892656],"length":1,"stats":{"Line":0}},{"line":43,"address":[3149721],"length":1,"stats":{"Line":0}},{"line":49,"address":[8111392],"length":1,"stats":{"Line":0}},{"line":50,"address":[11017673],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","add.rs"],"content":"use alloc::vec::Vec;\n\nuse p3_field::Field;\n\nuse crate::CircuitError;\nuse crate::op::Op;\nuse crate::types::WitnessId;\n\n/// Addition operation table.\n///\n/// Records every addition operation in the circuit.\n/// Each row represents one constraint: lhs + rhs = result.\n#[derive(Debug, Clone)]\npub struct AddTrace\u003cF\u003e {\n    /// Left operand values\n    pub lhs_values: Vec\u003cF\u003e,\n    /// Left operand indices (references witness bus)\n    pub lhs_index: Vec\u003cWitnessId\u003e,\n    /// Right operand values\n    pub rhs_values: Vec\u003cF\u003e,\n    /// Right operand indices (references witness bus)\n    pub rhs_index: Vec\u003cWitnessId\u003e,\n    /// Result values\n    pub result_values: Vec\u003cF\u003e,\n    /// Result indices (references witness bus)\n    pub result_index: Vec\u003cWitnessId\u003e,\n}\n\n/// Builder for generating addition traces.\npub struct AddTraceBuilder\u003c'a, F\u003e {\n    primitive_ops: \u0026'a [Op\u003cF\u003e],\n    witness: \u0026'a [Option\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone + Field\u003e AddTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new addition trace builder.\n    pub const fn new(primitive_ops: \u0026'a [Op\u003cF\u003e], witness: \u0026'a [Option\u003cF\u003e]) -\u003e Self {\n        Self {\n            primitive_ops,\n            witness,\n        }\n    }\n\n    /// Builds the addition trace from circuit operations.\n    pub fn build(self) -\u003e Result\u003cAddTrace\u003cF\u003e, CircuitError\u003e {\n        let mut lhs_values = Vec::new();\n        let mut lhs_index = Vec::new();\n        let mut rhs_values = Vec::new();\n        let mut rhs_index = Vec::new();\n        let mut result_values = Vec::new();\n        let mut result_index = Vec::new();\n\n        for prim in self.primitive_ops {\n            // Addition: a + b = out\n            if let Op::Add { a, b, out } = prim {\n                let a_val = self.resolve(a)?;\n                let b_val = self.resolve(b)?;\n                let out_val = self.resolve(out)?;\n\n                lhs_values.push(a_val);\n                lhs_index.push(*a);\n                rhs_values.push(b_val);\n                rhs_index.push(*b);\n                result_values.push(out_val);\n                result_index.push(*out);\n            }\n        }\n\n        // If trace is empty, add a dummy row: 0 + 0 = 0\n        if lhs_values.is_empty() {\n            lhs_values.push(F::ZERO);\n            lhs_index.push(WitnessId(0));\n            rhs_values.push(F::ZERO);\n            rhs_index.push(WitnessId(0));\n            result_values.push(F::ZERO);\n            result_index.push(WitnessId(0));\n        }\n\n        Ok(AddTrace {\n            lhs_values,\n            lhs_index,\n            rhs_values,\n            rhs_index,\n            result_values,\n            result_index,\n        })\n    }\n\n    /// Resolves a single witness value safely.\n    #[inline]\n    fn resolve(\u0026self, id: \u0026WitnessId) -\u003e Result\u003cF, CircuitError\u003e {\n        self.witness\n            .get(id.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .cloned()\n            .ok_or(CircuitError::WitnessNotSet { witness_id: *id })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_addition() {\n        // Create a simple witness containing three values\n        //\n        // Index 0: value 5 (left operand)\n        // Index 1: value 3 (right operand)\n        // Index 2: value 8 (result of 5 + 3)\n        let lhs = F::from_u64(5);\n        let rhs = F::from_u64(3);\n        let out = F::from_u64(8);\n        let witness = vec![\n            Some(lhs), // WitnessId(0)\n            Some(rhs), // WitnessId(1)\n            Some(out), // WitnessId(2)\n        ];\n\n        // Define a single addition operation: witness[0] + witness[1] = witness[2]\n        //\n        // This represents the constraint: 5 + 3 = 8\n        let ops = vec![Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(2),\n        }];\n\n        // Build the trace using the builder pattern\n        let builder = AddTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace contains exactly one row\n        assert_eq!(\n            trace.lhs_values.len(),\n            1,\n            \"Should have one addition operation\"\n        );\n\n        // Verify left operand (lhs) is correctly recorded\n        assert_eq!(trace.lhs_values[0], lhs);\n        assert_eq!(trace.lhs_index[0], WitnessId(0));\n\n        // Verify right operand (rhs) is correctly recorded\n        assert_eq!(trace.rhs_values[0], rhs);\n        assert_eq!(trace.rhs_index[0], WitnessId(1));\n\n        // Verify result is correctly recorded\n        assert_eq!(trace.result_values[0], out);\n        assert_eq!(trace.result_index[0], WitnessId(2));\n    }\n\n    #[test]\n    fn test_multiple_additions() {\n        // Create witness with values for three separate additions\n        //\n        // We have 9 witness slots total (3 additions × 3 values each)\n        let lhs1 = F::from_u64(10);\n        let rhs1 = F::from_u64(20);\n        let out1 = F::from_u64(30);\n\n        let lhs2 = F::from_u64(7);\n        let rhs2 = F::from_u64(13);\n        let out2 = F::from_u64(20);\n\n        let lhs3 = F::from_u64(1);\n        let rhs3 = F::from_u64(1);\n        let out3 = F::from_u64(2);\n\n        let witness = vec![\n            Some(lhs1), // First addition: lhs\n            Some(rhs1), // First addition: rhs\n            Some(out1), // First addition: result\n            Some(lhs2), // Second addition: lhs\n            Some(rhs2), // Second addition: rhs\n            Some(out2), // Second addition: result\n            Some(lhs3), // Third addition: lhs\n            Some(rhs3), // Third addition: rhs\n            Some(out3), // Third addition: result\n        ];\n\n        // Define three addition operations\n        let lhs1_witness_id = WitnessId(0);\n        let rhs1_witness_id = WitnessId(1);\n        let out1_witness_id = WitnessId(2);\n        let lhs2_witness_id = WitnessId(3);\n        let rhs2_witness_id = WitnessId(4);\n        let out2_witness_id = WitnessId(5);\n        let lhs3_witness_id = WitnessId(6);\n        let rhs3_witness_id = WitnessId(7);\n        let out3_witness_id = WitnessId(8);\n        let ops = vec![\n            Op::Add {\n                a: lhs1_witness_id,\n                b: rhs1_witness_id,\n                out: out1_witness_id,\n            },\n            Op::Add {\n                a: lhs2_witness_id,\n                b: rhs2_witness_id,\n                out: out2_witness_id,\n            },\n            Op::Add {\n                a: lhs3_witness_id,\n                b: rhs3_witness_id,\n                out: out3_witness_id,\n            },\n        ];\n\n        // Build the trace\n        let builder = AddTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify we have exactly three rows\n        assert_eq!(\n            trace.lhs_values.len(),\n            3,\n            \"Should have three addition operations\"\n        );\n\n        // Verify first addition\n        assert_eq!(trace.lhs_values[0], lhs1);\n        assert_eq!(trace.lhs_index[0], lhs1_witness_id);\n        assert_eq!(trace.rhs_values[0], rhs1);\n        assert_eq!(trace.rhs_index[0], rhs1_witness_id);\n        assert_eq!(trace.result_values[0], out1);\n        assert_eq!(trace.result_index[0], out1_witness_id);\n\n        // Verify second addition\n        assert_eq!(trace.lhs_values[1], lhs2);\n        assert_eq!(trace.lhs_index[1], lhs2_witness_id);\n        assert_eq!(trace.rhs_values[1], rhs2);\n        assert_eq!(trace.rhs_index[1], rhs2_witness_id);\n        assert_eq!(trace.result_values[1], out2);\n        assert_eq!(trace.result_index[1], out2_witness_id);\n\n        // Verify third addition\n        assert_eq!(trace.lhs_values[2], lhs3);\n        assert_eq!(trace.lhs_index[2], lhs3_witness_id);\n        assert_eq!(trace.rhs_values[2], rhs3);\n        assert_eq!(trace.rhs_index[2], rhs3_witness_id);\n        assert_eq!(trace.result_values[2], out3);\n        assert_eq!(trace.result_index[2], out3_witness_id);\n    }\n\n    #[test]\n    fn test_empty_operations_creates_dummy_row() {\n        // Create a witness with at least one entry (for the dummy row to reference)\n        let witness = vec![Some(F::ZERO)];\n\n        // Provide an empty operations list (no additions to process)\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![];\n\n        // Build the trace\n        let builder = AddTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify exactly one dummy row exists\n        assert_eq!(trace.lhs_values.len(), 1, \"Should have one dummy row\");\n\n        // Verify the dummy row contains: 0 + 0 = 0\n        assert_eq!(trace.lhs_values[0], F::ZERO);\n        assert_eq!(trace.lhs_index[0], WitnessId(0));\n        assert_eq!(trace.rhs_values[0], F::ZERO);\n        assert_eq!(trace.rhs_index[0], WitnessId(0));\n        assert_eq!(trace.result_values[0], F::ZERO);\n        assert_eq!(trace.result_index[0], WitnessId(0));\n    }\n\n    #[test]\n    fn test_mixed_operations_filters_correctly() {\n        // Create witness for one addition and one multiplication\n        let lhs = F::from_u64(4);\n        let rhs = F::from_u64(6);\n        let add_out = F::from_u64(10);\n        let mul_out = F::from_u64(24);\n\n        let witness = vec![\n            Some(lhs),     // WitnessId(0)\n            Some(rhs),     // WitnessId(1)\n            Some(add_out), // WitnessId(2)\n            Some(mul_out), // WitnessId(3) for Mul\n        ];\n\n        // Create a mixed list of operations\n        // Only the Add operation should be processed; Mul should be ignored\n        let ops = vec![\n            Op::Mul {\n                a: WitnessId(0),\n                b: WitnessId(1),\n                out: WitnessId(3),\n            }, // Should be ignored\n            Op::Add {\n                a: WitnessId(0),\n                b: WitnessId(1),\n                out: WitnessId(2),\n            }, // Should be processed\n            Op::Mul {\n                a: WitnessId(1),\n                b: WitnessId(2),\n                out: WitnessId(3),\n            }, // Should be ignored\n        ];\n\n        // Build the trace\n        let builder = AddTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify only one row exists (only one Add operation)\n        assert_eq!(\n            trace.lhs_values.len(),\n            1,\n            \"Should process only the Add operation\"\n        );\n\n        // Verify the single addition row is correct (4 + 6 = 10)\n        assert_eq!(trace.lhs_values[0], lhs);\n        assert_eq!(trace.rhs_values[0], rhs);\n        assert_eq!(trace.result_values[0], add_out);\n    }\n\n    #[test]\n    fn test_missing_witness_lhs_returns_error() {\n        // Create witness where the left operand (index 0) is missing\n        let rhs = F::from_u64(5);\n        let out = F::from_u64(5);\n\n        let witness = vec![\n            None,      // WitnessId(0) - NOT SET\n            Some(rhs), // WitnessId(1)\n            Some(out), // WitnessId(2)\n        ];\n\n        // Define an addition that references the missing witness\n        let ops = vec![Op::Add {\n            a: WitnessId(0), // References the None value\n            b: WitnessId(1),\n            out: WitnessId(2),\n        }];\n\n        // Attempt to build the trace\n        let builder = AddTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify the operation fails with the correct error\n        assert!(result.is_err(), \"Should fail when lhs witness is not set\");\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(\n                    witness_id,\n                    WitnessId(0),\n                    \"Error should reference WitnessId(0)\"\n                );\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n\n    #[test]\n    fn test_missing_witness_rhs_returns_error() {\n        // Create witness where the right operand (index 1) is missing\n        let lhs = F::from_u64(5);\n        let out = F::from_u64(5);\n\n        let witness = vec![\n            Some(lhs), // WitnessId(0)\n            None,      // WitnessId(1) - NOT SET\n            Some(out), // WitnessId(2)\n        ];\n\n        // Define an addition that references the missing witness\n        let ops = vec![Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(1), // References the None value\n            out: WitnessId(2),\n        }];\n\n        // Attempt to build the trace\n        let builder = AddTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify the operation fails with the correct error\n        assert!(result.is_err(), \"Should fail when rhs witness is not set\");\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(\n                    witness_id,\n                    WitnessId(1),\n                    \"Error should reference WitnessId(1)\"\n                );\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n\n    #[test]\n    fn test_missing_witness_result_returns_error() {\n        // Create witness where the result (index 2) is missing\n        let lhs = F::from_u64(5);\n        let rhs = F::from_u64(3);\n\n        let witness = vec![\n            Some(lhs), // WitnessId(0)\n            Some(rhs), // WitnessId(1)\n            None,      // WitnessId(2) - NOT SET\n        ];\n\n        // Define an addition that references the missing result\n        let ops = vec![Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(2), // References the None value\n        }];\n\n        // Attempt to build the trace\n        let builder = AddTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify the operation fails with the correct error\n        assert!(\n            result.is_err(),\n            \"Should fail when result witness is not set\"\n        );\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(\n                    witness_id,\n                    WitnessId(2),\n                    \"Error should reference WitnessId(2)\"\n                );\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n\n    #[test]\n    fn test_out_of_bounds_witness_id() {\n        // Create a small witness array with only 2 elements\n        let lhs = F::from_u64(5);\n        let rhs = F::from_u64(3);\n\n        let witness = vec![Some(lhs), Some(rhs)];\n\n        // Attempt to reference WitnessId(5), which doesn't exist\n        let ops = vec![Op::Add {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(5), // Out of bounds!\n        }];\n\n        // Attempt to build the trace\n        let builder = AddTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify proper error handling\n        assert!(\n            result.is_err(),\n            \"Should fail when witness ID is out of bounds\"\n        );\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(\n                    witness_id,\n                    WitnessId(5),\n                    \"Error should reference WitnessId(5)\"\n                );\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n}\n","traces":[{"line":37,"address":[8836320,8836368,8836224,8836176,8836272],"length":1,"stats":{"Line":17}},{"line":45,"address":[3322292,3320048,3320080,3317888],"length":1,"stats":{"Line":15}},{"line":46,"address":[3131083],"length":1,"stats":{"Line":17}},{"line":47,"address":[3131093],"length":1,"stats":{"Line":15}},{"line":48,"address":[2112953],"length":1,"stats":{"Line":17}},{"line":49,"address":[3320222,3318048],"length":1,"stats":{"Line":15}},{"line":50,"address":[],"length":0,"stats":{"Line":17}},{"line":51,"address":[3510356],"length":1,"stats":{"Line":15}},{"line":53,"address":[2113238,2113163],"length":1,"stats":{"Line":32}},{"line":55,"address":[6881343,6883569,6882193,6884374],"length":1,"stats":{"Line":32}},{"line":56,"address":[3123330,3122589],"length":1,"stats":{"Line":17}},{"line":57,"address":[2114438,2114992],"length":1,"stats":{"Line":18}},{"line":58,"address":[8838523,8844985,8842767,8847161,8840471,8838175,8843115,8845279,8840883,8847455],"length":1,"stats":{"Line":17}},{"line":60,"address":[3132982],"length":1,"stats":{"Line":17}},{"line":61,"address":[3123166],"length":1,"stats":{"Line":16}},{"line":62,"address":[3512048],"length":1,"stats":{"Line":17}},{"line":63,"address":[3133080],"length":1,"stats":{"Line":16}},{"line":64,"address":[2096697],"length":1,"stats":{"Line":17}},{"line":65,"address":[],"length":0,"stats":{"Line":15}},{"line":70,"address":[2095192],"length":1,"stats":{"Line":15}},{"line":71,"address":[2114014],"length":1,"stats":{"Line":2}},{"line":72,"address":[6882056,6884271],"length":1,"stats":{"Line":2}},{"line":73,"address":[3511304],"length":1,"stats":{"Line":2}},{"line":74,"address":[3511321],"length":1,"stats":{"Line":2}},{"line":75,"address":[3132302],"length":1,"stats":{"Line":2}},{"line":76,"address":[1846571],"length":1,"stats":{"Line":2}},{"line":79,"address":[8837255,8841847,8844111,8839495,8846287],"length":1,"stats":{"Line":16}},{"line":80,"address":[2095222],"length":1,"stats":{"Line":16}},{"line":81,"address":[],"length":0,"stats":{"Line":18}},{"line":82,"address":[8837063,8846095,8839303,8843919,8841655],"length":1,"stats":{"Line":16}},{"line":83,"address":[2095351],"length":1,"stats":{"Line":18}},{"line":84,"address":[3318667,3320823],"length":1,"stats":{"Line":16}},{"line":85,"address":[3131847],"length":1,"stats":{"Line":18}},{"line":91,"address":[3133296],"length":1,"stats":{"Line":15}},{"line":92,"address":[3123468],"length":1,"stats":{"Line":16}},{"line":93,"address":[3123476],"length":1,"stats":{"Line":15}},{"line":94,"address":[3123577,3123568,3123488],"length":1,"stats":{"Line":50}},{"line":96,"address":[8848170,8847787,8848043,8847921,8847674],"length":1,"stats":{"Line":16}}],"covered":38,"coverable":38},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","constant.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::CircuitError;\nuse crate::op::Op;\nuse crate::types::WitnessId;\n\n/// Constant values table.\n///\n/// Stores all compile-time known constant values used in the circuit.\n/// Each constant binds to a specific witness ID.\n/// Both prover and verifier know these values in advance.\n#[derive(Debug, Clone)]\npub struct ConstTrace\u003cF\u003e {\n    /// Witness IDs that each constant binds to.\n    ///\n    /// Maps each constant to its location in the witness table.\n    pub index: Vec\u003cWitnessId\u003e,\n    /// Constant field element values.\n    pub values: Vec\u003cF\u003e,\n}\n\n/// Builder for generating constant traces.\npub struct ConstTraceBuilder\u003c'a, F\u003e {\n    primitive_ops: \u0026'a [Op\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone\u003e ConstTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new constant trace builder.\n    pub const fn new(primitive_ops: \u0026'a [Op\u003cF\u003e]) -\u003e Self {\n        Self { primitive_ops }\n    }\n\n    /// Builds the constant trace from circuit operations.\n    pub fn build(self) -\u003e Result\u003cConstTrace\u003cF\u003e, CircuitError\u003e {\n        let mut index = Vec::new();\n        let mut values = Vec::new();\n\n        for prim in self.primitive_ops {\n            if let Op::Const { out, val } = prim {\n                index.push(*out);\n                values.push(val.clone());\n            }\n        }\n\n        Ok(ConstTrace { index, values })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_constant() {\n        // Create a single constant operation that loads a value into witness\n        let val = F::from_u64(42);\n        let out = WitnessId(0);\n\n        let ops = vec![Op::Const { out, val }];\n\n        // Build the trace using the builder pattern\n        let builder = ConstTraceBuilder::new(\u0026ops);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace contains exactly one constant\n        assert_eq!(trace.index.len(), 1, \"Should have one constant operation\");\n        assert_eq!(trace.values.len(), 1, \"Should have one constant value\");\n\n        // Verify the constant is correctly recorded\n        assert_eq!(trace.index[0], out);\n        assert_eq!(trace.values[0], val);\n    }\n\n    #[test]\n    fn test_multiple_constants() {\n        // Create multiple constant operations with different values\n        let val1 = F::from_u64(10);\n        let out1 = WitnessId(0);\n\n        let val2 = F::from_u64(20);\n        let out2 = WitnessId(1);\n\n        let val3 = F::from_u64(30);\n        let out3 = WitnessId(2);\n\n        let ops = vec![\n            Op::Const {\n                out: out1,\n                val: val1,\n            },\n            Op::Const {\n                out: out2,\n                val: val2,\n            },\n            Op::Const {\n                out: out3,\n                val: val3,\n            },\n        ];\n\n        // Build the trace\n        let builder = ConstTraceBuilder::new(\u0026ops);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify we have exactly three constants\n        assert_eq!(\n            trace.index.len(),\n            3,\n            \"Should have three constant operations\"\n        );\n        assert_eq!(trace.values.len(), 3, \"Should have three constant values\");\n\n        // Verify first constant\n        assert_eq!(trace.index[0], out1);\n        assert_eq!(trace.values[0], val1);\n\n        // Verify second constant\n        assert_eq!(trace.index[1], out2);\n        assert_eq!(trace.values[1], val2);\n\n        // Verify third constant\n        assert_eq!(trace.index[2], out3);\n        assert_eq!(trace.values[2], val3);\n    }\n\n    #[test]\n    fn test_empty_operations() {\n        // Provide an empty operations list\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![];\n\n        // Build the trace\n        let builder = ConstTraceBuilder::new(\u0026ops);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace is empty\n        assert_eq!(trace.index.len(), 0, \"Should have no constants\");\n        assert_eq!(trace.values.len(), 0, \"Should have no values\");\n    }\n}\n","traces":[{"line":29,"address":[4023712],"length":1,"stats":{"Line":15}},{"line":34,"address":[1895552,1896220,1896214],"length":1,"stats":{"Line":17}},{"line":35,"address":[3078272],"length":1,"stats":{"Line":15}},{"line":36,"address":[3078282],"length":1,"stats":{"Line":18}},{"line":38,"address":[],"length":0,"stats":{"Line":34}},{"line":39,"address":[3138608,3138894],"length":1,"stats":{"Line":32}},{"line":40,"address":[2097680],"length":1,"stats":{"Line":15}},{"line":41,"address":[3138955],"length":1,"stats":{"Line":17}},{"line":45,"address":[1895899],"length":1,"stats":{"Line":15}}],"covered":9,"coverable":9},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","mod.rs"],"content":"//! Execution trace tables for zkVM circuit operations.\n\nuse alloc::boxed::Box;\nuse alloc::vec::Vec;\nuse core::any::Any;\nuse core::fmt;\n\nuse hashbrown::HashMap;\n\nuse crate::CircuitError;\nuse crate::circuit::Circuit;\nuse crate::op::NonPrimitiveOpPrivateData;\n\nmod add;\nmod constant;\nmod mul;\nmod poseidon2;\nmod public;\nmod runner;\nmod witness;\n\npub use add::AddTrace;\npub use constant::ConstTrace;\npub use mul::MulTrace;\npub use poseidon2::{\n    Poseidon2CircuitRow, Poseidon2CircuitTrace, Poseidon2Params, Poseidon2PermPrivateData,\n    Poseidon2Trace, generate_poseidon2_trace,\n};\npub use public::PublicTrace;\npub use runner::CircuitRunner;\npub use witness::WitnessTrace;\n\n/// Trait implemented by all non-primitive operation traces.\npub trait NonPrimitiveTrace\u003cF\u003e: Send + Sync {\n    /// Identifier of the non-primitive table.\n    fn id(\u0026self) -\u003e \u0026'static str;\n    /// Number of rows produced by this trace.\n    fn rows(\u0026self) -\u003e usize;\n    /// Type-erased access for downcasting.\n    fn as_any(\u0026self) -\u003e \u0026dyn Any;\n    /// Clone the trace into a boxed trait object.\n    fn boxed_clone(\u0026self) -\u003e Box\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e;\n}\n\n/// Function pointer for constructing a non-primitive trace from runner state.\npub type TraceGeneratorFn\u003cF\u003e = fn(\n    circuit: \u0026Circuit\u003cF\u003e,\n    witness: \u0026[Option\u003cF\u003e],\n    non_primitive_data: \u0026[Option\u003cNonPrimitiveOpPrivateData\u003cF\u003e\u003e],\n) -\u003e Result\u003cOption\u003cBox\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e\u003e, CircuitError\u003e;\n\n/// Execution traces for all tables.\n///\n/// This structure holds the complete execution trace of a circuit,\n/// containing all the data needed to generate proofs.\npub struct Traces\u003cF\u003e {\n    /// Central witness table (bus) storing all intermediate values.\n    pub witness_trace: WitnessTrace\u003cF\u003e,\n    /// Constant table for compile-time known values.\n    pub const_trace: ConstTrace\u003cF\u003e,\n    /// Public input table for externally provided values.\n    pub public_trace: PublicTrace\u003cF\u003e,\n    /// Addition operation table.\n    pub add_trace: AddTrace\u003cF\u003e,\n    /// Multiplication operation table.\n    pub mul_trace: MulTrace\u003cF\u003e,\n    /// Dynamically registered non-primitive traces indexed by their table identifier.\n    pub non_primitive_traces: HashMap\u003c\u0026'static str, Box\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e\u003e,\n}\n\nimpl\u003cF\u003e Traces\u003cF\u003e {\n    /// Fetch a non-primitive trace by identifier and downcast to a concrete type.\n    pub fn non_primitive_trace\u003cT\u003e(\u0026self, id: \u0026'static str) -\u003e Option\u003c\u0026T\u003e\n    where\n        T: NonPrimitiveTrace\u003cF\u003e + 'static,\n    {\n        self.non_primitive_traces\n            .get(id)\n            .and_then(|trace| trace.as_any().downcast_ref::\u003cT\u003e())\n    }\n}\n\nimpl\u003cF: Clone\u003e Clone for Traces\u003cF\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            witness_trace: self.witness_trace.clone(),\n            const_trace: self.const_trace.clone(),\n            public_trace: self.public_trace.clone(),\n            add_trace: self.add_trace.clone(),\n            mul_trace: self.mul_trace.clone(),\n            non_primitive_traces: self\n                .non_primitive_traces\n                .iter()\n                .map(|(\u0026id, trace)| (id, trace.boxed_clone()))\n                .collect(),\n        }\n    }\n}\n\nimpl\u003cF\u003e fmt::Debug for Traces\u003cF\u003e\nwhere\n    WitnessTrace\u003cF\u003e: fmt::Debug,\n    ConstTrace\u003cF\u003e: fmt::Debug,\n    PublicTrace\u003cF\u003e: fmt::Debug,\n    AddTrace\u003cF\u003e: fmt::Debug,\n    MulTrace\u003cF\u003e: fmt::Debug,\n{\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let extra_summary: Vec\u003c_\u003e = self\n            .non_primitive_traces\n            .iter()\n            .map(|(\u0026id, trace)| (id, trace.rows()))\n            .collect();\n        f.debug_struct(\"Traces\")\n            .field(\"witness_trace\", \u0026self.witness_trace)\n            .field(\"const_trace\", \u0026self.const_trace)\n            .field(\"public_trace\", \u0026self.public_trace)\n            .field(\"add_trace\", \u0026self.add_trace)\n            .field(\"mul_trace\", \u0026self.mul_trace)\n            .field(\"non_primitive_traces\", \u0026extra_summary)\n            .finish()\n    }\n}\n\nimpl\u003cF: alloc::fmt::Debug\u003e Traces\u003cF\u003e {\n    #[allow(clippy::missing_const_for_fn)]\n    pub fn dump_primitive_traces_log(\u0026self) {\n        #[cfg(debug_assertions)]\n        {\n            tracing::debug!(\"\\n=== WITNESS TRACE ===\");\n            for (i, (idx, val)) in self\n                .witness_trace\n                .index\n                .iter()\n                .zip(self.witness_trace.values.iter())\n                .enumerate()\n            {\n                tracing::debug!(\"Row {i}: WitnessId({idx}) = {val:?}\");\n            }\n\n            tracing::debug!(\"\\n=== CONST TRACE ===\");\n            for (i, (idx, val)) in self\n                .const_trace\n                .index\n                .iter()\n                .zip(self.const_trace.values.iter())\n                .enumerate()\n            {\n                tracing::debug!(\"Row {i}: WitnessId({idx}) = {val:?}\");\n            }\n\n            tracing::debug!(\"\\n=== PUBLIC TRACE ===\");\n            for (i, (idx, val)) in self\n                .public_trace\n                .index\n                .iter()\n                .zip(self.public_trace.values.iter())\n                .enumerate()\n            {\n                tracing::debug!(\"Row {i}: WitnessId({idx}) = {val:?}\");\n            }\n\n            tracing::debug!(\"\\n=== MUL TRACE ===\");\n            for i in 0..self.mul_trace.lhs_values.len() {\n                tracing::debug!(\n                    \"Row {}: WitnessId({}) * WitnessId({}) -\u003e WitnessId({}) | {:?} * {:?} -\u003e {:?}\",\n                    i,\n                    self.mul_trace.lhs_index[i],\n                    self.mul_trace.rhs_index[i],\n                    self.mul_trace.result_index[i],\n                    self.mul_trace.lhs_values[i],\n                    self.mul_trace.rhs_values[i],\n                    self.mul_trace.result_values[i]\n                );\n            }\n\n            tracing::debug!(\"\\n=== ADD TRACE ===\");\n            for i in 0..self.add_trace.lhs_values.len() {\n                tracing::debug!(\n                    \"Row {}: WitnessId({}) + WitnessId({}) -\u003e WitnessId({}) | {:?} + {:?} -\u003e {:?}\",\n                    i,\n                    self.add_trace.lhs_index[i],\n                    self.add_trace.rhs_index[i],\n                    self.add_trace.result_index[i],\n                    self.add_trace.lhs_values[i],\n                    self.add_trace.rhs_values[i],\n                    self.add_trace.result_values[i]\n                );\n            }\n        }\n    }\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}}],"covered":22,"coverable":68},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","mul.rs"],"content":"use alloc::vec::Vec;\n\nuse p3_field::Field;\n\nuse crate::CircuitError;\nuse crate::op::Op;\nuse crate::types::WitnessId;\n\n/// Multiplication operation table.\n///\n/// Records every multiplication operation in the circuit.\n/// Each row represents one constraint: lhs * rhs = result.\n#[derive(Debug, Clone)]\npub struct MulTrace\u003cF\u003e {\n    /// Left operand values\n    pub lhs_values: Vec\u003cF\u003e,\n    /// Left operand indices (references witness bus)\n    pub lhs_index: Vec\u003cWitnessId\u003e,\n    /// Right operand values\n    pub rhs_values: Vec\u003cF\u003e,\n    /// Right operand indices (references witness bus)\n    pub rhs_index: Vec\u003cWitnessId\u003e,\n    /// Result values\n    pub result_values: Vec\u003cF\u003e,\n    /// Result indices (references witness bus)\n    pub result_index: Vec\u003cWitnessId\u003e,\n}\n\n/// Builder for generating multiplication traces.\npub struct MulTraceBuilder\u003c'a, F\u003e {\n    primitive_ops: \u0026'a [Op\u003cF\u003e],\n    witness: \u0026'a [Option\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone + Field\u003e MulTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new multiplication trace builder.\n    pub const fn new(primitive_ops: \u0026'a [Op\u003cF\u003e], witness: \u0026'a [Option\u003cF\u003e]) -\u003e Self {\n        Self {\n            primitive_ops,\n            witness,\n        }\n    }\n\n    /// Builds the multiplication trace from circuit operations.\n    pub fn build(self) -\u003e Result\u003cMulTrace\u003cF\u003e, CircuitError\u003e {\n        let mut lhs_values = Vec::new();\n        let mut lhs_index = Vec::new();\n        let mut rhs_values = Vec::new();\n        let mut rhs_index = Vec::new();\n        let mut result_values = Vec::new();\n        let mut result_index = Vec::new();\n\n        for prim in self.primitive_ops {\n            if let Op::Mul { a, b, out } = prim {\n                let a_val = self.resolve(a)?;\n                let b_val = self.resolve(b)?;\n                let out_val = self.resolve(out)?;\n\n                lhs_values.push(a_val);\n                lhs_index.push(*a);\n                rhs_values.push(b_val);\n                rhs_index.push(*b);\n                result_values.push(out_val);\n                result_index.push(*out);\n            }\n        }\n\n        // If trace is empty, add a dummy row: 0 * 0 = 0\n        if lhs_values.is_empty() {\n            lhs_values.push(F::ZERO);\n            lhs_index.push(WitnessId(0));\n            rhs_values.push(F::ZERO);\n            rhs_index.push(WitnessId(0));\n            result_values.push(F::ZERO);\n            result_index.push(WitnessId(0));\n        }\n\n        Ok(MulTrace {\n            lhs_values,\n            lhs_index,\n            rhs_values,\n            rhs_index,\n            result_values,\n            result_index,\n        })\n    }\n\n    /// Resolves a single witness value safely.\n    #[inline]\n    fn resolve(\u0026self, id: \u0026WitnessId) -\u003e Result\u003cF, CircuitError\u003e {\n        self.witness\n            .get(id.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .cloned()\n            .ok_or(CircuitError::WitnessNotSet { witness_id: *id })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_multiplication() {\n        // Create a simple witness containing three values\n        //\n        // Index 0: value 5 (left operand)\n        // Index 1: value 3 (right operand)\n        // Index 2: value 15 (result of 5 * 3)\n        let lhs = F::from_u64(5);\n        let rhs = F::from_u64(3);\n        let out = F::from_u64(15);\n        let witness = vec![\n            Some(lhs), // WitnessId(0)\n            Some(rhs), // WitnessId(1)\n            Some(out), // WitnessId(2)\n        ];\n\n        // Define a single multiplication operation: witness[0] * witness[1] = witness[2]\n        //\n        // This represents the constraint: 5 * 3 = 15\n        let ops = vec![Op::Mul {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(2),\n        }];\n\n        // Build the trace using the builder pattern\n        let builder = MulTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace contains exactly one row\n        assert_eq!(\n            trace.lhs_values.len(),\n            1,\n            \"Should have one multiplication operation\"\n        );\n\n        // Verify left operand (lhs) is correctly recorded\n        assert_eq!(trace.lhs_values[0], lhs);\n        assert_eq!(trace.lhs_index[0], WitnessId(0));\n\n        // Verify right operand (rhs) is correctly recorded\n        assert_eq!(trace.rhs_values[0], rhs);\n        assert_eq!(trace.rhs_index[0], WitnessId(1));\n\n        // Verify result is correctly recorded\n        assert_eq!(trace.result_values[0], out);\n        assert_eq!(trace.result_index[0], WitnessId(2));\n    }\n\n    #[test]\n    fn test_multiple_multiplications() {\n        // Create witness with values for three separate multiplications\n        //\n        // We have 9 witness slots total (3 multiplications × 3 values each)\n        let lhs1 = F::from_u64(10);\n        let rhs1 = F::from_u64(20);\n        let out1 = F::from_u64(200);\n\n        let lhs2 = F::from_u64(7);\n        let rhs2 = F::from_u64(13);\n        let out2 = F::from_u64(91);\n\n        let lhs3 = F::from_u64(3);\n        let rhs3 = F::from_u64(4);\n        let out3 = F::from_u64(12);\n\n        let witness = vec![\n            Some(lhs1), // First multiplication: lhs\n            Some(rhs1), // First multiplication: rhs\n            Some(out1), // First multiplication: result\n            Some(lhs2), // Second multiplication: lhs\n            Some(rhs2), // Second multiplication: rhs\n            Some(out2), // Second multiplication: result\n            Some(lhs3), // Third multiplication: lhs\n            Some(rhs3), // Third multiplication: rhs\n            Some(out3), // Third multiplication: result\n        ];\n\n        // Define three multiplication operations\n        let lhs1_witness_id = WitnessId(0);\n        let rhs1_witness_id = WitnessId(1);\n        let out1_witness_id = WitnessId(2);\n        let lhs2_witness_id = WitnessId(3);\n        let rhs2_witness_id = WitnessId(4);\n        let out2_witness_id = WitnessId(5);\n        let lhs3_witness_id = WitnessId(6);\n        let rhs3_witness_id = WitnessId(7);\n        let out3_witness_id = WitnessId(8);\n\n        let ops = vec![\n            Op::Mul {\n                a: lhs1_witness_id,\n                b: rhs1_witness_id,\n                out: out1_witness_id,\n            },\n            Op::Mul {\n                a: lhs2_witness_id,\n                b: rhs2_witness_id,\n                out: out2_witness_id,\n            },\n            Op::Mul {\n                a: lhs3_witness_id,\n                b: rhs3_witness_id,\n                out: out3_witness_id,\n            },\n        ];\n\n        // Build the trace\n        let builder = MulTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify we have exactly three rows\n        assert_eq!(\n            trace.lhs_values.len(),\n            3,\n            \"Should have three multiplication operations\"\n        );\n\n        // Verify first multiplication\n        assert_eq!(trace.lhs_values[0], lhs1);\n        assert_eq!(trace.lhs_index[0], lhs1_witness_id);\n        assert_eq!(trace.rhs_values[0], rhs1);\n        assert_eq!(trace.rhs_index[0], rhs1_witness_id);\n        assert_eq!(trace.result_values[0], out1);\n        assert_eq!(trace.result_index[0], out1_witness_id);\n\n        // Verify second multiplication\n        assert_eq!(trace.lhs_values[1], lhs2);\n        assert_eq!(trace.lhs_index[1], lhs2_witness_id);\n        assert_eq!(trace.rhs_values[1], rhs2);\n        assert_eq!(trace.rhs_index[1], rhs2_witness_id);\n        assert_eq!(trace.result_values[1], out2);\n        assert_eq!(trace.result_index[1], out2_witness_id);\n\n        // Verify third multiplication\n        assert_eq!(trace.lhs_values[2], lhs3);\n        assert_eq!(trace.lhs_index[2], lhs3_witness_id);\n        assert_eq!(trace.rhs_values[2], rhs3);\n        assert_eq!(trace.rhs_index[2], rhs3_witness_id);\n        assert_eq!(trace.result_values[2], out3);\n        assert_eq!(trace.result_index[2], out3_witness_id);\n    }\n\n    #[test]\n    fn test_empty_operations_creates_dummy_row() {\n        // Create a witness with at least one entry (for the dummy row to reference)\n        let witness = vec![Some(F::ZERO)];\n\n        // Provide an empty operations list (no multiplications to process)\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![];\n\n        // Build the trace\n        let builder = MulTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify exactly one dummy row exists\n        assert_eq!(trace.lhs_values.len(), 1, \"Should have one dummy row\");\n\n        // Verify the dummy row contains: 0 * 0 = 0\n        assert_eq!(trace.lhs_values[0], F::ZERO);\n        assert_eq!(trace.lhs_index[0], WitnessId(0));\n        assert_eq!(trace.rhs_values[0], F::ZERO);\n        assert_eq!(trace.rhs_index[0], WitnessId(0));\n        assert_eq!(trace.result_values[0], F::ZERO);\n        assert_eq!(trace.result_index[0], WitnessId(0));\n    }\n\n    #[test]\n    fn test_mixed_operations_filters_correctly() {\n        // Create witness for one multiplication and one addition\n        let lhs = F::from_u64(4);\n        let rhs = F::from_u64(6);\n        let mul_out = F::from_u64(24);\n        let add_out = F::from_u64(10);\n\n        let witness = vec![\n            Some(lhs),     // WitnessId(0)\n            Some(rhs),     // WitnessId(1)\n            Some(mul_out), // WitnessId(2)\n            Some(add_out), // WitnessId(3) for Add\n        ];\n\n        // Create a mixed list of operations\n        //\n        // Only the Mul operation should be processed; Add should be ignored\n        let ops = vec![\n            Op::Add {\n                a: WitnessId(0),\n                b: WitnessId(1),\n                out: WitnessId(3),\n            }, // Should be ignored\n            Op::Mul {\n                a: WitnessId(0),\n                b: WitnessId(1),\n                out: WitnessId(2),\n            }, // Should be processed\n            Op::Add {\n                a: WitnessId(1),\n                b: WitnessId(2),\n                out: WitnessId(3),\n            }, // Should be ignored\n        ];\n\n        // Build the trace\n        let builder = MulTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify only one row exists (only one Mul operation)\n        assert_eq!(\n            trace.lhs_values.len(),\n            1,\n            \"Should process only the Mul operation\"\n        );\n\n        // Verify the single multiplication row is correct (4 * 6 = 24)\n        assert_eq!(trace.lhs_values[0], lhs);\n        assert_eq!(trace.rhs_values[0], rhs);\n        assert_eq!(trace.result_values[0], mul_out);\n    }\n\n    #[test]\n    fn test_missing_witness_lhs_returns_error() {\n        // Create witness where the left operand (index 0) is missing\n        let rhs = F::from_u64(5);\n        let out = F::from_u64(25);\n\n        let witness = vec![\n            None,      // WitnessId(0) - NOT SET\n            Some(rhs), // WitnessId(1)\n            Some(out), // WitnessId(2)\n        ];\n\n        // Define a multiplication that references the missing witness\n        let ops = vec![Op::Mul {\n            a: WitnessId(0), // References the None value\n            b: WitnessId(1),\n            out: WitnessId(2),\n        }];\n\n        // Attempt to build the trace\n        let builder = MulTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify the operation fails with the correct error\n        assert!(result.is_err(), \"Should fail when lhs witness is not set\");\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(\n                    witness_id,\n                    WitnessId(0),\n                    \"Error should reference WitnessId(0)\"\n                );\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n\n    #[test]\n    fn test_missing_witness_rhs_returns_error() {\n        // Create witness where the right operand (index 1) is missing\n        let lhs = F::from_u64(5);\n        let out = F::from_u64(25);\n\n        let witness = vec![\n            Some(lhs), // WitnessId(0)\n            None,      // WitnessId(1) - NOT SET\n            Some(out), // WitnessId(2)\n        ];\n\n        // Define a multiplication that references the missing witness\n        let ops = vec![Op::Mul {\n            a: WitnessId(0),\n            b: WitnessId(1), // References the None value\n            out: WitnessId(2),\n        }];\n\n        // Attempt to build the trace\n        let builder = MulTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify the operation fails with the correct error\n        assert!(result.is_err(), \"Should fail when rhs witness is not set\");\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(\n                    witness_id,\n                    WitnessId(1),\n                    \"Error should reference WitnessId(1)\"\n                );\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n\n    #[test]\n    fn test_missing_witness_result_returns_error() {\n        // Create witness where the result (index 2) is missing\n        let lhs = F::from_u64(5);\n        let rhs = F::from_u64(3);\n\n        let witness = vec![\n            Some(lhs), // WitnessId(0)\n            Some(rhs), // WitnessId(1)\n            None,      // WitnessId(2) - NOT SET\n        ];\n\n        // Define a multiplication that references the missing result\n        let ops = vec![Op::Mul {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(2), // References the None value\n        }];\n\n        // Attempt to build the trace\n        let builder = MulTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify the operation fails with the correct error\n        assert!(\n            result.is_err(),\n            \"Should fail when result witness is not set\"\n        );\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(\n                    witness_id,\n                    WitnessId(2),\n                    \"Error should reference WitnessId(2)\"\n                );\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n\n    #[test]\n    fn test_out_of_bounds_witness_id() {\n        // Create a small witness array with only 2 elements\n        let lhs = F::from_u64(5);\n        let rhs = F::from_u64(3);\n\n        let witness = vec![Some(lhs), Some(rhs)];\n\n        // Attempt to reference WitnessId(5), which doesn't exist\n        let ops = vec![Op::Mul {\n            a: WitnessId(0),\n            b: WitnessId(1),\n            out: WitnessId(5), // Out of bounds!\n        }];\n\n        // Attempt to build the trace\n        let builder = MulTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify proper error handling\n        assert!(\n            result.is_err(),\n            \"Should fail when witness ID is out of bounds\"\n        );\n        match result {\n            Err(CircuitError::WitnessNotSet { witness_id }) =\u003e {\n                assert_eq!(\n                    witness_id,\n                    WitnessId(5),\n                    \"Error should reference WitnessId(5)\"\n                );\n            }\n            _ =\u003e panic!(\"Expected WitnessNotSet error\"),\n        }\n    }\n}\n","traces":[{"line":37,"address":[4394096,4394192,4394000,4394144,4394048],"length":1,"stats":{"Line":18}},{"line":45,"address":[4197056,4194864,4197024,4199268],"length":1,"stats":{"Line":16}},{"line":46,"address":[2887291],"length":1,"stats":{"Line":17}},{"line":47,"address":[2887301],"length":1,"stats":{"Line":16}},{"line":48,"address":[2115401],"length":1,"stats":{"Line":18}},{"line":49,"address":[4195024,4197198],"length":1,"stats":{"Line":16}},{"line":50,"address":[],"length":0,"stats":{"Line":18}},{"line":51,"address":[3592084],"length":1,"stats":{"Line":16}},{"line":53,"address":[2115611,2115686],"length":1,"stats":{"Line":34}},{"line":54,"address":[7172742,7174913,7174063,7171937],"length":1,"stats":{"Line":33}},{"line":55,"address":[2236493,2237234],"length":1,"stats":{"Line":16}},{"line":56,"address":[2116886,2117440],"length":1,"stats":{"Line":16}},{"line":57,"address":[4395999,4398587,4400535,4405279,4398239,4396347,4403103,4404985,4400947,4402809],"length":1,"stats":{"Line":16}},{"line":59,"address":[2889190],"length":1,"stats":{"Line":15}},{"line":60,"address":[2237070],"length":1,"stats":{"Line":15}},{"line":61,"address":[3593776],"length":1,"stats":{"Line":15}},{"line":62,"address":[2889288],"length":1,"stats":{"Line":15}},{"line":63,"address":[2948073],"length":1,"stats":{"Line":16}},{"line":64,"address":[],"length":0,"stats":{"Line":15}},{"line":69,"address":[2946568],"length":1,"stats":{"Line":16}},{"line":70,"address":[2116462],"length":1,"stats":{"Line":4}},{"line":71,"address":[7172639,7174776],"length":1,"stats":{"Line":3}},{"line":72,"address":[3593032],"length":1,"stats":{"Line":4}},{"line":73,"address":[3593049],"length":1,"stats":{"Line":3}},{"line":74,"address":[2888510],"length":1,"stats":{"Line":4}},{"line":75,"address":[1657739],"length":1,"stats":{"Line":3}},{"line":78,"address":[4399559,4397319,4401935,4395079,4404111],"length":1,"stats":{"Line":16}},{"line":79,"address":[2946598],"length":1,"stats":{"Line":17}},{"line":80,"address":[],"length":0,"stats":{"Line":15}},{"line":81,"address":[4394887,4397127,4401743,4403919,4399367],"length":1,"stats":{"Line":16}},{"line":82,"address":[2946727],"length":1,"stats":{"Line":15}},{"line":83,"address":[4195643,4197799],"length":1,"stats":{"Line":16}},{"line":84,"address":[2888055],"length":1,"stats":{"Line":15}},{"line":90,"address":[2889504],"length":1,"stats":{"Line":14}},{"line":91,"address":[2237372],"length":1,"stats":{"Line":14}},{"line":92,"address":[2237380],"length":1,"stats":{"Line":14}},{"line":93,"address":[2237392,2237481,2237472],"length":1,"stats":{"Line":42}},{"line":95,"address":[4405627,4405882,4405994,4405505,4405755],"length":1,"stats":{"Line":14}}],"covered":38,"coverable":38},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","poseidon2.rs"],"content":"use alloc::boxed::Box;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::any::Any;\nuse core::fmt::Debug;\n\nuse p3_field::{ExtensionField, PrimeCharacteristicRing, PrimeField};\n\nuse super::NonPrimitiveTrace;\nuse crate::CircuitError;\nuse crate::circuit::{Circuit, CircuitField};\nuse crate::op::{NonPrimitiveOpPrivateData, NonPrimitiveOpType, Op};\nuse crate::ops::poseidon2_perm::Poseidon2PermExecutor;\nuse crate::types::WitnessId;\n\n/// Private data for Poseidon2 permutation.\n/// Only used for Merkle mode operations, contains exactly 2 extension field limbs (the sibling).\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Poseidon2PermPrivateData\u003cF\u003e {\n    pub sibling: [F; 2],\n}\n\n/// Trait to provide Poseidon2 configuration parameters for a field type.\n///\n/// This allows the trace generator and AIR to work with different Poseidon2 configurations\n/// without hardcoding parameters. Implementations should provide the standard\n/// parameters for their field type.\npub trait Poseidon2Params {\n    type BaseField: PrimeField + PrimeCharacteristicRing;\n    /// Extension degree D\n    const D: usize;\n    /// Total width in base field elements\n    const WIDTH: usize;\n\n    /// Rate in extension elements\n    const RATE_EXT: usize;\n    /// Capacity in extension elements\n    const CAPACITY_EXT: usize;\n    /// Capacity size in base field elements = CAPACITY_EXT * D\n    const CAPACITY_SIZE: usize = Self::CAPACITY_EXT * Self::D;\n\n    /// S-box degree (polynomial degree for the S-box)\n    const SBOX_DEGREE: u64;\n    /// Number of S-box registers\n    const SBOX_REGISTERS: usize;\n\n    /// Number of half full rounds\n    const HALF_FULL_ROUNDS: usize;\n    /// Number of partial rounds\n    const PARTIAL_ROUNDS: usize;\n\n    /// Width in extension elements = RATE_EXT + CAPACITY_EXT\n    const WIDTH_EXT: usize = Self::RATE_EXT + Self::CAPACITY_EXT;\n}\n\n/// Poseidon2 operation table row.\n///\n/// This implements the Poseidon2 Permutation Table specification.\n/// See: https://github.com/Plonky3/Plonky3-recursion/discussions/186\n///\n/// The table has one row per Poseidon2 call, implementing:\n/// - Standard chaining (Challenger-style sponge use)\n/// - Merkle-path chaining (MMCS directional hashing)\n/// - Selective limb exposure to the witness via CTL\n/// - Optional MMCS index accumulator\n#[derive(Debug, Clone)]\npub struct Poseidon2CircuitRow\u003cF\u003e {\n    /// Control: If 1, row begins a new independent Poseidon2 chain.\n    pub new_start: bool,\n    /// Control: 0 → normal sponge/Challenger mode, 1 → Merkle-path mode.\n    pub merkle_path: bool,\n    /// Control: Direction bit for Merkle left/right hashing (only meaningful when merkle_path = 1).\n    pub mmcs_bit: bool,\n    /// Value: Optional MMCS accumulator (base field, encodes a u32-like integer).\n    pub mmcs_index_sum: F,\n    /// Inputs to the Poseidon2 permutation (flattened state, length = WIDTH).\n    /// Represents in[0..3] - 4 extension limbs (input digest).\n    pub input_values: Vec\u003cF\u003e,\n    /// Input exposure flags: for each limb i, if 1, in[i] must match witness lookup at input_indices[i].\n    pub in_ctl: [bool; 4],\n    /// Input exposure indices: index into the witness table for each limb.\n    pub input_indices: [u32; 4],\n    /// Output exposure flags: for limbs 0-1 only, if 1, out[i] must match witness lookup at output_indices[i].\n    /// Note: limbs 2-3 are never publicly exposed (always private).\n    pub out_ctl: [bool; 2],\n    /// Output exposure indices: index into the witness table for limbs 0-1.\n    pub output_indices: [u32; 2],\n    /// MMCS index exposure: index for CTL exposure of mmcs_index_sum.\n    pub mmcs_index_sum_idx: u32,\n}\npub type Poseidon2CircuitTrace\u003cF\u003e = Vec\u003cPoseidon2CircuitRow\u003cF\u003e\u003e;\n\n/// Poseidon2 trace for all hash operations in the circuit.\n#[derive(Debug, Clone)]\npub struct Poseidon2Trace\u003cF\u003e {\n    /// All Poseidon2 operations (permutation rows) in this trace.\n    pub operations: Poseidon2CircuitTrace\u003cF\u003e,\n}\n\n// Needed for NonPrimitiveTrace\u003cF\u003e\nunsafe impl\u003cF: Send + Sync\u003e Send for Poseidon2Trace\u003cF\u003e {}\nunsafe impl\u003cF: Send + Sync\u003e Sync for Poseidon2Trace\u003cF\u003e {}\n\nimpl\u003cF\u003e Poseidon2Trace\u003cF\u003e {\n    pub const fn total_rows(\u0026self) -\u003e usize {\n        self.operations.len()\n    }\n}\n\nimpl\u003cTraceF: Clone + Send + Sync + 'static, CF\u003e NonPrimitiveTrace\u003cCF\u003e for Poseidon2Trace\u003cTraceF\u003e {\n    fn id(\u0026self) -\u003e \u0026'static str {\n        \"poseidon2\"\n    }\n\n    fn rows(\u0026self) -\u003e usize {\n        self.total_rows()\n    }\n\n    fn as_any(\u0026self) -\u003e \u0026dyn Any {\n        self\n    }\n\n    fn boxed_clone(\u0026self) -\u003e Box\u003cdyn NonPrimitiveTrace\u003cCF\u003e\u003e {\n        Box::new(self.clone())\n    }\n}\n\n/// Builder for generating Poseidon2 traces.\n///\n/// The builder handles the conversion from the circuit's extension field (`CF`) to the\n/// base field (`Config::BaseField`) required by the Poseidon2 permutation.\npub struct Poseidon2TraceBuilder\u003c'a, CF, Config: Poseidon2Params\u003e {\n    circuit: \u0026'a Circuit\u003cCF\u003e,\n    witness: \u0026'a [Option\u003cCF\u003e],\n    non_primitive_op_private_data: \u0026'a [Option\u003cNonPrimitiveOpPrivateData\u003cCF\u003e\u003e],\n\n    phantom: core::marker::PhantomData\u003cConfig\u003e,\n}\n\nimpl\u003c'a, CF, Config\u003e Poseidon2TraceBuilder\u003c'a, CF, Config\u003e\nwhere\n    CF: CircuitField + ExtensionField\u003cConfig::BaseField\u003e,\n    Config: Poseidon2Params,\n{\n    /// Creates a new Poseidon2 trace builder.\n    pub const fn new(\n        circuit: \u0026'a Circuit\u003cCF\u003e,\n        witness: \u0026'a [Option\u003cCF\u003e],\n        non_primitive_op_private_data: \u0026'a [Option\u003cNonPrimitiveOpPrivateData\u003cCF\u003e\u003e],\n    ) -\u003e Self {\n        Self {\n            circuit,\n            witness,\n            non_primitive_op_private_data,\n            phantom: core::marker::PhantomData,\n        }\n    }\n\n    fn get_witness(\u0026self, index: \u0026WitnessId) -\u003e Result\u003cCF, CircuitError\u003e {\n        self.witness\n            .get(index.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .cloned()\n            .ok_or(CircuitError::WitnessNotSet { witness_id: *index })\n    }\n\n    /// Builds the Poseidon2 trace by scanning non-primitive ops with hash executors.\n    /// Also maintains state and fills state hints for stateful operations.\n    pub fn build(self) -\u003e Result\u003cPoseidon2Trace\u003cConfig::BaseField\u003e, CircuitError\u003e {\n        let mut operations = Vec::new();\n\n        let width = Config::WIDTH;\n        let d = Config::D;\n\n        for op in \u0026self.circuit.ops {\n            let Op::NonPrimitiveOpWithExecutor {\n                inputs,\n                outputs,\n                executor,\n                op_id,\n            } = op\n            else {\n                continue;\n            };\n\n            if executor.op_type() == \u0026NonPrimitiveOpType::Poseidon2Perm {\n                let Some(exec) = executor.as_any().downcast_ref::\u003cPoseidon2PermExecutor\u003e() else {\n                    return Err(CircuitError::InvalidNonPrimitiveOpConfiguration {\n                        op: executor.op_type().clone(),\n                    });\n                };\n                let (new_start, merkle_path) = (exec.new_start, exec.merkle_path);\n                // Expected input layout: [in0, in1, in2, in3, mmcs_index_sum, mmcs_bit]\n                if inputs.len() != 6 {\n                    return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                        op: executor.op_type().clone(),\n                        expected: \"6 input vectors\".to_string(),\n                        got: inputs.len(),\n                    });\n                }\n                // Expected output layout: [out0, out1]\n                if outputs.len() != 2 {\n                    return Err(CircuitError::NonPrimitiveOpLayoutMismatch {\n                        op: executor.op_type().clone(),\n                        expected: \"2 output vectors\".to_string(),\n                        got: outputs.len(),\n                    });\n                }\n\n                // mmcs_bit is at inputs[5]\n                if inputs[5].len() \u003e 1 {\n                    return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                        op: executor.op_type().clone(),\n                        expected: \"0 or 1 element for mmcs_bit\".to_string(),\n                        got: inputs[5].len(),\n                    });\n                }\n                if merkle_path \u0026\u0026 inputs[5].is_empty() {\n                    return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                        op: executor.op_type().clone(),\n                        operation_index: *op_id,\n                        expected: \"mmcs_bit must be provided when merkle_path=true\".to_string(),\n                        got: \"missing mmcs_bit\".to_string(),\n                    });\n                }\n\n                let mmcs_bit = if inputs[5].len() == 1 {\n                    let val = self.get_witness(\u0026inputs[5][0])?;\n                    let base = val.as_base().ok_or_else(|| {\n                        CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                            op: executor.op_type().clone(),\n                            operation_index: *op_id,\n                            expected: \"base field mmcs_bit\".to_string(),\n                            got: \"extension value\".to_string(),\n                        }\n                    })?;\n                    match base {\n                        x if x == Config::BaseField::ZERO =\u003e false,\n                        x if x == Config::BaseField::ONE =\u003e true,\n                        other =\u003e {\n                            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                                op: executor.op_type().clone(),\n                                operation_index: *op_id,\n                                expected: \"boolean mmcs_bit (0 or 1)\".to_string(),\n                                got: format!(\"{other:?}\"),\n                            });\n                        }\n                    }\n                } else {\n                    false\n                };\n\n                // Initialize padded_inputs.\n                // If private data is available, use it as the default.\n                // Otherwise start with zero.\n                let mut padded_inputs = vec![Config::BaseField::ZERO; width];\n\n                if let Some(Some(NonPrimitiveOpPrivateData::Poseidon2Perm(private_data))) =\n                    self.non_primitive_op_private_data.get(op_id.0 as usize)\n                {\n                    // Private inputs are only valid for Merkle mode (merkle_path \u0026\u0026 !new_start).\n                    // The type [F; 2] guarantees exactly 2 limbs (the sibling).\n                    if !merkle_path || new_start {\n                        return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                            op: executor.op_type().clone(),\n                            operation_index: *op_id,\n                            expected: \"no private data (only Merkle mode accepts private data)\"\n                                .to_string(),\n                            got: \"private data provided for non-Merkle operation\".to_string(),\n                        });\n                    }\n\n                    // Place sibling in the correct limbs based on mmcs_bit.\n                    // mmcs_bit=0: sibling in 2-3\n                    // mmcs_bit=1: sibling in 0-1\n                    let start_limb = if mmcs_bit { 0 } else { 2 };\n                    for (i, limb) in private_data.sibling.iter().enumerate() {\n                        let target_limb = start_limb + i;\n                        let coeffs = limb.as_basis_coefficients_slice();\n                        padded_inputs[target_limb * d..(target_limb + 1) * d]\n                            .copy_from_slice(coeffs);\n                    }\n                }\n\n                let mut in_ctl = [false; 4];\n                let mut in_idx = [0u32; 4];\n                for limb in 0..4 {\n                    let chunk = \u0026inputs[limb];\n                    match chunk.len() {\n                        // Case 1: No input provided for this limb. It remains zero-padded.\n                        0 =\u003e {}\n                        // Case 2: Input provided as a single WitnessId, representing an extension field element.\n                        // We convert this extension element to its `d` base field coefficients.\n                        1 =\u003e {\n                            let val = self.get_witness(\u0026chunk[0])?;\n                            let coeffs = val.as_basis_coefficients_slice();\n                            if coeffs.len() != d {\n                                return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                                    op: executor.op_type().clone(),\n                                    expected: d.to_string(),\n                                    got: coeffs.len(),\n                                });\n                            }\n                            in_ctl[limb] = true;\n                            in_idx[limb] = chunk[0].0;\n                            padded_inputs[limb * d..(limb + 1) * d].copy_from_slice(coeffs);\n                        }\n                        // Case 3: Input provided as `d` WitnessIds, representing base field elements.\n                        // The extension element is already \"flattened\" into its base field components.\n                        len if len == d =\u003e {\n                            in_ctl[limb] = true;\n                            in_idx[limb] = chunk[0].0;\n                            for (dst, \u0026wid) in padded_inputs[limb * d..(limb + 1) * d]\n                                .iter_mut()\n                                .zip(chunk.iter())\n                            {\n                                let val = self.get_witness(\u0026wid)?;\n                                let base = val.as_base().ok_or_else(|| {\n                                    CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                                        op: executor.op_type().clone(),\n                                        operation_index: *op_id,\n                                        expected: \"base field limb component\".to_string(),\n                                        got: \"extension value\".to_string(),\n                                    }\n                                })?;\n                                *dst = base;\n                            }\n                        }\n                        // Case 4: Invalid input length.\n                        other =\u003e {\n                            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                                op: executor.op_type().clone(),\n                                expected: format!(\"0, 1, or {d} elements per limb\"),\n                                got: other,\n                            });\n                        }\n                    }\n                }\n\n                let mut out_ctl = [false; 2];\n                let mut out_idx = [0u32; 2];\n                for (offset, chunk) in outputs.iter().enumerate() {\n                    if chunk.len() == d || chunk.len() == 1 {\n                        out_ctl[offset] = true;\n                        out_idx[offset] = chunk[0].0;\n                    } else if !chunk.is_empty() {\n                        return Err(CircuitError::IncorrectNonPrimitiveOpPrivateDataSize {\n                            op: executor.op_type().clone(),\n                            expected: format!(\"0, 1, or {d} elements per output limb\"),\n                            got: chunk.len(),\n                        });\n                    }\n                }\n\n                // mmcs_index_sum is at inputs[4]\n                let (mmcs_index_sum, mmcs_index_sum_idx) = if inputs[4].len() == 1 {\n                    let val = self.get_witness(\u0026inputs[4][0])?;\n                    let base = val.as_base().ok_or_else(|| {\n                        CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                            op: executor.op_type().clone(),\n                            operation_index: *op_id,\n                            expected: \"base field mmcs_index_sum\".to_string(),\n                            got: \"extension value\".to_string(),\n                        }\n                    })?;\n                    (base, inputs[4][0].0)\n                } else {\n                    (Config::BaseField::ZERO, 0)\n                };\n\n                operations.push(Poseidon2CircuitRow {\n                    new_start,\n                    merkle_path,\n                    mmcs_bit,\n                    mmcs_index_sum,\n                    input_values: padded_inputs,\n                    in_ctl,\n                    input_indices: in_idx,\n                    out_ctl,\n                    output_indices: out_idx,\n                    mmcs_index_sum_idx,\n                });\n                continue;\n            }\n        }\n\n        Ok(Poseidon2Trace { operations })\n    }\n}\n\n/// Generate the Poseidon2 trace with a specific configuration.\n///\n/// # Type Parameters\n/// - `F`: The field type (e.g., `BabyBear`, `KoalaBear`)\n/// - `Config`: A type implementing `Poseidon2Params` that specifies the Poseidon2 configuration\n///   (e.g., `BabyBearD4Width16`, `BabyBearD4Width24` from [`p3-poseidon2-circuit-air::public_types`])\n///\n/// # Example\n///\n/// ```ignore\n/// use p3_poseidon2_circuit_air::BabyBearD4Width16;\n/// builder.enable_hash(true, generate_poseidon2_trace::\u003cBabyBear, BabyBearD4Width16\u003e);\n/// ```\npub fn generate_poseidon2_trace\u003c\n    F: CircuitField + ExtensionField\u003cConfig::BaseField\u003e,\n    Config: Poseidon2Params,\n\u003e(\n    circuit: \u0026Circuit\u003cF\u003e,\n    witness: \u0026[Option\u003cF\u003e],\n    non_primitive_data: \u0026[Option\u003cNonPrimitiveOpPrivateData\u003cF\u003e\u003e],\n) -\u003e Result\u003cOption\u003cBox\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e\u003e, CircuitError\u003e {\n    let trace =\n        Poseidon2TraceBuilder::\u003cF, Config\u003e::new(circuit, witness, non_primitive_data).build()?;\n    if trace.total_rows() == 0 {\n        Ok(None)\n    } else {\n        Ok(Some(Box::new(trace)))\n    }\n}\n","traces":[{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":163},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","public.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::CircuitError;\nuse crate::op::Op;\nuse crate::types::WitnessId;\n\n/// Public input table.\n///\n/// Unlike compile-time `Const` values, these inputs are provided at runtime\n/// and are known to both the prover and the verifier.\n#[derive(Debug, Clone)]\npub struct PublicTrace\u003cF\u003e {\n    /// Witness IDs of each public input.\n    ///\n    /// Identifies which witness slots contain public values.\n    pub index: Vec\u003cWitnessId\u003e,\n\n    /// Public input field element values.\n    ///\n    /// Provided at the start of the execution.\n    /// Serve as the starting point for computation.\n    pub values: Vec\u003cF\u003e,\n}\n\n/// Builder for generating public input traces.\npub struct PublicTraceBuilder\u003c'a, F\u003e {\n    primitive_ops: \u0026'a [Op\u003cF\u003e],\n    witness: \u0026'a [Option\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone\u003e PublicTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new public trace builder.\n    pub const fn new(primitive_ops: \u0026'a [Op\u003cF\u003e], witness: \u0026'a [Option\u003cF\u003e]) -\u003e Self {\n        Self {\n            primitive_ops,\n            witness,\n        }\n    }\n\n    /// Builds the public input trace from circuit operations.\n    pub fn build(self) -\u003e Result\u003cPublicTrace\u003cF\u003e, CircuitError\u003e {\n        let mut index = Vec::new();\n        let mut values = Vec::new();\n\n        for prim in self.primitive_ops {\n            if let Op::Public { out, public_pos: _ } = prim {\n                index.push(*out);\n                let value = self\n                    .witness\n                    .get(out.0 as usize)\n                    .and_then(|opt| opt.as_ref())\n                    .cloned()\n                    .ok_or(CircuitError::WitnessNotSet { witness_id: *out })?;\n                values.push(value);\n            }\n        }\n\n        Ok(PublicTrace { index, values })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_public_input() {\n        // Create a single public input operation that reads from witness\n        let out = WitnessId(0);\n        let val = F::from_u64(42);\n\n        let ops = vec![Op::Public { out, public_pos: 0 }];\n\n        // Prepare the witness table with the public input value\n        let witness = vec![Some(val)];\n\n        // Build the trace using the builder pattern\n        let builder = PublicTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace contains exactly one public input\n        assert_eq!(trace.index.len(), 1, \"Should have one public input\");\n        assert_eq!(trace.values.len(), 1, \"Should have one public value\");\n\n        // Verify the public input is correctly recorded\n        assert_eq!(trace.index[0], out);\n        assert_eq!(trace.values[0], val);\n    }\n\n    #[test]\n    fn test_multiple_public_inputs() {\n        // Create multiple public input operations with non-contiguous witness indices\n        let out1 = WitnessId(0);\n        let out2 = WitnessId(2);\n\n        let val1 = F::from_u64(10);\n        let val2 = F::from_u64(30);\n\n        let ops = vec![\n            Op::Public {\n                out: out1,\n                public_pos: 0,\n            },\n            Op::Public {\n                out: out2,\n                public_pos: 1,\n            },\n        ];\n\n        // Prepare witness table with gaps (index 1 is unused)\n        let witness = vec![Some(val1), None, Some(val2)];\n\n        // Build the trace\n        let builder = PublicTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify we have exactly two public inputs\n        assert_eq!(trace.index.len(), 2, \"Should have two public inputs\");\n        assert_eq!(trace.values.len(), 2, \"Should have two public values\");\n\n        // Verify first public input\n        assert_eq!(trace.index[0], out1);\n        assert_eq!(trace.values[0], val1);\n\n        // Verify second public input\n        assert_eq!(trace.index[1], out2);\n        assert_eq!(trace.values[1], val2);\n    }\n\n    #[test]\n    fn test_empty_operations() {\n        // Provide an empty operations list\n        let ops: Vec\u003cOp\u003cF\u003e\u003e = vec![];\n        let witness: Vec\u003cOption\u003cF\u003e\u003e = vec![];\n\n        // Build the trace\n        let builder = PublicTraceBuilder::new(\u0026ops, \u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace is empty\n        assert_eq!(trace.index.len(), 0, \"Should have no public inputs\");\n        assert_eq!(trace.values.len(), 0, \"Should have no values\");\n    }\n\n    #[test]\n    fn test_witness_not_set_error() {\n        // Create a public input operation referencing an unset witness slot\n        let out = WitnessId(0);\n        let ops = vec![Op::Public { out, public_pos: 0 }];\n\n        // Witness table has the slot but value is None (not yet set)\n        let witness: Vec\u003cOption\u003cF\u003e\u003e = vec![None];\n\n        // Attempt to build the trace\n        let builder = PublicTraceBuilder::new(\u0026ops, \u0026witness);\n        let result = builder.build();\n\n        // Verify the build fails with the expected error\n        assert!(result.is_err(), \"Should fail when witness is not set\");\n        assert!(matches!(\n            result,\n            Err(CircuitError::WitnessNotSet { witness_id }) if witness_id == out\n        ));\n    }\n}\n","traces":[{"line":33,"address":[2521952],"length":1,"stats":{"Line":17}},{"line":41,"address":[6885632,6886656,6886637,6887688],"length":1,"stats":{"Line":15}},{"line":42,"address":[1714262],"length":1,"stats":{"Line":17}},{"line":43,"address":[3041949],"length":1,"stats":{"Line":15}},{"line":45,"address":[],"length":0,"stats":{"Line":32}},{"line":46,"address":[2416783,2416059,2416348],"length":1,"stats":{"Line":47}},{"line":47,"address":[2760976],"length":1,"stats":{"Line":15}},{"line":48,"address":[4895129,4895365,4894096,4897484,4896318,4897381,4893221,4892985,4893118,4894229,4896421,4897248,4894332,4895262,4896185],"length":1,"stats":{"Line":32}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[2761009],"length":1,"stats":{"Line":16}},{"line":51,"address":[2523056,2522630,2523065],"length":1,"stats":{"Line":48}},{"line":53,"address":[3042571,3042677],"length":1,"stats":{"Line":17}},{"line":54,"address":[],"length":0,"stats":{"Line":15}},{"line":58,"address":[2416120],"length":1,"stats":{"Line":15}}],"covered":13,"coverable":14},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","runner.rs"],"content":"use alloc::boxed::Box;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\n\nuse hashbrown::HashMap;\nuse p3_util::zip_eq::zip_eq;\nuse tracing::instrument;\n\nuse super::add::AddTraceBuilder;\nuse super::constant::ConstTraceBuilder;\nuse super::mul::MulTraceBuilder;\nuse super::public::PublicTraceBuilder;\nuse super::witness::WitnessTraceBuilder;\nuse super::{NonPrimitiveTrace, Traces};\nuse crate::circuit::Circuit;\nuse crate::op::{ExecutionContext, NonPrimitiveOpPrivateData, Op};\nuse crate::types::{NonPrimitiveOpId, WitnessId};\nuse crate::{CircuitError, CircuitField};\n\n/// Circuit execution engine.\npub struct CircuitRunner\u003cF\u003e {\n    /// Circuit specification.\n    circuit: Circuit\u003cF\u003e,\n    /// Witness values (None = unset, Some = computed).\n    witness: Vec\u003cOption\u003cF\u003e\u003e,\n    /// Private data for non-primitive operations (not on witness bus)\n    non_primitive_op_private_data: Vec\u003cOption\u003cNonPrimitiveOpPrivateData\u003cF\u003e\u003e\u003e,\n    /// Map from NonPrimitiveOpId -\u003e index in `circuit.ops` for type checks.\n    non_primitive_op_index_by_id: Vec\u003cOption\u003cusize\u003e\u003e,\n}\n\nimpl\u003cF: CircuitField\u003e CircuitRunner\u003cF\u003e {\n    /// Creates circuit runner with empty witness storage.\n    pub fn new(circuit: Circuit\u003cF\u003e) -\u003e Self {\n        let witness = vec![None; circuit.witness_count as usize];\n        let mut max_op_id: Option\u003cu32\u003e = None;\n        for op in \u0026circuit.ops {\n            if let Op::NonPrimitiveOpWithExecutor { op_id, .. } = op {\n                max_op_id = Some(max_op_id.map_or(op_id.0, |cur| cur.max(op_id.0)));\n            }\n        }\n        let non_primitive_op_count = max_op_id.map_or(0, |m| m as usize + 1);\n\n        let mut non_primitive_op_index_by_id = vec![None; non_primitive_op_count];\n        for (idx, op) in circuit.ops.iter().enumerate() {\n            if let Op::NonPrimitiveOpWithExecutor { op_id, .. } = op\n                \u0026\u0026 let Some(slot) = non_primitive_op_index_by_id.get_mut(op_id.0 as usize)\n            {\n                #[cfg(debug_assertions)]\n                debug_assert!(\n                    slot.is_none(),\n                    \"duplicate NonPrimitiveOpId({}) in circuit.ops\",\n                    op_id.0\n                );\n                // Keep the first occurrence if duplicates exist (release builds).\n                if slot.is_none() {\n                    *slot = Some(idx);\n                }\n            }\n        }\n\n        let non_primitive_op_private_data = vec![None; non_primitive_op_count];\n        Self {\n            circuit,\n            witness,\n            non_primitive_op_private_data,\n            non_primitive_op_index_by_id,\n        }\n    }\n\n    /// Sets public input values into witness table.\n    pub fn set_public_inputs(\u0026mut self, public_values: \u0026[F]) -\u003e Result\u003c(), CircuitError\u003e {\n        if public_values.len() != self.circuit.public_flat_len {\n            return Err(CircuitError::PublicInputLengthMismatch {\n                expected: self.circuit.public_flat_len,\n                got: public_values.len(),\n            });\n        }\n        if self.circuit.public_rows.len() != self.circuit.public_flat_len {\n            return Err(CircuitError::MissingPublicRowsMapping);\n        }\n\n        for (i, value) in public_values.iter().enumerate() {\n            let widx = self.circuit.public_rows[i];\n            self.set_witness(widx, *value)?;\n        }\n\n        Ok(())\n    }\n\n    /// Sets private data for a non-primitive operation.\n    pub fn set_non_primitive_op_private_data(\n        \u0026mut self,\n        op_id: NonPrimitiveOpId,\n        private_data: NonPrimitiveOpPrivateData\u003cF\u003e,\n    ) -\u003e Result\u003c(), CircuitError\u003e {\n        // Validate that the op_id exists in the circuit.\n        if op_id.0 as usize \u003e= self.non_primitive_op_private_data.len()\n            || self\n                .non_primitive_op_index_by_id\n                .get(op_id.0 as usize)\n                .and_then(|x| *x)\n                .is_none()\n        {\n            return Err(CircuitError::NonPrimitiveOpIdOutOfRange {\n                op_id: op_id.0,\n                max_ops: self.non_primitive_op_private_data.len(),\n            });\n        }\n\n        // Validate that the private data matches the operation type\n        let op_idx = self\n            .non_primitive_op_index_by_id\n            .get(op_id.0 as usize)\n            .and_then(|x| *x)\n            .ok_or(CircuitError::NonPrimitiveOpIdOutOfRange {\n                op_id: op_id.0,\n                max_ops: self.non_primitive_op_private_data.len(),\n            })?;\n        let Op::NonPrimitiveOpWithExecutor { executor, .. } = \u0026self.circuit.ops[op_idx] else {\n            return Err(CircuitError::NonPrimitiveOpIdOutOfRange {\n                op_id: op_id.0,\n                max_ops: self.non_primitive_op_private_data.len(),\n            });\n        };\n        match (executor.op_type(), \u0026private_data) {\n            (\n                crate::op::NonPrimitiveOpType::Poseidon2Perm,\n                NonPrimitiveOpPrivateData::Poseidon2Perm(_),\n            ) =\u003e {\n                // ok\n            }\n        }\n\n        // Disallow double-setting private data\n        if self.non_primitive_op_private_data[op_id.0 as usize].is_some() {\n            return Err(CircuitError::IncorrectNonPrimitiveOpPrivateData {\n                op: executor.op_type().clone(),\n                operation_index: op_id,\n                expected: \"private data not previously set\".to_string(),\n                got: \"already set\".to_string(),\n            });\n        }\n\n        // Store private data for this operation\n        self.non_primitive_op_private_data[op_id.0 as usize] = Some(private_data);\n        Ok(())\n    }\n\n    /// Run the circuit and generate traces\n    #[instrument(skip_all)]\n    pub fn run(mut self) -\u003e Result\u003cTraces\u003cF\u003e, CircuitError\u003e {\n        self.execute_all()?;\n\n        // Delegate to trace builders for each table\n        let witness_trace = WitnessTraceBuilder::new(\u0026self.witness).build()?;\n        let const_trace = ConstTraceBuilder::new(\u0026self.circuit.ops).build()?;\n        let public_trace = PublicTraceBuilder::new(\u0026self.circuit.ops, \u0026self.witness).build()?;\n        let add_trace = AddTraceBuilder::new(\u0026self.circuit.ops, \u0026self.witness).build()?;\n        let mul_trace = MulTraceBuilder::new(\u0026self.circuit.ops, \u0026self.witness).build()?;\n\n        let mut non_primitive_traces: HashMap\u003c\u0026'static str, Box\u003cdyn NonPrimitiveTrace\u003cF\u003e\u003e\u003e =\n            HashMap::new();\n        for generator in self.circuit.non_primitive_trace_generators.values() {\n            if let Some(trace) = generator(\n                \u0026self.circuit,\n                \u0026self.witness,\n                \u0026self.non_primitive_op_private_data,\n            )? {\n                let id = trace.id();\n                non_primitive_traces.insert(id, trace);\n            }\n        }\n\n        Ok(Traces {\n            witness_trace,\n            const_trace,\n            public_trace,\n            add_trace,\n            mul_trace,\n            non_primitive_traces,\n        })\n    }\n\n    /// Executes the full circuit operation list to populate witness table.\n    ///\n    /// The circuit is already lowered into a valid execution order, so this function\n    /// can blindly execute from index 0 to end.\n    fn execute_all(\u0026mut self) -\u003e Result\u003c(), CircuitError\u003e {\n        // Clone ops to avoid borrowing issues.\n        let ops = self.circuit.ops.clone();\n\n        // Global chaining state for Poseidon2 permutation\n        let mut last_poseidon: Option\u003c[F; 4]\u003e = None;\n\n        for op in ops {\n            match op {\n                Op::Const { out, val } =\u003e {\n                    self.set_witness(out, val)?;\n                }\n                Op::Public { out, public_pos: _ } =\u003e {\n                    // Public inputs should already be set\n                    if self.witness[out.0 as usize].is_none() {\n                        return Err(CircuitError::PublicInputNotSet { witness_id: out });\n                    }\n                }\n                Op::Add { a, b, out } =\u003e {\n                    let a_val = self.get_witness(a)?;\n                    if let Ok(b_val) = self.get_witness(b) {\n                        let result = a_val + b_val;\n                        self.set_witness(out, result)?;\n                    } else {\n                        let out_val = self.get_witness(out)?;\n                        let b_val = out_val - a_val;\n                        self.set_witness(b, b_val)?;\n                    }\n                }\n                Op::Mul { a, b, out } =\u003e {\n                    // Mul is used to represent either `Mul` or `Div` operations.\n                    // We determine which based on which inputs are set.\n                    let a_val = self.get_witness(a)?;\n                    if let Ok(b_val) = self.get_witness(b) {\n                        let result = a_val * b_val;\n                        self.set_witness(out, result)?;\n                    } else {\n                        let result_val = self.get_witness(out)?;\n                        let a_inv = a_val.try_inverse().ok_or(CircuitError::DivisionByZero)?;\n                        let b_val = result_val * a_inv;\n                        self.set_witness(b, b_val)?;\n                    }\n                }\n                Op::Unconstrained {\n                    inputs,\n                    outputs,\n                    filler,\n                } =\u003e {\n                    let inputs_val = inputs\n                        .iter()\n                        .map(|\u0026input| self.get_witness(input))\n                        .collect::\u003cResult\u003cVec\u003cF\u003e, _\u003e\u003e()?;\n                    let outputs_val = filler.compute_outputs(inputs_val)?;\n\n                    for (\u0026output, \u0026output_val) in zip_eq(\n                        outputs.iter(),\n                        outputs_val.iter(),\n                        CircuitError::UnconstrainedOpInputLengthMismatch {\n                            op: \"equal to\".to_string(),\n                            expected: outputs.len(),\n                            got: outputs_val.len(),\n                        },\n                    )? {\n                        self.set_witness(output, output_val)?;\n                    }\n                }\n                Op::NonPrimitiveOpWithExecutor {\n                    inputs,\n                    outputs,\n                    executor,\n                    op_id,\n                } =\u003e {\n                    let mut ctx = ExecutionContext::new(\n                        \u0026mut self.witness,\n                        \u0026self.non_primitive_op_private_data,\n                        \u0026self.circuit.enabled_ops,\n                        op_id,\n                        \u0026mut last_poseidon,\n                    );\n\n                    executor.execute(\u0026inputs, \u0026outputs, \u0026mut ctx)?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Gets witness value by ID.\n    fn get_witness(\u0026self, widx: WitnessId) -\u003e Result\u003cF, CircuitError\u003e {\n        self.witness\n            .get(widx.0 as usize)\n            .and_then(|opt| opt.as_ref())\n            .cloned()\n            .ok_or(CircuitError::WitnessNotSet { witness_id: widx })\n    }\n\n    /// Sets witness value by ID.\n    fn set_witness(\u0026mut self, widx: WitnessId, value: F) -\u003e Result\u003c(), CircuitError\u003e {\n        if widx.0 as usize \u003e= self.witness.len() {\n            return Err(CircuitError::WitnessIdOutOfBounds { witness_id: widx });\n        }\n\n        // Check for conflicting reassignment\n        if let Some(existing_value) = self.witness[widx.0 as usize] {\n            if existing_value != value {\n                return Err(CircuitError::WitnessConflict {\n                    witness_id: widx,\n                    existing: format!(\"{existing_value:?}\"),\n                    new: format!(\"{value:?}\"),\n                });\n            }\n        } else {\n            self.witness[widx.0 as usize] = Some(value);\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    extern crate std;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\n    use tracing_forest::ForestLayer;\n    use tracing_forest::util::LevelFilter;\n    use tracing_subscriber::layer::SubscriberExt;\n    use tracing_subscriber::util::SubscriberInitExt;\n    use tracing_subscriber::{EnvFilter, Registry};\n\n    use crate::ExprId;\n    use crate::builder::CircuitBuilder;\n    use crate::op::WitnessHintsFiller;\n    use crate::types::WitnessId;\n\n    /// Initializes a global logger with default parameters.\n    fn init_logger() {\n        let env_filter = EnvFilter::builder()\n            .with_default_directive(LevelFilter::INFO.into())\n            .from_env_lossy();\n\n        Registry::default()\n            .with(env_filter)\n            .with(ForestLayer::default())\n            .init();\n    }\n\n    #[test]\n    fn test_table_generation_basic() {\n        let mut builder = CircuitBuilder::new();\n\n        // Simple test: x + 5 = result\n        let x = builder.add_public_input();\n        let c5 = builder.add_const(BabyBear::from_u64(5));\n        let _result = builder.add(x, c5);\n\n        let circuit = builder.build().unwrap();\n        let mut runner = circuit.runner();\n\n        // Set public input: x = 3\n        runner.set_public_inputs(\u0026[BabyBear::from_u64(3)]).unwrap();\n\n        let traces = runner.run().unwrap();\n\n        // Check witness trace\n        assert_eq!(\n            traces.witness_trace.index.len(),\n            traces.witness_trace.values.len()\n        );\n\n        // Check that we have const trace entries\n        assert!(!traces.const_trace.values.is_empty());\n\n        // Check that we have public trace entries\n        assert!(!traces.public_trace.values.is_empty());\n\n        // Check that we have add trace entries\n        assert!(!traces.add_trace.lhs_values.is_empty());\n    }\n\n    #[derive(Debug, Clone)]\n    /// The hint defined by x in an equation a*x - b = 0\n    struct XHint {\n        inputs: Vec\u003cExprId\u003e,\n    }\n\n    impl XHint {\n        pub fn new(a: ExprId, b: ExprId) -\u003e Self {\n            Self { inputs: vec![a, b] }\n        }\n    }\n\n    impl\u003cF: Field\u003e WitnessHintsFiller\u003cF\u003e for XHint {\n        fn inputs(\u0026self) -\u003e \u0026[ExprId] {\n            \u0026self.inputs\n        }\n\n        fn n_outputs(\u0026self) -\u003e usize {\n            1\n        }\n\n        fn compute_outputs(\u0026self, inputs_val: Vec\u003cF\u003e) -\u003e Result\u003cVec\u003cF\u003e, crate::CircuitError\u003e {\n            if inputs_val.len() != self.inputs.len() {\n                Err(crate::CircuitError::UnconstrainedOpInputLengthMismatch {\n                    op: \"equal to\".to_string(),\n                    expected: self.inputs.len(),\n                    got: inputs_val.len(),\n                })\n            } else {\n                let a = inputs_val[0];\n                let b = inputs_val[1];\n                let inv_a = a.try_inverse().ok_or(CircuitError::DivisionByZero)?;\n                let x = b * inv_a;\n                Ok(vec![x])\n            }\n        }\n    }\n\n    #[test]\n    // Proves that we know x such that 37 * x - 111 = 0\n    fn test_toy_example_37_times_x_minus_111() {\n        init_logger();\n\n        let mut builder = CircuitBuilder::new();\n\n        let c37 = builder.add_const(BabyBear::from_u64(37));\n        let c111 = builder.add_const(BabyBear::from_u64(111));\n        let x_hint = XHint::new(c37, c111);\n        let x = builder.alloc_witness_hints(x_hint, \"x\")[0];\n\n        let mul_result = builder.mul(c37, x);\n        let sub_result = builder.sub(mul_result, c111);\n        builder.assert_zero(sub_result);\n\n        let circuit = builder.build().unwrap();\n\n        let witness_count = circuit.witness_count;\n        let runner = circuit.runner();\n\n        let traces = runner.run().unwrap();\n\n        traces.dump_primitive_traces_log();\n\n        // Verify trace structure\n        assert_eq!(traces.witness_trace.index.len(), witness_count as usize);\n\n        // Should have constants: 0, 37, 111\n        assert_eq!(traces.const_trace.values.len(), 3);\n\n        // Should have no public input\n        assert!(traces.public_trace.values.is_empty());\n\n        // Should store the value of the hint (3) at `WitnessId(3)``\n        assert_eq!(traces.witness_trace.index[3], WitnessId(3));\n        assert_eq!(traces.witness_trace.values[3], BabyBear::from_usize(3));\n\n        // Should have one mul operation: 37 * x\n        assert_eq!(traces.mul_trace.lhs_values.len(), 1);\n\n        // Encoded subtraction lands in the add table (result + rhs = lhs).\n        assert_eq!(traces.add_trace.lhs_values.len(), 1);\n        assert_eq!(traces.add_trace.lhs_index, vec![WitnessId(2)]);\n        assert_eq!(traces.add_trace.rhs_index, vec![WitnessId(0)]);\n        assert_eq!(traces.add_trace.result_index, vec![WitnessId(4)]);\n    }\n\n    #[test]\n    fn test_extension_field_support() {\n        type ExtField = BinomialExtensionField\u003cBabyBear, 4\u003e;\n\n        let mut builder = CircuitBuilder::new();\n\n        // Test extension field operations: x + y * z\n        let x = builder.add_public_input();\n        let y = builder.add_public_input();\n        let z = builder.add_public_input();\n\n        let yz = builder.mul(y, z);\n        let _result = builder.add(x, yz);\n\n        let circuit = builder.build().unwrap();\n        let mut runner = circuit.runner();\n\n        // Set public inputs to genuine extension field values with ALL non-zero coefficients\n        let x_val = ExtField::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(1), // a0\n            BabyBear::from_u64(2), // a1\n            BabyBear::from_u64(3), // a2\n            BabyBear::from_u64(4), // a3\n        ])\n        .unwrap();\n        let y_val = ExtField::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(5), // b0\n            BabyBear::from_u64(6), // b1\n            BabyBear::from_u64(7), // b2\n            BabyBear::from_u64(8), // b3\n        ])\n        .unwrap();\n        let z_val = ExtField::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(9),  // c0\n            BabyBear::from_u64(10), // c1\n            BabyBear::from_u64(11), // c2\n            BabyBear::from_u64(12), // c3\n        ])\n        .unwrap();\n\n        runner.set_public_inputs(\u0026[x_val, y_val, z_val]).unwrap();\n        let traces = runner.run().unwrap();\n\n        // Verify extension field traces were generated correctly\n        assert_eq!(traces.public_trace.values.len(), 3);\n        assert_eq!(traces.public_trace.values[0], x_val);\n        assert_eq!(traces.public_trace.values[1], y_val);\n        assert_eq!(traces.public_trace.values[2], z_val);\n\n        // Should have one mul and one add operation\n        assert_eq!(traces.mul_trace.lhs_values.len(), 1);\n        assert_eq!(traces.add_trace.lhs_values.len(), 1);\n\n        // Verify mul operation: y * z with genuine extension field multiplication\n        let expected_yz = y_val * z_val;\n        assert_eq!(traces.mul_trace.lhs_values[0], y_val);\n        assert_eq!(traces.mul_trace.rhs_values[0], z_val);\n        assert_eq!(traces.mul_trace.result_values[0], expected_yz);\n\n        // Verify add operation: x + yz with genuine extension field addition\n        let expected_result = x_val + expected_yz;\n        assert_eq!(traces.add_trace.lhs_values[0], x_val);\n        assert_eq!(traces.add_trace.rhs_values[0], expected_yz);\n        assert_eq!(traces.add_trace.result_values[0], expected_result);\n    }\n}\n","traces":[{"line":35,"address":[6756480,6759637,6758064,6759555,6757963,6758047],"length":1,"stats":{"Line":16}},{"line":36,"address":[3131759],"length":1,"stats":{"Line":19}},{"line":37,"address":[2253769],"length":1,"stats":{"Line":17}},{"line":38,"address":[4526959,4526883],"length":1,"stats":{"Line":36}},{"line":39,"address":[2426513,2426576,2425326],"length":1,"stats":{"Line":18}},{"line":40,"address":[8001954,8005640,8005400,8000360,7998768,8005616,8005240,8005376,8005216,8005688,8005136,8005352,8003544,8005664,8005328],"length":1,"stats":{"Line":0}},{"line":43,"address":[4528352,4528360,4527125],"length":1,"stats":{"Line":16}},{"line":45,"address":[6756898,6758493],"length":1,"stats":{"Line":18}},{"line":46,"address":[2425452,2425519],"length":1,"stats":{"Line":32}},{"line":47,"address":[4527915,4527505],"length":1,"stats":{"Line":15}},{"line":48,"address":[2254828],"length":1,"stats":{"Line":0}},{"line":50,"address":[2426305],"length":1,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[3133184,3133087,3133214],"length":1,"stats":{"Line":0}},{"line":58,"address":[8003499,8000315,7998723,8001909,8005091],"length":1,"stats":{"Line":0}},{"line":63,"address":[2254457],"length":1,"stats":{"Line":17}},{"line":73,"address":[7994176,7994816,7996032,7995440,7996656],"length":1,"stats":{"Line":15}},{"line":74,"address":[2253080],"length":1,"stats":{"Line":15}},{"line":75,"address":[1743273],"length":1,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[3337926,3337334],"length":1,"stats":{"Line":15}},{"line":81,"address":[2424650],"length":1,"stats":{"Line":0}},{"line":84,"address":[2253318,2253193],"length":1,"stats":{"Line":32}},{"line":85,"address":[4526575],"length":1,"stats":{"Line":16}},{"line":86,"address":[3131540,3131661],"length":1,"stats":{"Line":16}},{"line":89,"address":[1743661],"length":1,"stats":{"Line":16}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[2426720,2431458,2431210],"length":1,"stats":{"Line":17}},{"line":154,"address":[6765568,6760056,6769308,6764840,6760784,6764524],"length":1,"stats":{"Line":34}},{"line":157,"address":[3263966,3260367],"length":1,"stats":{"Line":15}},{"line":158,"address":[4533056,4529901,4529822],"length":1,"stats":{"Line":33}},{"line":159,"address":[1747182,1750015,1747285],"length":1,"stats":{"Line":32}},{"line":160,"address":[4530763,4530660,4533022],"length":1,"stats":{"Line":32}},{"line":161,"address":[1748192,1749981,1748092],"length":1,"stats":{"Line":34}},{"line":163,"address":[2429804],"length":1,"stats":{"Line":15}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[8013739,8008915,8018491,8013667,8027995,8023171,8018419,8023243,8027923,8008987],"length":1,"stats":{"Line":31}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[1749387],"length":1,"stats":{"Line":0}},{"line":171,"address":[8024387,8029139,8019550,8024302,8029054,8014883,8010046,8014798,8019635,8010131],"length":1,"stats":{"Line":0}},{"line":172,"address":[3351011,3346259],"length":1,"stats":{"Line":0}},{"line":176,"address":[2430243],"length":1,"stats":{"Line":16}},{"line":177,"address":[2430087],"length":1,"stats":{"Line":16}},{"line":178,"address":[2258753],"length":1,"stats":{"Line":15}},{"line":179,"address":[6763335,6768119],"length":1,"stats":{"Line":16}},{"line":180,"address":[1748885],"length":1,"stats":{"Line":15}},{"line":181,"address":[8009247,8013999,8028255,8023503,8018751],"length":1,"stats":{"Line":16}},{"line":182,"address":[8014025,8023529,8018777,8028281,8009273],"length":1,"stats":{"Line":15}},{"line":190,"address":[4519040,4520875,4525181],"length":1,"stats":{"Line":17}},{"line":192,"address":[],"length":0,"stats":{"Line":19}},{"line":195,"address":[2416955],"length":1,"stats":{"Line":17}},{"line":197,"address":[],"length":0,"stats":{"Line":32}},{"line":198,"address":[7976259,7983040,7963459,7969860,7957296],"length":1,"stats":{"Line":15}},{"line":199,"address":[7963580,7969981,7976380,7957417,7983161],"length":1,"stats":{"Line":17}},{"line":200,"address":[3329290,3329863,3323133,3323674],"length":1,"stats":{"Line":32}},{"line":202,"address":[2246076],"length":1,"stats":{"Line":15}},{"line":204,"address":[],"length":0,"stats":{"Line":30}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[3329403,3323214],"length":1,"stats":{"Line":16}},{"line":209,"address":[1737325,1738271,1736670],"length":1,"stats":{"Line":30}},{"line":210,"address":[7964612,7971065,7984231,7984172,7958428,7964664,7971013,7977460,7958487,7977512],"length":1,"stats":{"Line":31}},{"line":211,"address":[],"length":0,"stats":{"Line":21}},{"line":212,"address":[3330478,3324272],"length":1,"stats":{"Line":15}},{"line":214,"address":[3125542,3125982],"length":1,"stats":{"Line":11}},{"line":215,"address":[3251632],"length":1,"stats":{"Line":11}},{"line":216,"address":[2419070],"length":1,"stats":{"Line":11}},{"line":219,"address":[3250221],"length":1,"stats":{"Line":14}},{"line":222,"address":[4522506,4519776,4521316],"length":1,"stats":{"Line":28}},{"line":223,"address":[7965750,7978706,7959395,7978758,7959447,7985191,7965698,7972151,7985139,7972099],"length":1,"stats":{"Line":28}},{"line":224,"address":[2248182],"length":1,"stats":{"Line":19}},{"line":225,"address":[6743271,6749580],"length":1,"stats":{"Line":14}},{"line":227,"address":[2248542,2249215],"length":1,"stats":{"Line":7}},{"line":228,"address":[2420088,2420570],"length":1,"stats":{"Line":7}},{"line":229,"address":[2248940],"length":1,"stats":{"Line":7}},{"line":230,"address":[2420378],"length":1,"stats":{"Line":7}},{"line":233,"address":[3124407],"length":1,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[3332752,3332646,3329663,3326252,3326358,3328080,3323474,3334484],"length":1,"stats":{"Line":12}},{"line":240,"address":[2423280,2420696,2423302],"length":1,"stats":{"Line":18}},{"line":242,"address":[3255200,3253722,3253585],"length":1,"stats":{"Line":12}},{"line":244,"address":[],"length":0,"stats":{"Line":6}},{"line":245,"address":[3253925,3254004],"length":1,"stats":{"Line":12}},{"line":246,"address":[1740333],"length":1,"stats":{"Line":6}},{"line":247,"address":[6751610,6745236],"length":1,"stats":{"Line":6}},{"line":248,"address":[7987099,7974146,7967745,7961355,7980897],"length":1,"stats":{"Line":6}},{"line":249,"address":[6745106,6751480],"length":1,"stats":{"Line":6}},{"line":250,"address":[2421627],"length":1,"stats":{"Line":6}},{"line":253,"address":[6752290,6745894,6745716,6752084],"length":1,"stats":{"Line":12}},{"line":256,"address":[6747745,6741572],"length":1,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[6747830,6741657],"length":1,"stats":{"Line":0}},{"line":264,"address":[7982101,7988261,7975322,7968921,7962517],"length":1,"stats":{"Line":0}},{"line":265,"address":[3334660,3328256],"length":1,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[3129512],"length":1,"stats":{"Line":0}},{"line":274,"address":[7969949,7957385,7976348,7963548,7983129],"length":1,"stats":{"Line":15}},{"line":278,"address":[3255968],"length":1,"stats":{"Line":17}},{"line":279,"address":[1742262],"length":1,"stats":{"Line":16}},{"line":280,"address":[1742284],"length":1,"stats":{"Line":18}},{"line":281,"address":[3130128,3130208,3130217],"length":1,"stats":{"Line":49}},{"line":283,"address":[3256075],"length":1,"stats":{"Line":17}},{"line":287,"address":[7990893,7992640,7991755,7992617,7990912,7993382,7991776,7993376,7993408,7989984,7994144,7994150],"length":1,"stats":{"Line":19}},{"line":288,"address":[2423574],"length":1,"stats":{"Line":17}},{"line":289,"address":[2423664],"length":1,"stats":{"Line":0}},{"line":293,"address":[7990170,7993502,7993588,7990079,7992820,7991962,7991007,7991871,7992734,7991097],"length":1,"stats":{"Line":34}},{"line":294,"address":[2252370],"length":1,"stats":{"Line":15}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[3130760,3130827],"length":1,"stats":{"Line":0}},{"line":302,"address":[3256410],"length":1,"stats":{"Line":16}},{"line":305,"address":[3130617],"length":1,"stats":{"Line":18}}],"covered":83,"coverable":156},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","tables","witness.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::CircuitError;\nuse crate::types::WitnessId;\n\n/// Central witness table.\n///\n/// Primary storage for all intermediate values in the circuit.\n/// Acts as the \"bus\" that all operation tables reference.\n/// Witnesses have sequential IDs starting from 0.\n#[derive(Debug, Clone)]\npub struct WitnessTrace\u003cF\u003e {\n    /// Sequential witness IDs: WitnessId(0), WitnessId(1), WitnessId(2), ...\n    ///\n    /// Forms a preprocessed column for lookups from other tables.\n    pub index: Vec\u003cWitnessId\u003e,\n\n    /// Witness field element values.\n    ///\n    /// Each value is one computation result.\n    /// Computed during circuit execution.\n    pub values: Vec\u003cF\u003e,\n}\n\n/// Builder for generating witness traces.\npub struct WitnessTraceBuilder\u003c'a, F\u003e {\n    witness: \u0026'a [Option\u003cF\u003e],\n}\n\nimpl\u003c'a, F: Clone\u003e WitnessTraceBuilder\u003c'a, F\u003e {\n    /// Creates a new witness trace builder.\n    pub const fn new(witness: \u0026'a [Option\u003cF\u003e]) -\u003e Self {\n        Self { witness }\n    }\n\n    /// Builds the witness trace from the populated witness table.\n    pub fn build(self) -\u003e Result\u003cWitnessTrace\u003cF\u003e, CircuitError\u003e {\n        let mut index = Vec::new();\n        let mut values = Vec::new();\n\n        for (i, witness_opt) in self.witness.iter().enumerate() {\n            match witness_opt {\n                Some(value) =\u003e {\n                    index.push(WitnessId(i as u32));\n                    values.push(value.clone());\n                }\n                None =\u003e {\n                    return Err(CircuitError::WitnessNotSetForIndex { index: i });\n                }\n            }\n        }\n\n        Ok(WitnessTrace { index, values })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    type F = BabyBear;\n\n    #[test]\n    fn test_single_witness() {\n        // Create a witness table with a single value\n        let val = F::from_u64(42);\n        let witness = vec![Some(val)];\n\n        // Build the trace using the builder pattern\n        let builder = WitnessTraceBuilder::new(\u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace contains exactly one witness\n        assert_eq!(trace.index.len(), 1, \"Should have one witness entry\");\n        assert_eq!(trace.values.len(), 1, \"Should have one witness value\");\n\n        // Verify the witness is correctly recorded with sequential index\n        assert_eq!(trace.index[0], WitnessId(0));\n        assert_eq!(trace.values[0], val);\n    }\n\n    #[test]\n    fn test_multiple_witnesses() {\n        // Create a witness table with multiple values\n        let val1 = F::from_u64(10);\n        let val2 = F::from_u64(20);\n        let val3 = F::from_u64(30);\n\n        let witness = vec![Some(val1), Some(val2), Some(val3)];\n\n        // Build the trace\n        let builder = WitnessTraceBuilder::new(\u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify we have exactly three witnesses\n        assert_eq!(trace.index.len(), 3, \"Should have three witness entries\");\n        assert_eq!(trace.values.len(), 3, \"Should have three witness values\");\n\n        // Verify indices are sequential starting from 0\n        assert_eq!(trace.index[0], WitnessId(0));\n        assert_eq!(trace.index[1], WitnessId(1));\n        assert_eq!(trace.index[2], WitnessId(2));\n\n        // Verify values match the input order\n        assert_eq!(trace.values[0], val1);\n        assert_eq!(trace.values[1], val2);\n        assert_eq!(trace.values[2], val3);\n    }\n\n    #[test]\n    fn test_empty_witness() {\n        // Provide an empty witness table\n        let witness: Vec\u003cOption\u003cF\u003e\u003e = vec![];\n\n        // Build the trace\n        let builder = WitnessTraceBuilder::new(\u0026witness);\n        let trace = builder.build().expect(\"Failed to build trace\");\n\n        // Verify the trace is empty\n        assert_eq!(trace.index.len(), 0, \"Should have no witness entries\");\n        assert_eq!(trace.values.len(), 0, \"Should have no values\");\n    }\n\n    #[test]\n    fn test_witness_not_set_error() {\n        // Create a witness table with an unset slot in the middle\n        let witness: Vec\u003cOption\u003cF\u003e\u003e = vec![Some(F::from_u64(10)), None, Some(F::from_u64(30))];\n\n        // Attempt to build the trace\n        let builder = WitnessTraceBuilder::new(\u0026witness);\n        let result = builder.build();\n\n        // Verify the build fails with the expected error at index 1\n        assert!(result.is_err(), \"Should fail when witness slot is not set\");\n        assert!(matches!(\n            result,\n            Err(CircuitError::WitnessNotSetForIndex { index: 1 })\n        ));\n    }\n}\n","traces":[{"line":32,"address":[4321648],"length":1,"stats":{"Line":16}},{"line":37,"address":[3165744,3166608,3167441,3166575,3167435,3166581],"length":1,"stats":{"Line":15}},{"line":38,"address":[3166656,3165792],"length":1,"stats":{"Line":16}},{"line":39,"address":[3165797,3166666],"length":1,"stats":{"Line":15}},{"line":41,"address":[2288244,2288313],"length":1,"stats":{"Line":32}},{"line":42,"address":[2618643],"length":1,"stats":{"Line":17}},{"line":43,"address":[2427863],"length":1,"stats":{"Line":15}},{"line":44,"address":[3166416,3167272],"length":1,"stats":{"Line":17}},{"line":45,"address":[7263926,7264774],"length":1,"stats":{"Line":15}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[2288816],"length":1,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":17}}],"covered":11,"coverable":12},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","test_utils.rs"],"content":"use core::borrow::Borrow;\n\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, BaseAir};\nuse p3_field::PrimeField64;\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\n\npub struct FibonacciAir {}\n\npub const NUM_FIBONACCI_COLS: usize = 2;\n\nimpl\u003cF\u003e BaseAir\u003cF\u003e for FibonacciAir {\n    fn width(\u0026self) -\u003e usize {\n        NUM_FIBONACCI_COLS\n    }\n}\n\nimpl\u003cAB: AirBuilderWithPublicValues\u003e Air\u003cAB\u003e for FibonacciAir {\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n\n        let pis = builder.public_values();\n\n        let a = pis[0];\n        let b = pis[1];\n        let x = pis[2];\n\n        let (local, next) = (\n            main.row_slice(0).expect(\"Matrix is empty?\"),\n            main.row_slice(1).expect(\"Matrix only has 1 row?\"),\n        );\n        let local: \u0026FibonacciRow\u003cAB::Var\u003e = (*local).borrow();\n        let next: \u0026FibonacciRow\u003cAB::Var\u003e = (*next).borrow();\n\n        let mut when_first_row = builder.when_first_row();\n\n        when_first_row.assert_eq(local.left.clone(), a);\n        when_first_row.assert_eq(local.right.clone(), b);\n\n        let mut when_transition = builder.when_transition();\n\n        // a' \u003c- b\n        when_transition.assert_eq(local.right.clone(), next.left.clone());\n\n        // b' \u003c- a + b\n        when_transition.assert_eq(local.left.clone() + local.right.clone(), next.right.clone());\n\n        builder.when_last_row().assert_eq(local.right.clone(), x);\n    }\n}\n\npub fn generate_trace_rows\u003cF: PrimeField64\u003e(a: u64, b: u64, n: usize) -\u003e RowMajorMatrix\u003cF\u003e {\n    assert!(n.is_power_of_two());\n\n    let mut trace = RowMajorMatrix::new(F::zero_vec(n * NUM_FIBONACCI_COLS), NUM_FIBONACCI_COLS);\n\n    let (prefix, rows, suffix) = unsafe { trace.values.align_to_mut::\u003cFibonacciRow\u003cF\u003e\u003e() };\n    assert!(prefix.is_empty(), \"Alignment should match\");\n    assert!(suffix.is_empty(), \"Alignment should match\");\n    assert_eq!(rows.len(), n);\n\n    rows[0] = FibonacciRow::new(F::from_u64(a), F::from_u64(b));\n\n    for i in 1..n {\n        rows[i].left = rows[i - 1].right;\n        rows[i].right = rows[i - 1].left + rows[i - 1].right;\n    }\n\n    trace\n}\n\npub struct FibonacciRow\u003cF\u003e {\n    pub left: F,\n    pub right: F,\n}\n\nimpl\u003cF\u003e FibonacciRow\u003cF\u003e {\n    const fn new(left: F, right: F) -\u003e Self {\n        Self { left, right }\n    }\n}\n\nimpl\u003cF\u003e Borrow\u003cFibonacciRow\u003cF\u003e\u003e for [F] {\n    fn borrow(\u0026self) -\u003e \u0026FibonacciRow\u003cF\u003e {\n        debug_assert_eq!(self.len(), NUM_FIBONACCI_COLS);\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cFibonacciRow\u003cF\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026shorts[0]\n    }\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":4}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":7}},{"line":20,"address":[],"length":0,"stats":{"Line":7}},{"line":22,"address":[],"length":0,"stats":{"Line":14}},{"line":24,"address":[2122153,2122075,2118881,2125529,2120406,2118822,2123968,2123921,2120465,2125451],"length":1,"stats":{"Line":7}},{"line":25,"address":[7422367,7420609,7422418,7422449,7420665,7420549],"length":1,"stats":{"Line":14}},{"line":26,"address":[7420645,7422432,7422520,7422477,7420696,7420760],"length":1,"stats":{"Line":14}},{"line":28,"address":[],"length":0,"stats":{"Line":7}},{"line":29,"address":[],"length":0,"stats":{"Line":14}},{"line":30,"address":[],"length":0,"stats":{"Line":14}},{"line":32,"address":[2119402,2124402,2121060,2124456,2122720,2121006,2122666,2126042,2126096,2119342],"length":1,"stats":{"Line":14}},{"line":33,"address":[2126129,2119435,2124489,2121093,2122753],"length":1,"stats":{"Line":7}},{"line":35,"address":[],"length":0,"stats":{"Line":7}},{"line":37,"address":[2119597,2122841,2124628,2119540,2126264,2126217,2124574,2121255,2122888,2121198],"length":1,"stats":{"Line":14}},{"line":38,"address":[2124640,2122956,2121267,2119609,2126332],"length":1,"stats":{"Line":7}},{"line":40,"address":[2119658,2121316,2126430,2124699,2123054],"length":1,"stats":{"Line":7}},{"line":43,"address":[2119703,2119769,2123153,2121879,2124711,2126506,2121408,2121427,2123130,2124762,2123747,2125256,2126442,2126529,2120223,2119750,2124785,2127123,2121361,2123066],"length":1,"stats":{"Line":14}},{"line":46,"address":[],"length":0,"stats":{"Line":7}},{"line":48,"address":[],"length":0,"stats":{"Line":7}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[2042308,2042185],"length":1,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[2042514,2042594],"length":1,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[2042663,2042752],"length":1,"stats":{"Line":1}},{"line":62,"address":[2042949,2042827],"length":1,"stats":{"Line":1}},{"line":64,"address":[],"length":0,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[2043610,2043302,2043363],"length":1,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[2043664],"length":1,"stats":{"Line":1}},{"line":84,"address":[3120608],"length":1,"stats":{"Line":6}},{"line":85,"address":[3120641],"length":1,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[6732771],"length":1,"stats":{"Line":6}},{"line":88,"address":[3120928],"length":1,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":6}}],"covered":39,"coverable":40},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","types.rs"],"content":"use core::fmt;\n\nuse serde::{Deserialize, Serialize};\n\n/// Witness ID type - a unique identifier for extension field values in the global witness bus\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]\npub struct WitnessId(pub u32);\n\nimpl fmt::Display for WitnessId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"w{}\", self.0)\n    }\n}\n\n/// Handle to an expression in the graph\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct ExprId(pub u32);\n\nimpl fmt::Display for ExprId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"e{}\", self.0)\n    }\n}\n\nimpl ExprId {\n    /// The zero expression ID - always points to Const(0)\n    pub const ZERO: Self = Self(0);\n}\n\n/// Handle to a non-primitive operation (for setting private data later)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct NonPrimitiveOpId(pub u32);\n\nimpl fmt::Display for NonPrimitiveOpId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"id{}\", self.0)\n    }\n}\n\n/// Witness allocator for monotonic index assignment\n#[derive(Debug, Clone, Default)]\npub struct WitnessAllocator {\n    next_idx: u32,\n}\n\nimpl WitnessAllocator {\n    pub const fn new() -\u003e Self {\n        Self { next_idx: 0 }\n    }\n\n    pub const fn alloc(\u0026mut self) -\u003e WitnessId {\n        let idx = WitnessId(self.next_idx);\n        self.next_idx += 1;\n        idx\n    }\n\n    pub const fn witness_count(\u0026self) -\u003e u32 {\n        self.next_idx\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::format;\n\n    use super::*;\n\n    #[test]\n    fn test_witness_id_display() {\n        let idx = WitnessId(42);\n        assert_eq!(format!(\"{idx}\"), \"w42\");\n    }\n\n    #[test]\n    fn test_witness_allocator() {\n        let mut allocator = WitnessAllocator::new();\n\n        let w0 = allocator.alloc();\n        let w1 = allocator.alloc();\n        let w2 = allocator.alloc();\n\n        assert_eq!(w0, WitnessId(0));\n        assert_eq!(w1, WitnessId(1));\n        assert_eq!(w2, WitnessId(2));\n        assert_eq!(allocator.witness_count(), 3);\n    }\n\n    #[cfg(test)]\n    mod proptests {\n        use proptest::prelude::*;\n\n        use super::*;\n\n        proptest! {\n            #[test]\n            fn witness_id_ordering(a in 0u32..u32::MAX, b in 0u32..u32::MAX) {\n                let id_a = WitnessId(a);\n                let id_b = WitnessId(b);\n\n                if a \u003c b {\n                    prop_assert!(id_a \u003c id_b, \"ordering should match inner value\");\n                } else if a \u003e b {\n                    prop_assert!(id_a \u003e id_b, \"ordering should match inner value\");\n                } else {\n                    prop_assert_eq!(id_a, id_b, \"equal values should compare equal\");\n                }\n            }\n\n            #[test]\n            fn expr_id_ordering(a in 0u32..u32::MAX, b in 0u32..u32::MAX) {\n                let id_a = ExprId(a);\n                let id_b = ExprId(b);\n\n                if a \u003c b {\n                    prop_assert!(id_a \u003c id_b, \"ordering should match inner value\");\n                } else if a \u003e b {\n                    prop_assert!(id_a \u003e id_b, \"ordering should match inner value\");\n                } else {\n                    prop_assert_eq!(id_a, id_b, \"equal values should compare equal\");\n                }\n            }\n\n            #[test]\n            fn non_primitive_op_id_equality(a in 0u32..u32::MAX, b in 0u32..u32::MAX) {\n                let id_a1 = NonPrimitiveOpId(a);\n                let id_a2 = NonPrimitiveOpId(a);\n                let id_b = NonPrimitiveOpId(b);\n\n                prop_assert_eq!(id_a1, id_a2, \"same value should be equal\");\n                if a != b {\n                    prop_assert_ne!(id_a1, id_b, \"different values should not be equal\");\n                }\n            }\n\n            #[test]\n            fn witness_allocator_unique(count in 1usize..100) {\n                let mut allocator = WitnessAllocator::new();\n                let mut seen = hashbrown::HashSet::new();\n\n                for _ in 0..count {\n                    let id = allocator.alloc();\n                    prop_assert!(seen.insert(id), \"each allocation should be unique\");\n                }\n            }\n\n            #[test]\n            fn witness_allocator_count_accurate(count in 0usize..100) {\n                let mut allocator = WitnessAllocator::new();\n\n                prop_assert_eq!(allocator.witness_count(), 0, \"new allocator should have count 0\");\n\n                for i in 1..=count {\n                    allocator.alloc();\n                    prop_assert_eq!(\n                        allocator.witness_count(),\n                        i as u32,\n                        \"count should increment with each allocation\"\n                    );\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":10,"address":[11041856],"length":1,"stats":{"Line":1}},{"line":11,"address":[3939705],"length":1,"stats":{"Line":1}},{"line":20,"address":[4055568],"length":1,"stats":{"Line":0}},{"line":21,"address":[5321209],"length":1,"stats":{"Line":0}},{"line":35,"address":[3940224],"length":1,"stats":{"Line":0}},{"line":36,"address":[3940249],"length":1,"stats":{"Line":0}},{"line":51,"address":[8127104],"length":1,"stats":{"Line":10}},{"line":52,"address":[3925790],"length":1,"stats":{"Line":12}},{"line":53,"address":[2684075,2684040],"length":1,"stats":{"Line":10}},{"line":57,"address":[3403296],"length":1,"stats":{"Line":10}},{"line":58,"address":[3931173],"length":1,"stats":{"Line":10}}],"covered":7,"coverable":11},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit","src","utils.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\n\nuse hashbrown::HashMap;\nuse p3_field::Field;\nuse p3_uni_stark::{Entry, SymbolicExpression};\n\nuse crate::{CircuitBuilder, ExprId};\n\n/// Identifiers for special row selector flags in the circuit.\n#[derive(Clone, Copy, Debug)]\npub struct RowSelectorsTargets {\n    pub is_first_row: ExprId,\n    pub is_last_row: ExprId,\n    pub is_transition: ExprId,\n}\n\n/// Targets for all columns in the circuit.\n#[derive(Clone, Debug)]\npub struct ColumnsTargets\u003c'a\u003e {\n    /// Challenges added to the circuit.\n    pub challenges: \u0026'a [ExprId],\n    /// Public values added to the circuit.\n    pub public_values: \u0026'a [ExprId],\n    /// Targets for the preprocessed values used in the circuit.\n    pub local_prep_values: \u0026'a [ExprId],\n    /// Targets for the preprocessed values evaluated at the next row.\n    pub next_prep_values: \u0026'a [ExprId],\n    /// Targets for the main trace values.\n    pub local_values: \u0026'a [ExprId],\n    /// Targets for the main trace values evaluated at the next row.\n    pub next_values: \u0026'a [ExprId],\n}\n\n/// Given symbolic constraints, adds the corresponding recursive circuit to `circuit`.\n/// The `public_values`, `local_prep_values`, `next_prep_values`, `local_values`, and `next_values`\n/// are assumed to be in the same order as those used to create the symbolic expressions.\n// Recursive approaches blowup quickly, so this takes an iterative DAG approach with\n// some caching of `SymbolicExpression` nodes.\npub fn symbolic_to_circuit\u003cF: Field\u003e(\n    row_selectors: RowSelectorsTargets,\n    columns: \u0026ColumnsTargets\u003c'_\u003e,\n    symbolic: \u0026SymbolicExpression\u003cF\u003e,\n    circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n) -\u003e ExprId {\n    /// Used when iterating through the DAG of expressions\n    /// - `Eval` is used when visiting a node\n    /// - `Build` is used to combine entries for a given `Op`\n    enum Work\u003c'a, F: Field\u003e {\n        Eval(\u0026'a SymbolicExpression\u003cF\u003e),\n        // Store a raw pointer instead of a reference because this removes lifetime handling\n        // and its clear that we never dereference the node.\n        // It binds the expression to the Op and its arity, so we can reuse the same node for different ops.\n        Build(*const SymbolicExpression\u003cF\u003e, Op, usize),\n    }\n\n    /// Arithmetic ops applied when building parent nodes\n    #[derive(Copy, Clone)]\n    enum Op {\n        Add,\n        Sub,\n        Mul,\n        Neg,\n    }\n\n    let RowSelectorsTargets {\n        is_first_row,\n        is_last_row,\n        is_transition,\n    } = row_selectors;\n\n    let ColumnsTargets {\n        challenges,\n        public_values,\n        local_prep_values,\n        next_prep_values,\n        local_values,\n        next_values,\n    } = columns;\n\n    let mut cache: HashMap\u003c*const SymbolicExpression\u003cF\u003e, ExprId\u003e = HashMap::new();\n    let mut tasks = vec![Work::Eval(symbolic)];\n    let mut stack = Vec::new();\n\n    while let Some(work) = tasks.pop() {\n        match work {\n            Work::Eval(expr) =\u003e {\n                let key = expr as *const _;\n                if let Some(\u0026cached) = cache.get(\u0026key) {\n                    stack.push(cached);\n                    continue;\n                }\n                match expr {\n                    SymbolicExpression::Constant(c) =\u003e {\n                        let id = circuit.add_const(*c);\n                        cache.insert(key, id);\n                        stack.push(id);\n                    }\n                    SymbolicExpression::Variable(v) =\u003e {\n                        let get_val =\n                            |offset: usize,\n                             index: usize,\n                             local_vals: \u0026[ExprId],\n                             next_vals: \u0026[ExprId]| match offset {\n                                0 =\u003e local_vals[index],\n                                1 =\u003e next_vals[index],\n                                _ =\u003e {\n                                    panic!(\"Cannot have expressions involving more than two rows.\")\n                                }\n                            };\n                        let id = match v.entry {\n                            Entry::Preprocessed { offset } =\u003e {\n                                get_val(offset, v.index, local_prep_values, next_prep_values)\n                            }\n                            Entry::Main { offset } =\u003e {\n                                get_val(offset, v.index, local_values, next_values)\n                            }\n                            Entry::Public =\u003e public_values[v.index],\n                            Entry::Challenge =\u003e challenges[v.index],\n                            _ =\u003e unimplemented!(),\n                        };\n                        cache.insert(key, id);\n                        stack.push(id);\n                    }\n                    SymbolicExpression::IsFirstRow =\u003e stack.push(is_first_row),\n                    SymbolicExpression::IsLastRow =\u003e stack.push(is_last_row),\n                    SymbolicExpression::IsTransition =\u003e stack.push(is_transition),\n                    SymbolicExpression::Neg { x, .. } =\u003e {\n                        tasks.push(Work::Build(key, Op::Neg, 1));\n                        tasks.push(Work::Eval(x));\n                    }\n                    SymbolicExpression::Add { x, y, .. } =\u003e {\n                        tasks.push(Work::Build(key, Op::Add, 2));\n                        tasks.push(Work::Eval(y));\n                        tasks.push(Work::Eval(x));\n                    }\n                    SymbolicExpression::Sub { x, y, .. } =\u003e {\n                        tasks.push(Work::Build(key, Op::Sub, 2));\n                        tasks.push(Work::Eval(y));\n                        tasks.push(Work::Eval(x));\n                    }\n                    SymbolicExpression::Mul { x, y, .. } =\u003e {\n                        tasks.push(Work::Build(key, Op::Mul, 2));\n                        tasks.push(Work::Eval(y));\n                        tasks.push(Work::Eval(x));\n                    }\n                }\n            }\n            Work::Build(key, op, arity) =\u003e {\n                let rhs = stack.pop().expect(\"rhs\");\n                let lhs = if arity == 2 {\n                    stack.pop().expect(\"lhs\")\n                } else {\n                    rhs // placeholder; for Neg we overwrite below\n                };\n                let id = match op {\n                    Op::Add =\u003e circuit.add(lhs, rhs),\n                    Op::Sub =\u003e circuit.sub(lhs, rhs),\n                    Op::Mul =\u003e circuit.mul(lhs, rhs),\n                    Op::Neg =\u003e {\n                        let zero = circuit.add_const(F::ZERO);\n                        circuit.sub(zero, rhs)\n                    }\n                };\n                cache.insert(key, id);\n                stack.push(id);\n            }\n        }\n    }\n\n    stack.pop().expect(\"final target\")\n}\n\n/// Helper to pad trace values to power-of-two height with zeros\npub fn pad_to_power_of_two\u003cF: Field\u003e(values: \u0026mut Vec\u003cF\u003e, width: usize, original_height: usize) {\n    if original_height == 0 {\n        // Empty trace - just ensure we have at least one row of zeros\n        values.resize(width, F::ZERO);\n        return;\n    }\n\n    let target_height = original_height.next_power_of_two();\n    if target_height == original_height {\n        return; // Already power of two\n    }\n\n    // Pad with zeroes\n    for _ in original_height..target_height {\n        values.extend_from_slice(\u0026vec![F::ZERO; width]);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_air::{Air, BaseAir};\n    use p3_baby_bear::{BabyBear, Poseidon2BabyBear};\n    use p3_challenger::DuplexChallenger;\n    use p3_commit::ExtensionMmcs;\n    use p3_dft::Radix2DitParallel;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_field::integers::QuotientMap;\n    use p3_fri::TwoAdicFriPcs;\n    use p3_matrix::dense::RowMajorMatrixView;\n    use p3_matrix::stack::VerticalPair;\n    use p3_merkle_tree::MerkleTreeMmcs;\n    use p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\n    use p3_uni_stark::{\n        StarkConfig, SymbolicExpression, VerifierConstraintFolder, get_symbolic_constraints,\n    };\n    use rand::rngs::SmallRng;\n    use rand::{RngCore, SeedableRng};\n\n    use super::*;\n\n    type F = BabyBear;\n    const D: usize = 4;\n    type Challenge = BinomialExtensionField\u003cF, D\u003e;\n    type Dft = Radix2DitParallel\u003cF\u003e;\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\n    type MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\n    type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n    type ValMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n    type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n    type Challenger = DuplexChallenger\u003cF, Perm, 16, 8\u003e;\n    type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n    type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n    use p3_field::PrimeCharacteristicRing;\n\n    use crate::test_utils::{FibonacciAir, NUM_FIBONACCI_COLS};\n    use crate::utils::{ColumnsTargets, RowSelectorsTargets, symbolic_to_circuit};\n    use crate::{CircuitBuilder, CircuitError};\n\n    #[test]\n    fn test_symbolic_to_circuit() -\u003e Result\u003c(), CircuitError\u003e {\n        let mut rng = SmallRng::seed_from_u64(1);\n        let x = 21;\n\n        let pis = vec![F::ZERO, F::ONE, F::from_u64(x)];\n        let pis_ext = pis\n            .iter()\n            .map(|c| Challenge::from_prime_subfield(*c))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let air = FibonacciAir {};\n\n        let alpha = Challenge::from_u64(rng.next_u64());\n\n        // Let us simulate the constraints folding.\n        // First, get random values for the trace.\n        let width = \u003cFibonacciAir as BaseAir\u003cF\u003e\u003e::width(\u0026air);\n        let mut trace_local = Vec::with_capacity(width);\n        let mut trace_next = Vec::with_capacity(width);\n        for _ in 0..width {\n            trace_local.push(Challenge::from_prime_subfield(F::from_int(rng.next_u64())));\n            trace_next.push(Challenge::from_prime_subfield(F::from_int(rng.next_u64())));\n        }\n        let main = VerticalPair::new(\n            RowMajorMatrixView::new_row(\u0026trace_local),\n            RowMajorMatrixView::new_row(\u0026trace_next),\n        );\n\n        // Get random values for the selectors.\n        let sels = [\n            Challenge::from_u64(rng.next_u64()),\n            Challenge::from_u64(rng.next_u64()),\n            Challenge::from_u64(rng.next_u64()),\n        ];\n\n        // Fold the constraints using random values for the trace and selectors.\n        let mut folder: VerifierConstraintFolder\u003c'_, MyConfig\u003e = VerifierConstraintFolder {\n            main,\n            preprocessed: None,\n            public_values: \u0026pis,\n            is_first_row: sels[0],\n            is_last_row: sels[1],\n            is_transition: sels[2],\n            alpha,\n            accumulator: Challenge::ZERO,\n        };\n        air.eval(\u0026mut folder);\n        let folded_constraints = folder.accumulator;\n\n        // Get the symbolic constraints from `FibonacciAir`.\n        let symbolic_constraints: Vec\u003cp3_uni_stark::SymbolicExpression\u003cChallenge\u003e\u003e =\n            get_symbolic_constraints(\u0026air, 0, pis.len());\n\n        // Fold the symbolic constraints using `alpha`.\n        let folded_symbolic_constraints = {\n            let mut acc = SymbolicExpression::\u003cChallenge\u003e::Constant(Challenge::ZERO);\n            let ch = SymbolicExpression::Constant(alpha);\n            for s_c in symbolic_constraints.iter() {\n                acc = ch.clone() * acc;\n                acc += s_c.clone();\n            }\n            acc\n        };\n\n        // Build a circuit adding public inputs for `sels`, public values, local values and next values.\n        let mut circuit = CircuitBuilder::new();\n        let circuit_sels = [\n            circuit.add_public_input(),\n            circuit.add_public_input(),\n            circuit.add_public_input(),\n        ];\n        let circuit_public_values = [\n            circuit.add_public_input(),\n            circuit.add_public_input(),\n            circuit.add_public_input(),\n        ];\n        let mut circuit_local_values = Vec::with_capacity(NUM_FIBONACCI_COLS);\n        let mut circuit_next_values = Vec::with_capacity(NUM_FIBONACCI_COLS);\n        for _ in 0..NUM_FIBONACCI_COLS {\n            circuit_local_values.push(circuit.add_public_input());\n            circuit_next_values.push(circuit.add_public_input());\n        }\n\n        let row_selectors = RowSelectorsTargets {\n            is_first_row: circuit_sels[0],\n            is_last_row: circuit_sels[1],\n            is_transition: circuit_sels[2],\n        };\n\n        let columns = ColumnsTargets {\n            challenges: \u0026[],\n            public_values: \u0026circuit_public_values,\n            local_prep_values: \u0026[],\n            next_prep_values: \u0026[],\n            local_values: \u0026circuit_local_values,\n            next_values: \u0026circuit_next_values,\n        };\n\n        // Get the circuit for the folded constraints.\n        let sum = symbolic_to_circuit(\n            row_selectors,\n            \u0026columns,\n            \u0026folded_symbolic_constraints,\n            \u0026mut circuit,\n        );\n\n        // Check that the circuit output equals the folded constraints.\n        let final_result_const = circuit.add_const(folded_constraints);\n        circuit.connect(final_result_const, sum);\n\n        let mut all_public_values = sels.to_vec();\n        all_public_values.extend_from_slice(\u0026pis_ext);\n        for i in 0..NUM_FIBONACCI_COLS {\n            all_public_values.push(trace_local[i]);\n            all_public_values.push(trace_next[i]);\n        }\n\n        let builder = circuit.build().unwrap();\n        let mut builder = builder.runner();\n        builder.set_public_inputs(\u0026all_public_values).unwrap();\n        let _ = builder.run()?;\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_pad_to_power_of_two_basic() {\n        // Test with 3 rows -\u003e should pad to 4\n        let mut values = vec![\n            F::from_u64(1),\n            F::from_u64(10), // row 0: [value=1, index=10]\n            F::from_u64(2),\n            F::from_u64(11), // row 1: [value=2, index=11]\n            F::from_u64(3),\n            F::from_u64(12), // row 2: [value=3, index=12]\n        ];\n        let width = 2;\n        let original_height = 3;\n\n        pad_to_power_of_two(\u0026mut values, width, original_height);\n\n        // Should be padded to 4 rows\n        assert_eq!(values.len(), 4 * width);\n\n        // Original rows should be unchanged\n        assert_eq!(values[0], F::from_u64(1));\n        assert_eq!(values[1], F::from_u64(10));\n        assert_eq!(values[2], F::from_u64(2));\n        assert_eq!(values[3], F::from_u64(11));\n        assert_eq!(values[4], F::from_u64(3));\n        assert_eq!(values[5], F::from_u64(12));\n\n        // Padded row should be zero\n        assert_eq!(values[6], F::ZERO); // same as row 2\n        assert_eq!(values[7], F::ZERO); // same as row 2\n    }\n\n    #[test]\n    fn test_pad_to_power_of_two_already_power_of_two() {\n        // Test with 4 rows (already power of two) -\u003e should not change\n        let mut values = vec![\n            F::from_u64(1),\n            F::from_u64(2),\n            F::from_u64(3),\n            F::from_u64(4),\n            F::from_u64(5),\n            F::from_u64(6),\n            F::from_u64(7),\n            F::from_u64(8),\n        ];\n        let original = values.clone();\n        let width = 2;\n        let original_height = 4;\n\n        pad_to_power_of_two(\u0026mut values, width, original_height);\n\n        // Should remain unchanged\n        assert_eq!(values, original);\n        assert_eq!(values.len(), 4 * width);\n    }\n}\n","traces":[{"line":40,"address":[4471342,4467872],"length":1,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[3064903],"length":1,"stats":{"Line":7}},{"line":68,"address":[1935831],"length":1,"stats":{"Line":7}},{"line":69,"address":[3245800],"length":1,"stats":{"Line":7}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":7}},{"line":74,"address":[4467985],"length":1,"stats":{"Line":7}},{"line":75,"address":[4468008],"length":1,"stats":{"Line":7}},{"line":76,"address":[],"length":0,"stats":{"Line":7}},{"line":77,"address":[3065030],"length":1,"stats":{"Line":7}},{"line":78,"address":[1935965],"length":1,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":7}},{"line":82,"address":[],"length":0,"stats":{"Line":14}},{"line":83,"address":[2789524,2789571],"length":1,"stats":{"Line":14}},{"line":85,"address":[6817649,6817605],"length":1,"stats":{"Line":14}},{"line":86,"address":[2789712],"length":1,"stats":{"Line":7}},{"line":87,"address":[6817882],"length":1,"stats":{"Line":7}},{"line":88,"address":[1936598],"length":1,"stats":{"Line":7}},{"line":89,"address":[3065710],"length":1,"stats":{"Line":7}},{"line":90,"address":[3246661,3246710],"length":1,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[2790020],"length":1,"stats":{"Line":7}},{"line":94,"address":[4469035],"length":1,"stats":{"Line":6}},{"line":95,"address":[4470272,4469050],"length":1,"stats":{"Line":12}},{"line":96,"address":[1938167],"length":1,"stats":{"Line":6}},{"line":97,"address":[3476888],"length":1,"stats":{"Line":6}},{"line":99,"address":[3065861],"length":1,"stats":{"Line":7}},{"line":100,"address":[3068368],"length":1,"stats":{"Line":7}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[4471471],"length":1,"stats":{"Line":7}},{"line":105,"address":[1939425,1939459],"length":1,"stats":{"Line":14}},{"line":106,"address":[3478201,3478130],"length":1,"stats":{"Line":14}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[3249347],"length":1,"stats":{"Line":0}},{"line":111,"address":[1936796],"length":1,"stats":{"Line":7}},{"line":112,"address":[6818768],"length":1,"stats":{"Line":5}},{"line":113,"address":[3247424,3247892],"length":1,"stats":{"Line":10}},{"line":115,"address":[],"length":0,"stats":{"Line":7}},{"line":116,"address":[4469748,4470085],"length":1,"stats":{"Line":14}},{"line":118,"address":[6819122,6819320],"length":1,"stats":{"Line":4}},{"line":119,"address":[6819384,6819176],"length":1,"stats":{"Line":0}},{"line":122,"address":[3476619],"length":1,"stats":{"Line":7}},{"line":123,"address":[3248074],"length":1,"stats":{"Line":7}},{"line":125,"address":[3246799,3248101],"length":1,"stats":{"Line":12}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[1936897,1938148],"length":1,"stats":{"Line":14}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[3066333],"length":1,"stats":{"Line":0}},{"line":130,"address":[4470603],"length":1,"stats":{"Line":0}},{"line":132,"address":[3246935],"length":1,"stats":{"Line":7}},{"line":133,"address":[3475698],"length":1,"stats":{"Line":7}},{"line":134,"address":[],"length":0,"stats":{"Line":7}},{"line":135,"address":[3067388],"length":1,"stats":{"Line":7}},{"line":137,"address":[6818412],"length":1,"stats":{"Line":7}},{"line":138,"address":[4469242],"length":1,"stats":{"Line":7}},{"line":139,"address":[2791665],"length":1,"stats":{"Line":7}},{"line":140,"address":[1938422],"length":1,"stats":{"Line":7}},{"line":142,"address":[3247275],"length":1,"stats":{"Line":7}},{"line":143,"address":[3066454],"length":1,"stats":{"Line":7}},{"line":144,"address":[],"length":0,"stats":{"Line":7}},{"line":145,"address":[3248587],"length":1,"stats":{"Line":7}},{"line":149,"address":[3475145],"length":1,"stats":{"Line":7}},{"line":150,"address":[3246502,3248662],"length":1,"stats":{"Line":14}},{"line":151,"address":[3477431,3477471],"length":1,"stats":{"Line":7}},{"line":152,"address":[4470874,4470910],"length":1,"stats":{"Line":14}},{"line":154,"address":[3067880],"length":1,"stats":{"Line":0}},{"line":156,"address":[6820165],"length":1,"stats":{"Line":7}},{"line":157,"address":[6820326,6820206],"length":1,"stats":{"Line":14}},{"line":158,"address":[2792224,2792355],"length":1,"stats":{"Line":14}},{"line":159,"address":[3477744,3477630],"length":1,"stats":{"Line":14}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[1939069,1938975],"length":1,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":7}},{"line":166,"address":[],"length":0,"stats":{"Line":7}},{"line":171,"address":[3246401,3249121],"length":1,"stats":{"Line":14}},{"line":175,"address":[],"length":0,"stats":{"Line":6}},{"line":176,"address":[3474181],"length":1,"stats":{"Line":5}},{"line":178,"address":[6816837],"length":1,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[6816851],"length":1,"stats":{"Line":6}},{"line":183,"address":[],"length":0,"stats":{"Line":5}},{"line":188,"address":[],"length":0,"stats":{"Line":8}},{"line":189,"address":[],"length":0,"stats":{"Line":4}}],"covered":70,"coverable":89},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","examples","fibonacci.rs"],"content":"use std::env;\nuse std::error::Error;\n\n/// Fibonacci circuit: Compute F(n) and prove correctness\n/// Public input: expected_result (F(n))\nuse p3_baby_bear::BabyBear;\nuse p3_batch_stark::CommonData;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit_prover::common::get_airs_and_degrees_with_prep;\nuse p3_circuit_prover::{BatchStarkProver, TablePacking, config};\nuse p3_field::PrimeCharacteristicRing;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\ntype F = BabyBear;\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    init_logger();\n\n    let n = env::args()\n        .nth(1)\n        .and_then(|s| s.parse().ok())\n        .unwrap_or(100);\n\n    let mut builder = CircuitBuilder::new();\n\n    // Public input: expected F(n)\n    let expected_result = builder.alloc_public_input(\"expected_result\");\n\n    // Compute F(n) iteratively\n    let mut a = builder.alloc_const(F::ZERO, \"F(0)\");\n    let mut b = builder.alloc_const(F::ONE, \"F(1)\");\n\n    for _i in 2..=n {\n        let next = builder.add(a, b);\n        a = b;\n        b = next;\n    }\n\n    // Assert computed F(n) equals expected result\n    builder.connect(b, expected_result);\n\n    builder.dump_allocation_log();\n\n    let circuit = builder.build()?;\n    let table_packing = TablePacking::new(4, 4, 1);\n\n    let airs_degrees =\n        get_airs_and_degrees_with_prep::\u003c_, _, 1\u003e(\u0026circuit, table_packing, None).unwrap();\n    let (airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    // Set public input\n    let expected_fib = compute_fibonacci_classical(n);\n    runner.set_public_inputs(\u0026[expected_fib])?;\n\n    let traces = runner.run()?;\n    let config = config::baby_bear().build();\n    let common = CommonData::from_airs_and_degrees(\u0026config, \u0026airs, \u0026degrees);\n    let prover = BatchStarkProver::new(config).with_table_packing(table_packing);\n    let proof = prover.prove_all_tables(\u0026traces, \u0026common)?;\n    prover.verify_all_tables(\u0026proof, \u0026common)?;\n    Ok(())\n}\n\nfn compute_fibonacci_classical(n: usize) -\u003e F {\n    if n == 0 {\n        return F::ZERO;\n    }\n    if n == 1 {\n        return F::ONE;\n    }\n\n    let mut a = F::ZERO;\n    let mut b = F::ONE;\n\n    for _i in 2..=n {\n        let next = a + b;\n        a = b;\n        b = next;\n    }\n\n    b\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","examples","poseidon2_perm_chain.rs"],"content":"use std::env;\nuse std::error::Error;\n\n/// Poseidon2 permutation chain example using the Poseidon2Perm op.\n///\n/// Builds a chain of Poseidon2 permutations and verifies the final output against a native\n/// computation.\nuse p3_baby_bear::{BabyBear, default_babybear_poseidon2_16};\nuse p3_batch_stark::CommonData;\nuse p3_circuit::ops::{Poseidon2PermCall, Poseidon2PermOps};\nuse p3_circuit::tables::generate_poseidon2_trace;\nuse p3_circuit::{CircuitBuilder, ExprId};\nuse p3_circuit_prover::common::{NonPrimitiveConfig, get_airs_and_degrees_with_prep};\nuse p3_circuit_prover::{BatchStarkProver, Poseidon2Config, TablePacking, config};\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{BasedVectorSpace, PrimeCharacteristicRing};\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_symmetric::Permutation;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\ntype Base = BabyBear;\ntype Ext4 = BinomialExtensionField\u003cBase, 4\u003e;\n\nconst WIDTH: usize = 16;\nconst LIMB_SIZE: usize = 4; // D=4\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    init_logger();\n\n    // Parse chain length from CLI (default: 3 permutations).\n    let chain_length: usize = env::args().nth(1).and_then(|s| s.parse().ok()).unwrap_or(3);\n    assert!(chain_length \u003e= 1, \"chain length must be at least 1\");\n\n    // Build an initial state of 4 extension limbs with distinct coefficients.\n    let mut ext_limbs = [Ext4::ZERO; 4];\n    for (limb, ext_limb) in ext_limbs.iter_mut().enumerate() {\n        let coeffs: [Base; LIMB_SIZE] =\n            core::array::from_fn(|j| Base::from_u64((limb * LIMB_SIZE + j + 1) as u64));\n        *ext_limb = Ext4::from_basis_coefficients_slice(\u0026coeffs).unwrap();\n    }\n\n    // Compute native permutation chain over the base field (flattened coefficients).\n    let perm = default_babybear_poseidon2_16();\n    let mut state_base = flatten_ext_limbs(\u0026ext_limbs);\n    for _ in 0..chain_length {\n        state_base = perm.permute(state_base);\n    }\n    let final_state = state_base;\n    let final_limbs_ext = collect_ext_limbs(\u0026final_state);\n\n    // Build the circuit.\n    let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n    builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cExt4, BabyBearD4Width16\u003e,\n        perm,\n    );\n\n    // Allocate initial input limbs (constants for this example).\n    let first_inputs_expr: [ExprId; 4] =\n        core::array::from_fn(|i| builder.alloc_const(ext_limbs[i], \"poseidon2_perm_input\"));\n\n    // Allocate expected outputs for limbs 0 and 1 of the final row (for checking).\n    let expected_final_output_exprs: [ExprId; 2] = core::array::from_fn(|i| {\n        builder.alloc_const(final_limbs_ext[i], \"poseidon2_perm_expected_output\")\n    });\n\n    // Add permutation rows.\n    let mut last_outputs: [Option\u003cExprId\u003e; 2] = [None, None];\n\n    for row in 0..chain_length {\n        let is_first = row == 0;\n        let is_last = row + 1 == chain_length;\n\n        let mut inputs: [Option\u003cExprId\u003e; 4] = [None, None, None, None];\n        if is_first {\n            for limb in 0..4 {\n                inputs[limb] = Some(first_inputs_expr[limb]);\n            }\n        }\n\n        let (_op_id, outputs) = builder.add_poseidon2_perm(Poseidon2PermCall {\n            new_start: is_first,\n            merkle_path: false,\n            mmcs_bit: None, // Must be None when merkle_path=false\n            inputs,\n            out_ctl: [is_last, is_last],\n            mmcs_index_sum: None,\n        })?;\n\n        if is_last {\n            last_outputs = outputs;\n\n            let out0 = outputs[0].ok_or(\"missing out0 expr\")?;\n            let out1 = outputs[1].ok_or(\"missing out1 expr\")?;\n            builder.connect(out0, expected_final_output_exprs[0]);\n            builder.connect(out1, expected_final_output_exprs[1]);\n        }\n    }\n\n    let out0 = last_outputs[0].ok_or(\"missing out0 expr\")?;\n    let out1 = last_outputs[1].ok_or(\"missing out1 expr\")?;\n\n    // Build + run.\n    let circuit = builder.build()?;\n    let expr_to_widx = circuit.expr_to_widx.clone();\n\n    let table_packing = TablePacking::new(1, 1, 1);\n    let poseidon2_config = Poseidon2Config::baby_bear_d4_width16();\n    let airs_degrees = get_airs_and_degrees_with_prep::\u003c_, _, 1\u003e(\n        \u0026circuit,\n        table_packing,\n        Some(\u0026[NonPrimitiveConfig::Poseidon2(poseidon2_config.clone())]),\n    )\n    .unwrap();\n\n    let runner = circuit.runner();\n    let traces = runner.run()?;\n\n    // Sanity-check exposed outputs against the native computation.\n    let observed_out0 = {\n        let wid = expr_to_widx\n            .get(\u0026out0)\n            .ok_or(\"missing witness id for out0\")?;\n        let pos = traces\n            .witness_trace\n            .index\n            .iter()\n            .position(|\u0026idx| idx == *wid)\n            .ok_or(\"missing witness id for out0 in witness trace\")?;\n        *traces\n            .witness_trace\n            .values\n            .get(pos)\n            .ok_or(\"missing witness value for out0\")?\n    };\n    let observed_out1 = {\n        let wid = expr_to_widx\n            .get(\u0026out1)\n            .ok_or(\"missing witness id for out1\")?;\n        let pos = traces\n            .witness_trace\n            .index\n            .iter()\n            .position(|\u0026idx| idx == *wid)\n            .ok_or(\"missing witness id for out1 in witness trace\")?;\n        *traces\n            .witness_trace\n            .values\n            .get(pos)\n            .ok_or(\"missing witness value for out1\")?\n    };\n\n    assert_eq!(\n        [observed_out0, observed_out1],\n        [final_limbs_ext[0], final_limbs_ext[1]]\n    );\n\n    assert!(\n        traces\n            .non_primitive_traces\n            .get(\"poseidon2\")\n            .is_some_and(|t| t.rows() == chain_length),\n        \"Poseidon2 trace should contain one row per perm op\"\n    );\n\n    // Prove and verify the circuit.\n    let stark_config = config::baby_bear().build();\n\n    let (airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let common = CommonData::from_airs_and_degrees(\u0026stark_config, \u0026airs, \u0026degrees);\n\n    let mut prover = BatchStarkProver::new(stark_config).with_table_packing(table_packing);\n    prover.register_poseidon2_table(poseidon2_config);\n    let proof = prover.prove_all_tables(\u0026traces, \u0026common)?;\n    prover.verify_all_tables(\u0026proof, \u0026common)?;\n\n    Ok(())\n}\n\nfn flatten_ext_limbs(limbs: \u0026[Ext4; 4]) -\u003e [Base; WIDTH] {\n    let mut out = [Base::ZERO; WIDTH];\n    for (i, limb) in limbs.iter().enumerate() {\n        let coeffs = limb.as_basis_coefficients_slice();\n        out[i * LIMB_SIZE..(i + 1) * LIMB_SIZE].copy_from_slice(coeffs);\n    }\n    out\n}\n\nfn collect_ext_limbs(state: \u0026[Base; WIDTH]) -\u003e [Ext4; 4] {\n    let mut limbs = [Ext4::ZERO; 4];\n    for i in 0..4 {\n        let chunk = \u0026state[i * LIMB_SIZE..(i + 1) * LIMB_SIZE];\n        limbs[i] = Ext4::from_basis_coefficients_slice(chunk).unwrap();\n    }\n    limbs\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","examples","poseidon2_perm_merkle.rs"],"content":"use std::error::Error;\n\nuse p3_baby_bear::{BabyBear, default_babybear_poseidon2_16};\nuse p3_batch_stark::CommonData;\nuse p3_circuit::op::NonPrimitiveOpPrivateData;\nuse p3_circuit::tables::{Poseidon2PermPrivateData, generate_poseidon2_trace};\nuse p3_circuit::{CircuitBuilder, ExprId, Poseidon2PermOps};\nuse p3_circuit_prover::common::{NonPrimitiveConfig, get_airs_and_degrees_with_prep};\nuse p3_circuit_prover::{BatchStarkProver, Poseidon2Config, TablePacking, config};\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{BasedVectorSpace, PrimeCharacteristicRing};\nuse p3_poseidon2_circuit_air::BabyBearD4Width16;\nuse p3_symmetric::Permutation;\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\ntype Base = BabyBear;\ntype Ext4 = BinomialExtensionField\u003cBase, 4\u003e;\n\nconst LIMB_SIZE: usize = 4;\nconst WIDTH: usize = 16;\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    init_logger();\n\n    // Three-row Merkle path example (2 levels):\n    // Row 0: permutation input is leaf || sibling0. merkle_path = true, new_start = true, mmcs_bit = 0\n    // Row 1: merkle_path = true, new_start = false, mmcs_bit = 1 (previous hash becomes right child),\n    //        input limbs 2-3 get prev row's output limbs 0-1; input limbs 0-1 take sibling1 as private inputs.\n    // Row 2: merkle_path = true, new_start = false, mmcs_bit = 0 (previous hash becomes left child),\n    //        input limbs 0-1 get prev row's output limbs 0-1; input limbs 2-3 take sibling2 as private inputs.\n    //\n    // Tree shape (limb ranges = base-field coeff slices of Ext4):\n    //          root (row2 out)\n    //         /                 \\\n    //   row2 left (row1 out)   sibling2 [25..32]\n    //      /          \\\n    // sibling1 [17..24]  row0 out\n    //                     /     \\\n    //               leaf [1..8]  sibling0 [9..16]\n    //\n    // We expose final digest limbs 0-1 as public inputs and the mmcs_index_sum (should be binary 010 = 2).\n\n    let perm = default_babybear_poseidon2_16();\n\n    // Build leaf and siblings as extension limbs.\n    let leaf_limb0 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(1),\n        Base::from_u64(2),\n        Base::from_u64(3),\n        Base::from_u64(4),\n    ])\n    .expect(\"extension from coeffs\");\n    let leaf_limb1 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(5),\n        Base::from_u64(6),\n        Base::from_u64(7),\n        Base::from_u64(8),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling0_limb2 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(9),\n        Base::from_u64(10),\n        Base::from_u64(11),\n        Base::from_u64(12),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling0_limb3 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(13),\n        Base::from_u64(14),\n        Base::from_u64(15),\n        Base::from_u64(16),\n    ])\n    .expect(\"extension from coeffs\");\n\n    let sibling1_limb2 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(17),\n        Base::from_u64(18),\n        Base::from_u64(19),\n        Base::from_u64(20),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling1_limb3 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(21),\n        Base::from_u64(22),\n        Base::from_u64(23),\n        Base::from_u64(24),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling2_limb2 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(25),\n        Base::from_u64(26),\n        Base::from_u64(27),\n        Base::from_u64(28),\n    ])\n    .expect(\"extension from coeffs\");\n    let sibling2_limb3 = Ext4::from_basis_coefficients_slice(\u0026[\n        Base::from_u64(29),\n        Base::from_u64(30),\n        Base::from_u64(31),\n        Base::from_u64(32),\n    ])\n    .expect(\"extension from coeffs\");\n\n    // Native row 0 permutation: hash(leaf limbs, sibling0 limbs)\n    let row0_state = [leaf_limb0, leaf_limb1, sibling0_limb2, sibling0_limb3];\n    let row0_state_base = flatten_ext_limbs(\u0026row0_state);\n    let row0_out_base = perm.permute(row0_state_base);\n\n    // Row 1 chaining: mmcs_bit = 1, so previous hash becomes right child.\n    // Previous digest (out[0..1]) chains into limbs 2-3; sibling1 provides limbs 0-1.\n    let mut row1_state_base = [Base::ZERO; WIDTH];\n    // limbs 0-1 from sibling1\n    let sibling1_flat: [Base; 2 * LIMB_SIZE] = flatten_ext_limbs(\u0026[sibling1_limb2, sibling1_limb3]);\n    row1_state_base[0..2 * LIMB_SIZE].copy_from_slice(\u0026sibling1_flat);\n    // limbs 2-3 from row0 output limbs 0-1\n    row1_state_base[2 * LIMB_SIZE..4 * LIMB_SIZE].copy_from_slice(\u0026row0_out_base[0..2 * LIMB_SIZE]);\n\n    let row1_out_base = perm.permute(row1_state_base);\n\n    // Row 2 chaining: mmcs_bit = 0, so previous hash becomes left child (limbs 0-1 get prev_out[0..2])\n    // limbs 2-3 from sibling2\n    let mut row2_state_base = [Base::ZERO; WIDTH];\n    row2_state_base[0..2 * LIMB_SIZE].copy_from_slice(\u0026row1_out_base[0..2 * LIMB_SIZE]);\n    let sibling2_flat: [Base; 2 * LIMB_SIZE] = flatten_ext_limbs(\u0026[sibling2_limb2, sibling2_limb3]);\n    row2_state_base[2 * LIMB_SIZE..4 * LIMB_SIZE].copy_from_slice(\u0026sibling2_flat);\n\n    let row2_out_base = perm.permute(row2_state_base);\n    let row2_out_limbs = collect_ext_limbs(\u0026row2_out_base);\n\n    // mmcs_index_sum should be 2 (bits: row1=1, row2=0)\n    let mmcs_index_sum_row2 = Base::from_u64(2);\n\n    // Build circuit\n    let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n    builder.enable_poseidon2_perm::\u003cBabyBearD4Width16, _\u003e(\n        generate_poseidon2_trace::\u003cExt4, BabyBearD4Width16\u003e,\n        perm,\n    );\n\n    // Row 0: expose all inputs\n    let mmcs_bit_row0 = builder.alloc_const(Ext4::from_prime_subfield(Base::ZERO), \"mmcs_bit_row0\");\n    let inputs_row0: [ExprId; 4] = [\n        builder.alloc_const(row0_state[0], \"leaf0\"),\n        builder.alloc_const(row0_state[1], \"leaf1\"),\n        builder.alloc_const(row0_state[2], \"sibling0_2\"),\n        builder.alloc_const(row0_state[3], \"sibling0_3\"),\n    ];\n\n    let (_row0_op_id, _row0_outputs) =\n        builder.add_poseidon2_perm(p3_circuit::ops::Poseidon2PermCall {\n            new_start: true,\n            merkle_path: true,\n            mmcs_bit: Some(mmcs_bit_row0),\n            inputs: inputs_row0.map(Some),\n            out_ctl: [false, false],\n            mmcs_index_sum: None,\n        })?;\n\n    // Row 1: Merkle right. Chain previous digest into limbs 2-3 and provide sibling1 in limbs 0-1.\n    // All inputs are private (chained from row 0 or provided via private data)\n    let sibling1_inputs: [Option\u003cExprId\u003e; 4] = [None, None, None, None];\n    // Public root limbs\n    let out0 = builder.add_public_input();\n    let out1 = builder.add_public_input();\n    let mmcs_idx_sum_expr = builder.add_public_input();\n\n    let mmcs_bit_row1 = builder.alloc_const(Ext4::from_prime_subfield(Base::ONE), \"mmcs_bit_row1\");\n    let (row1_op_id, _row1_outputs) =\n        builder.add_poseidon2_perm(p3_circuit::ops::Poseidon2PermCall {\n            new_start: false,\n            merkle_path: true,\n            mmcs_bit: Some(mmcs_bit_row1),\n            inputs: sibling1_inputs,\n            out_ctl: [false, false],\n            mmcs_index_sum: None,\n        })?;\n\n    // Row 2: merkle left - all inputs private (chained from row 1 or provided via private data)\n    let mmcs_bit_row2 = builder.alloc_const(Ext4::from_prime_subfield(Base::ZERO), \"mmcs_bit_row2\");\n    let sibling2_inputs: [Option\u003cExprId\u003e; 4] = [None, None, None, None];\n    let (row2_op_id, row2_outputs) =\n        builder.add_poseidon2_perm(p3_circuit::ops::Poseidon2PermCall {\n            new_start: false,\n            merkle_path: true,\n            mmcs_bit: Some(mmcs_bit_row2),\n            inputs: sibling2_inputs,\n            out_ctl: [true, true],\n            mmcs_index_sum: Some(mmcs_idx_sum_expr),\n        })?;\n    let row2_out0 = row2_outputs[0].ok_or(\"missing row2 out0\")?;\n    let row2_out1 = row2_outputs[1].ok_or(\"missing row2 out1\")?;\n    builder.connect(row2_out0, out0);\n    builder.connect(row2_out1, out1);\n\n    let circuit = builder.build()?;\n    let table_packing = TablePacking::new(4, 4, 1);\n    let poseidon2_config = Poseidon2Config::baby_bear_d4_width16();\n    let airs_degrees = get_airs_and_degrees_with_prep::\u003c_, _, 1\u003e(\n        \u0026circuit,\n        table_packing,\n        Some(\u0026[NonPrimitiveConfig::Poseidon2(poseidon2_config.clone())]),\n    )?;\n    let (airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n    let mut runner = circuit.runner();\n    runner.set_public_inputs(\u0026[\n        row2_out_limbs[0],\n        row2_out_limbs[1],\n        Ext4::from_prime_subfield(mmcs_index_sum_row2),\n    ])?;\n\n    // Set private inputs for Row 1\n    // Row 1: mmcs_bit = 1 (Right Child). Previous digest chains from previous row.\n    // For Merkle mode, provide the sibling (2 limbs). Internal logic handles placement.\n    runner.set_non_primitive_op_private_data(\n        row1_op_id,\n        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n            sibling: [sibling1_limb2, sibling1_limb3],\n        }),\n    )?;\n\n    // Set private inputs for Row 2\n    // Row 2: mmcs_bit = 0 (Left Child). Previous digest chains from previous row.\n    // For Merkle mode, provide the sibling (2 limbs). Internal logic handles placement.\n    runner.set_non_primitive_op_private_data(\n        row2_op_id,\n        NonPrimitiveOpPrivateData::Poseidon2Perm(Poseidon2PermPrivateData {\n            sibling: [sibling2_limb2, sibling2_limb3],\n        }),\n    )?;\n\n    let traces = runner.run()?;\n\n    // Check Poseidon2 trace rows and mmcs_index_sum exposure\n    let poseidon2_trace = traces\n        .non_primitive_trace::\u003cp3_circuit::tables::Poseidon2Trace\u003cBase\u003e\u003e(\"poseidon2\")\n        .expect(\"poseidon2 trace missing\");\n    assert_eq!(poseidon2_trace.total_rows(), 3, \"expected three perm rows\");\n\n    let stark_config = config::baby_bear().build();\n    let common = CommonData::from_airs_and_degrees(\u0026stark_config, \u0026airs, \u0026degrees);\n\n    let mut prover = BatchStarkProver::new(stark_config).with_table_packing(table_packing);\n    prover.register_poseidon2_table(poseidon2_config);\n    let proof = prover.prove_all_tables(\u0026traces, \u0026common)?;\n    prover.verify_all_tables(\u0026proof, \u0026common)?;\n\n    Ok(())\n}\n\nfn flatten_ext_limbs\u003cconst N: usize, const M: usize\u003e(limbs: \u0026[Ext4; N]) -\u003e [Base; M] {\n    let mut out = [Base::ZERO; M];\n    for (i, limb) in limbs.iter().enumerate() {\n        let coeffs = limb.as_basis_coefficients_slice();\n        let start = i * LIMB_SIZE;\n        let end = (start + LIMB_SIZE).min(M);\n        out[start..end].copy_from_slice(\u0026coeffs[0..(end - start)]);\n    }\n    out\n}\n\nfn collect_ext_limbs(state: \u0026[Base; WIDTH]) -\u003e [Ext4; 4] {\n    let mut limbs = [Ext4::ZERO; 4];\n    for i in 0..4 {\n        let chunk = \u0026state[i * LIMB_SIZE..(i + 1) * LIMB_SIZE];\n        limbs[i] = Ext4::from_basis_coefficients_slice(chunk).unwrap();\n    }\n    limbs\n}\n","traces":[{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","add_air.rs"],"content":"//! [`AddAir`] defines the AIR for proving addition and subtraction over both base and extension fields.\n//!\n//! Conceptually, each row of the trace encodes one or more addition constraints of the form\n//!\n//! ```text\n//!     lhs + rhs = result\n//! ```\n//!\n//! When the circuit wants to prove a subtraction, it is expressed as an addition by rewriting\n//!\n//! ```text\n//!     a - b = c\n//! ```\n//!\n//! as\n//!\n//! ```text\n//!     b + c = a\n//! ```\n//!\n//! so that subtraction is handled uniformly as an addition gate in the AIR.\n//!\n//! The AIR is generic over an extension degree `D`. Each operand and result is treated as\n//! an element of an extension field of degree `D` over the base field. Internally, this is\n//! represented as `D` base-field coordinates (basis coefficients), and the addition is\n//! checked component-wise. The runtime parameter `lanes` controls how many independent\n//! additions are packed side-by-side in a single row of the trace.\n//!\n//! # Column layout\n//!\n//! For each logical operation (lane) we allocate `3 * D + 3` base-field columns. These are\n//! grouped as:\n//!\n//! - `D` columns for the left operand (lhs) basis coefficients,\n//! - `D` columns for the right operand (rhs) basis coefficients,\n//! - `D` columns for the result operand basis coefficients,\n//!\n//! In other words, for a single lane the layout is:\n//!\n//! ```text\n//!     [lhs[0..D), rhs[0..D), result[0..D)]\n//! ```\n//!\n//! We also allocate 3 preprocessed base-field columns:\n//!\n//! - 1 column for the lhs operand index within the `Witness` table,\n//! - 1 column for the rhs operand index,\n//! - 1 column for the result operand index,\n//!\n//! A single row can pack several of these lanes side-by-side, so the full row layout is\n//! this pattern repeated `lanes` times.\n//!\n//! # Constraints\n//!\n//! Let `left[i]`, `right[i]`, and `output[i]` denote the `i`-th basis coordinate of the\n//! left, right and result extension field elements respectively. For each operation and\n//! each coordinate `i` in `0..D`, the AIR enforces the linear constraint\n//!\n//! $$\n//! left[i] + right[i] - output[i] = 0.\n//! $$\n//!\n//! Since extension addition is coordinate-wise, these constraints are sufficient to show\n//! that the full extension elements satisfy\n//!\n//! $$\n//! left + right = output.\n//! $$\n//!\n//! # Global interactions\n//!\n//! Each operation (lane) has three interactions with the global witness bus:\n//!\n//! - send `(index_left,  left)`\n//! - send `(index_right, right)`\n//! - send `(index_output, result)`\n//!\n//! The AIR defined here focuses on the algebraic relation between the operands. The\n//! correctness of the indices with respect to the global witness bus is enforced by the\n//! bus interaction logic elsewhere in the system.\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::iter;\nuse core::marker::PhantomData;\n\nuse itertools::Itertools;\nuse p3_air::{\n    Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PairBuilder, PermutationAirBuilder,\n};\nuse p3_circuit::tables::AddTrace;\nuse p3_circuit::utils::pad_to_power_of_two;\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_lookup::lookup_traits::{AirLookupHandler, Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_uni_stark::SymbolicAirBuilder;\n\nuse crate::air::utils::get_index_lookups;\n\n/// AIR for proving addition gates of the form `lhs + rhs = result`.\n///\n/// The type is generic over:\n///\n/// - `F`: the base field,\n/// - `D`: the degree of the extension field; each operand is represented by `D` coordinates.\n///\n/// At runtime, a `lanes` parameter specifies how many addition gates are packed into each\n/// trace row.\n#[derive(Debug, Clone)]\npub struct AddAir\u003cF, const D: usize = 1\u003e {\n    /// Total number of logical addition operations (gates) in the trace.\n    pub num_ops: usize,\n    /// Number of independent addition gates packed per trace row.\n    ///\n    /// The last row is padded if the number of operations is not a multiple of this value.\n    pub lanes: usize,\n    /// Flattened values of preprocessed columns. They are used for generating the common data,\n    /// as well as by the prover, to compute the constraint polynomial.\n    ///\n    /// Note that the verifier does not need those values.\n    /// When providing instances to the verifier, this field can be left empty.\n    /// Preprocessed values correspond to the indices of the inputs and outputs within the `Witness`.\n    pub preprocessed: Vec\u003cF\u003e,\n    /// Number of lookup columns registered by this AIR so far.\n    pub num_lookup_columns: usize,\n    /// Marker tying this AIR to its base field.\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field + PrimeCharacteristicRing, const D: usize\u003e AddAir\u003cF, D\u003e {\n    /// Construct a new `AddAir` instance.\n    ///\n    /// - `num_ops`: total number of addition operations to be proven,\n    /// - `lanes`: how many operations are packed side-by-side in each row.\n    ///\n    /// Panics if `lanes == 0` because we always need at least one lane per row.\n    pub const fn new(num_ops: usize, lanes: usize) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        Self {\n            num_ops,\n            lanes,\n            preprocessed: Vec::new(),\n            num_lookup_columns: 0,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `AddAir` instance.\n    ///\n    /// - `num_ops`: total number of addition operations to be proven,\n    /// - `lanes`: how many operations are packed side-by-side in each row.\n    ///\n    /// Panics if `lanes == 0` because we always need at least one lane per row.\n    pub const fn new_with_preprocessed(num_ops: usize, lanes: usize, preprocessed: Vec\u003cF\u003e) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        Self {\n            num_ops,\n            lanes,\n            preprocessed,\n            num_lookup_columns: 0,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Number of base-field columns occupied by a single lane.\n    ///\n    /// Each lane stores:\n    /// - `3 * D` coordinates (for `lhs`, `rhs`, and `result`),\n    ///\n    /// The total width of a single row is `3 * D`\n    pub const fn lane_width() -\u003e usize {\n        3 * D\n    }\n\n    /// Total number of columns in the main trace for this AIR instance.\n    pub const fn total_width(\u0026self) -\u003e usize {\n        self.lanes * Self::lane_width()\n    }\n\n    /// Number of preprocessed base-field columns occupied by a single lane.\n    ///\n    /// Each lane stores 3 indices (one for each operand), as well as the multiplicity.\n    /// The multiplicity is 1 for addition operations and 0 for padding.\n    pub const fn preprocessed_lane_width() -\u003e usize {\n        4\n    }\n\n    /// Number of preprocessed columns for this AIR instance.\n    ///\n    /// Each lane stores 3 indices (one for each operand)\n    pub const fn preprocessed_width(\u0026self) -\u003e usize {\n        self.lanes * Self::preprocessed_lane_width()\n    }\n\n    /// Number of preprocessed columns excluding the multiplicity column.\n    pub const fn preprocessed_width_without_multiplicity(\u0026self) -\u003e usize {\n        self.lanes * (Self::preprocessed_lane_width() - 1)\n    }\n\n    /// Convert an `AddTrace` into a `RowMajorMatrix` suitable for the STARK prover.\n    ///\n    /// This function is responsible for:\n    ///\n    /// 1. Taking the logical operations from the `AddTrace`:\n    ///    - `lhs_values`, `rhs_values`, `result_values` (extension elements),\n    ///    - `lhs_index`, `rhs_index`, `result_index` (witness-bus indices),\n    /// 2. Decomposing each extension element into its `D` basis coordinates,\n    /// 3. Packing `lanes` operations side-by-side in each row,\n    /// 4. Padding the trace to have a power-of-two number of rows for FFT-friendly\n    ///    execution by the STARK prover.\n    ///\n    /// The resulting matrix has:\n    ///\n    /// - width `= lanes * LANE_WIDTH`,\n    /// - height equal to the number of rows after packing and padding.\n    ///\n    /// The layout within a row is:\n    ///\n    /// ```text\n    ///     [lhs[D], lhs_idx, rhs[D], rhs_idx, result[D], result_idx] repeated `lanes` times.\n    /// ```\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026AddTrace\u003cExtF\u003e,\n        lanes: usize,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        // Lanes must be strictly positive.\n        //\n        // Zero lanes would make it impossible to construct a row.\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        // Per-lane width in base-field columns.\n        let lane_width = Self::lane_width();\n        // Total width of each row once all lanes are packed.\n        let width = lane_width * lanes;\n        // Number of logical operations we need to pack into the trace.\n        let op_count = trace.lhs_values.len();\n        // Number of rows needed to hold `op_count` operations when each row carries `lanes` of them.\n        let row_count = op_count.div_ceil(lanes);\n\n        // Pre-allocate the entire trace as a flat vector in row-major order.\n        //\n        // We start with `row_count` rows, each of width `width`, and fill it with zeros.\n        // This automatically provides a clean padding for any unused lanes in the final row.\n        let mut values = F::zero_vec(width * row_count.max(1));\n\n        // Iterate over all operations in lockstep across the trace arrays.\n        for (op_idx, ((lhs_val, rhs_val), res_val)) in trace\n            .lhs_values\n            .iter()\n            .zip(trace.rhs_values.iter())\n            .zip(trace.result_values.iter())\n            .enumerate()\n        {\n            // Determine the target row index.\n            let row = op_idx / lanes;\n            // Determine which lane within that row this operation occupies.\n            let lane = op_idx % lanes;\n\n            // Compute the starting column index (cursor) for this lane within the flat vector.\n            //\n            // Row-major layout means:\n            //   row_offset = row * width,\n            //   lane_offset = lane * lane_width.\n            let mut cursor = (row * width) + (lane * lane_width);\n\n            // Write LHS coordinates and LHS witness index.\n            //\n            // Extract the basis coefficients of the lhs extension element.\n            let lhs_coeffs = lhs_val.as_basis_coefficients_slice();\n            // Sanity check: the extension degree must match the generic parameter `D`.\n            assert_eq!(\n                lhs_coeffs.len(),\n                D,\n                \"Extension field degree mismatch for lhs\"\n            );\n            // Copy the `D` lhs coordinates into the trace row.\n            values[cursor..cursor + D].copy_from_slice(lhs_coeffs);\n            cursor += D;\n\n            // Write RHS coordinates and RHS witness index.\n            //\n            // Extract the basis coefficients of the rhs extension element.\n            let rhs_coeffs = rhs_val.as_basis_coefficients_slice();\n            // Sanity check: the extension degree must match the generic parameter `D`.\n            assert_eq!(\n                rhs_coeffs.len(),\n                D,\n                \"Extension field degree mismatch for rhs\"\n            );\n            // Copy the `D` rhs coordinates into the trace row.\n            values[cursor..cursor + D].copy_from_slice(rhs_coeffs);\n            cursor += D;\n\n            // Write result coordinates and result witness index.\n            //\n            // Extract the basis coefficients of the result extension element.\n            let res_coeffs = res_val.as_basis_coefficients_slice();\n            debug_assert_eq!(\n                res_coeffs.len(),\n                D,\n                \"Extension field degree mismatch for result\"\n            );\n            // Copy the `D` result coordinates into the trace row.\n            values[cursor..cursor + D].copy_from_slice(res_coeffs);\n        }\n\n        // Pad the matrix to a power-of-two height.\n        pad_to_power_of_two(\u0026mut values, width, row_count);\n\n        // Build the row-major matrix with the computed width.\n        RowMajorMatrix::new(values, width)\n    }\n\n    pub fn trace_to_preprocessed\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026AddTrace\u003cExtF\u003e,\n        lanes: usize,\n    ) -\u003e Vec\u003cF\u003e {\n        let total_len = trace.lhs_index.len() * Self::preprocessed_lane_width() * lanes;\n        let mut preprocessed_values = Vec::with_capacity(total_len);\n        for (lhs_idx, rhs_idx, res_idx) in trace\n            .lhs_index\n            .iter()\n            .zip(trace.rhs_index.iter())\n            .zip(trace.result_index.iter())\n            .map(|((l, r), o)| (l, r, o))\n        {\n            preprocessed_values.extend(\u0026[\n                F::from_u32(lhs_idx.0),\n                F::from_u32(rhs_idx.0),\n                F::from_u32(res_idx.0),\n            ]);\n        }\n\n        preprocessed_values\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for AddAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        self.total_width()\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        // At this point, the preprocessed trace should be set.\n        let original_height = self.num_ops.div_ceil(self.lanes);\n\n        if original_height \u003e 0 {\n            assert!(!self.preprocessed.is_empty());\n        }\n\n        // Add the multiplicity to the preprocessed values.\n        let mut preprocessed_values = self\n            .preprocessed\n            .iter()\n            .chunks(Self::preprocessed_lane_width() - 1)\n            .into_iter()\n            .flat_map(|chunk| iter::once(F::ONE).chain(chunk.into_iter().cloned()))\n            .collect::\u003cVec\u003cF\u003e\u003e();\n\n        debug_assert!(\n            preprocessed_values.len() % Self::preprocessed_lane_width() == 0,\n            \"Preprocessed trace length mismatch for AddAir: Got {} values, expected multiple of {}\",\n            preprocessed_values.len(),\n            Self::preprocessed_lane_width()\n        );\n\n        let padding_len =\n            self.preprocessed_width() - preprocessed_values.len() % self.preprocessed_width();\n        if padding_len != self.preprocessed_width() {\n            preprocessed_values.extend(vec![F::ZERO; padding_len]);\n        }\n        pad_to_power_of_two(\n            \u0026mut preprocessed_values,\n            self.preprocessed_width(),\n            original_height,\n        );\n        Some(RowMajorMatrix::new(\n            preprocessed_values,\n            self.preprocessed_width(),\n        ))\n    }\n}\n\nimpl\u003cAB: PairBuilder, const D: usize\u003e Air\u003cAB\u003e for AddAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        // Access the main trace view from the builder.\n        let main = builder.main();\n\n        // Make sure that the matrix width matches what this AIR expects.\n        debug_assert_eq!(main.width(), self.total_width(), \"column width mismatch\");\n\n        // Get the evaluation at evaluation point `zeta`\n        let local = main.row_slice(0).expect(\"matrix must be non-empty\");\n        let lane_width = Self::lane_width();\n\n        // Iterate over the row in fixed-size chunks, each chunk describing one lane:\n        //\n        // [lhs[0..D), lhs_idx, rhs[0..D), rhs_idx, result[0..D), result_idx]\n        for lane_data in local.chunks_exact(lane_width) {\n            // First, split off the lhs block and its index:\n            //\n            //   lhs_and_idx = [lhs[0..D), lhs_idx]\n            //   rest        = [rhs[0..D), rhs_idx, result[0..D), result_idx]\n            let (lhs_slice, rest) = lane_data.split_at(D);\n            // Next, split the remaining data into:\n            //\n            //   rhs_and_idx    = [rhs[0..D), rhs_idx]\n            //   result_and_idx = [result[0..D), result_idx]\n            let (rhs_slice, result_slice) = rest.split_at(D);\n\n            // Enforce coordinate-wise addition for each basis coordinate `i` in `0..D`.\n            //\n            // For each `i`, we add the constraint:\n            //\n            //     lhs_slice[i] + rhs_slice[i] - result_slice[i] = 0.\n            for ((lhs, rhs), result) in lhs_slice\n                .iter()\n                .zip(rhs_slice.iter())\n                .zip(result_slice.iter())\n            {\n                // Push a single linear constraint into the builder.\n                builder.assert_zero(lhs.clone() + rhs.clone() - result.clone());\n            }\n        }\n    }\n}\n\nimpl\u003cAB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues, const D: usize\u003e\n    AirLookupHandler\u003cAB\u003e for AddAir\u003cAB::F, D\u003e\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        let new_idx = self.num_lookup_columns;\n        self.num_lookup_columns += 1;\n        vec![new_idx]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e {\n        let mut lookups = Vec::new();\n        self.num_lookup_columns = 0;\n        let preprocessed_width = self.preprocessed_width();\n\n        // Create symbolic air builder to access symbolic variables\n        let symbolic_air_builder = SymbolicAirBuilder::\u003cAB::F\u003e::new(\n            preprocessed_width,\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            0, // Here, we do not need the permutation trace\n            0,\n        );\n\n        let symbolic_main = symbolic_air_builder.main();\n        let symbolic_main_local = symbolic_main.row_slice(0).unwrap();\n\n        let preprocessed = symbolic_air_builder.preprocessed();\n        let preprocessed_local = preprocessed.row_slice(0).unwrap();\n\n        for lane in 0..self.lanes {\n            let lane_offset = lane * Self::lane_width();\n            let preprocessed_lane_offset = lane * Self::preprocessed_lane_width();\n\n            // There are 3 lookups per lane: lhs, rhs, result, with the same multiplicity.\n            let lane_lookup_inputs = get_index_lookups::\u003cAB, D\u003e(\n                lane_offset,\n                preprocessed_lane_offset,\n                3,\n                \u0026symbolic_main_local,\n                \u0026preprocessed_local,\n                Direction::Send,\n            );\n            lookups.extend(lane_lookup_inputs.into_iter().map(|inps| {\n                AirLookupHandler::\u003cAB\u003e::register_lookup(\n                    self,\n                    Kind::Global(\"WitnessChecks\".to_string()),\n                    \u0026inps,\n                )\n            }));\n        }\n        lookups\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n    use alloc::vec::Vec;\n\n    use p3_baby_bear::BabyBear as Val;\n    use p3_circuit::WitnessId;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    #[test]\n    fn prove_verify_add_base_field() {\n        let n = 8;\n        let lhs_values = vec![Val::from_u64(3); n];\n        let rhs_values = vec![Val::from_u64(5); n];\n        let result_values = vec![Val::from_u64(8); n];\n        let lhs_index = vec![WitnessId(1); n];\n        let rhs_index = vec![WitnessId(2); n];\n        let result_index = vec![WitnessId(3); n];\n\n        // Get preprocessed index values.\n        let mut preprocessed_values = Vec::with_capacity(n * 3);\n        lhs_index\n            .iter()\n            .zip(rhs_index.iter())\n            .zip(result_index.iter())\n            .for_each(|((lhs_idx, rhs_idx), result_idx)| {\n                preprocessed_values.extend(\u0026[\n                    Val::from_u32(lhs_idx.0),\n                    Val::from_u32(rhs_idx.0),\n                    Val::from_u32(result_idx.0),\n                ]);\n            });\n\n        let trace = AddTrace {\n            lhs_values,\n            lhs_index,\n            rhs_values,\n            rhs_index,\n            result_values,\n            result_index,\n        };\n\n        let matrix: RowMajorMatrix\u003cVal\u003e = AddAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n        assert_eq!(matrix.width(), 3);\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = AddAir::\u003cVal, 1\u003e::new_with_preprocessed(n, 1, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn prove_verify_add_extension_field_d4() {\n        type ExtField = BinomialExtensionField\u003cVal, 4\u003e;\n        let n = 4;\n\n        // Build genuine degree-4 elements via explicit coefficients with ALL non-zero values:\n        // a = a0 + a1 x + a2 x^2 + a3 x^3\n        let lhs = ExtField::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(7), // a0\n            Val::from_u64(3), // a1\n            Val::from_u64(4), // a2\n            Val::from_u64(5), // a3\n        ])\n        .unwrap();\n\n        let rhs = ExtField::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(11), // b0\n            Val::from_u64(2),  // b1\n            Val::from_u64(9),  // b2\n            Val::from_u64(6),  // b3\n        ])\n        .unwrap();\n\n        let result = lhs + rhs;\n\n        // Sanity: basis length is D\n        assert_eq!(\n            \u003cExtField as BasedVectorSpace\u003cVal\u003e\u003e::as_basis_coefficients_slice(\u0026lhs).len(),\n            4\n        );\n\n        let lhs_values = vec![lhs; n];\n        let rhs_values = vec![rhs; n];\n        let result_values = vec![result; n];\n        let lhs_index = vec![WitnessId(1); n];\n        let rhs_index = vec![WitnessId(2); n];\n        let result_index = vec![WitnessId(3); n];\n\n        // Get preprocessed index values.\n        let mut preprocessed_values = Vec::with_capacity(n * 3);\n        lhs_index\n            .iter()\n            .zip(rhs_index.iter())\n            .zip(result_index.iter())\n            .for_each(|((lhs_idx, rhs_idx), result_idx)| {\n                preprocessed_values.extend(\u0026[\n                    Val::from_u32(lhs_idx.0),\n                    Val::from_u32(rhs_idx.0),\n                    Val::from_u32(result_idx.0),\n                ]);\n            });\n\n        let trace = AddTrace {\n            lhs_values,\n            lhs_index,\n            rhs_values,\n            rhs_index,\n            result_values,\n            result_index,\n        };\n\n        let matrix: RowMajorMatrix\u003cVal\u003e = AddAir::\u003cVal, 4\u003e::trace_to_matrix(\u0026trace, 1);\n        assert_eq!(matrix.height(), n);\n        assert_eq!(matrix.width(), AddAir::\u003cVal, 4\u003e::lane_width());\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = AddAir::\u003cVal, 4\u003e::new_with_preprocessed(n, 1, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"extension field verification failed\");\n    }\n\n    #[test]\n    fn trace_to_matrix_packs_multiple_lanes() {\n        let n = 3;\n        let lanes = 2;\n        let lhs_values = vec![Val::from_u64(1); n];\n        let rhs_values = vec![Val::from_u64(2); n];\n        let result_values = vec![Val::from_u64(3); n];\n        let lhs_index = vec![WitnessId(10); n];\n        let rhs_index = vec![WitnessId(20); n];\n        let result_index = vec![WitnessId(30); n];\n\n        let trace = AddTrace {\n            lhs_values,\n            lhs_index,\n            rhs_values,\n            rhs_index,\n            result_values,\n            result_index,\n        };\n\n        let matrix: RowMajorMatrix\u003cVal\u003e = AddAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, lanes);\n        assert_eq!(matrix.width(), AddAir::\u003cVal, 1\u003e::lane_width() * lanes);\n        assert_eq!(matrix.height(), 2);\n    }\n\n    #[test]\n    fn test_add_air_padding() {\n        let n = 5;\n        let lanes = 2;\n        let lhs_values = vec![Val::from_u64(3); n];\n        let rhs_values = vec![Val::from_u64(5); n];\n        let result_values = vec![Val::from_u64(8); n];\n        let lhs_index = vec![WitnessId(1); n];\n        let rhs_index = vec![WitnessId(2); n];\n        let result_index = vec![WitnessId(3); n];\n\n        // Get preprocessed index values.\n        let mut preprocessed_values = Vec::with_capacity(n * 3);\n        lhs_index\n            .iter()\n            .zip(rhs_index.iter())\n            .zip(result_index.iter())\n            .for_each(|((lhs_idx, rhs_idx), result_idx)| {\n                preprocessed_values.extend(\u0026[\n                    Val::from_u32(lhs_idx.0),\n                    Val::from_u32(rhs_idx.0),\n                    Val::from_u32(result_idx.0),\n                ]);\n            });\n\n        let trace = AddTrace {\n            lhs_values,\n            lhs_index: lhs_index.clone(),\n            rhs_values,\n            rhs_index: rhs_index.clone(),\n            result_values,\n            result_index: result_index.clone(),\n        };\n\n        let matrix: RowMajorMatrix\u003cVal\u003e = AddAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, lanes);\n        assert_eq!(matrix.width(), 6);\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = AddAir::\u003cVal, 1\u003e::new_with_preprocessed(n, lanes, preprocessed_values);\n\n        // Check the preprocessed trace has been padded correctly.\n        let preprocessed_trace = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_trace.height(), 4);\n\n        let lane_width = AddAir::\u003cVal, 1\u003e::preprocessed_lane_width();\n        let preprocessed_width = air.preprocessed_width();\n        for i in 0..preprocessed_trace.height() {\n            for j in 0..lanes {\n                let lane_idx = i * lanes + j;\n                if lane_idx \u003c n {\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j],\n                        Val::ONE\n                    );\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j + 1],\n                        Val::from_u32(lhs_index[lane_idx].0)\n                    );\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j + 2],\n                        Val::from_u32(rhs_index[lane_idx].0)\n                    );\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j + 3],\n                        Val::from_u32(result_index[lane_idx].0)\n                    );\n                } else {\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j\n                            ..i * preprocessed_width + lane_width * (j + 1)],\n                        [Val::ZERO; 4]\n                    );\n                }\n            }\n        }\n\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n}\n","traces":[{"line":139,"address":[],"length":0,"stats":{"Line":7}},{"line":140,"address":[],"length":0,"stats":{"Line":7}},{"line":144,"address":[],"length":0,"stats":{"Line":7}},{"line":156,"address":[],"length":0,"stats":{"Line":7}},{"line":157,"address":[3514717,3514888],"length":1,"stats":{"Line":7}},{"line":173,"address":[3511152,3511200,3511104,3511296,3511344,3511248],"length":1,"stats":{"Line":10}},{"line":174,"address":[],"length":0,"stats":{"Line":10}},{"line":178,"address":[6586048,6586368,6587008,6586768,6586848,6587088,6586288,6586528,6586688,6586208,6586448,6587168,6586128,6586608,6586928],"length":1,"stats":{"Line":8}},{"line":179,"address":[],"length":0,"stats":{"Line":8}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[1836976],"length":1,"stats":{"Line":7}},{"line":194,"address":[6600916,6600953,6601193,6600873,6601156,6601236,6601033,6601113,6601076,6600996],"length":1,"stats":{"Line":7}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[3514549,3511872,3514581],"length":1,"stats":{"Line":8}},{"line":231,"address":[],"length":0,"stats":{"Line":8}},{"line":234,"address":[3511983],"length":1,"stats":{"Line":8}},{"line":236,"address":[3512147,3512012],"length":1,"stats":{"Line":8}},{"line":238,"address":[6590148,6598308,6592868,6595588,6587428],"length":1,"stats":{"Line":8}},{"line":240,"address":[3512076],"length":1,"stats":{"Line":8}},{"line":246,"address":[],"length":0,"stats":{"Line":16}},{"line":249,"address":[6593434,6587573,6590293,6595733,6598874,6587994,6593013,6590714,6596154,6598453],"length":1,"stats":{"Line":16}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[3512290],"length":1,"stats":{"Line":8}},{"line":252,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[3512474],"length":1,"stats":{"Line":8}},{"line":254,"address":[3512595],"length":1,"stats":{"Line":8}},{"line":257,"address":[3512809,3512963,3513003],"length":1,"stats":{"Line":16}},{"line":259,"address":[3513094,3512995,3513047],"length":1,"stats":{"Line":16}},{"line":266,"address":[3513272,3513076,3513128],"length":1,"stats":{"Line":16}},{"line":271,"address":[],"length":0,"stats":{"Line":16}},{"line":273,"address":[],"length":0,"stats":{"Line":8}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":16}},{"line":280,"address":[],"length":0,"stats":{"Line":8}},{"line":285,"address":[3513768,3513720],"length":1,"stats":{"Line":16}},{"line":287,"address":[3513784],"length":1,"stats":{"Line":8}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":15}},{"line":294,"address":[3514109,3514172],"length":1,"stats":{"Line":6}},{"line":299,"address":[],"length":0,"stats":{"Line":13}},{"line":300,"address":[],"length":0,"stats":{"Line":7}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[6595273,6597845,6600572,6600720,6589685,6595125,6597993,6592405,6592553,6589833],"length":1,"stats":{"Line":13}},{"line":310,"address":[3512845],"length":1,"stats":{"Line":6}},{"line":313,"address":[3512868],"length":1,"stats":{"Line":7}},{"line":316,"address":[3515817,3514944,3515811],"length":1,"stats":{"Line":6}},{"line":320,"address":[],"length":0,"stats":{"Line":6}},{"line":321,"address":[6606426,6602810,6605530,6604634,6603738],"length":1,"stats":{"Line":6}},{"line":322,"address":[],"length":0,"stats":{"Line":12}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[3515243],"length":1,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":6}},{"line":326,"address":[3515379],"length":1,"stats":{"Line":6}},{"line":327,"address":[],"length":0,"stats":{"Line":18}},{"line":329,"address":[3515762],"length":1,"stats":{"Line":6}},{"line":330,"address":[6606940,6603330,6604252,6605148,6606044],"length":1,"stats":{"Line":6}},{"line":331,"address":[6605225,6607017,6603412,6604329,6606121],"length":1,"stats":{"Line":6}},{"line":332,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[3515673],"length":1,"stats":{"Line":6}},{"line":341,"address":[],"length":0,"stats":{"Line":9}},{"line":342,"address":[1807413],"length":1,"stats":{"Line":9}},{"line":345,"address":[3466002,3465787,3464720],"length":1,"stats":{"Line":6}},{"line":347,"address":[6046727,6049383,6048055,6044055,6045399],"length":1,"stats":{"Line":6}},{"line":349,"address":[6045451,6048107,6044107,6049435,6046779],"length":1,"stats":{"Line":6}},{"line":350,"address":[],"length":0,"stats":{"Line":6}},{"line":354,"address":[6046793,6045465,6048121,6044121,6049449],"length":1,"stats":{"Line":6}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[6046938,6048244,6048266,6044149,6045588,6045491,6046819,6048147,6049594,6044268,6045610,6044246,6049572,6049475,6046916],"length":1,"stats":{"Line":12}},{"line":359,"address":[3466078,3466048,3465036],"length":1,"stats":{"Line":18}},{"line":362,"address":[],"length":0,"stats":{"Line":1}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[3465402,3465224,3465267],"length":1,"stats":{"Line":12}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[6046030,6044743,6046073,6047358,6048729,6047401,6050057,6050014,6044700,6048686],"length":1,"stats":{"Line":12}},{"line":372,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[3465446],"length":1,"stats":{"Line":6}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":12}},{"line":380,"address":[3465541],"length":1,"stats":{"Line":6}},{"line":381,"address":[3465589],"length":1,"stats":{"Line":6}},{"line":390,"address":[3485043,3488191,3491491,3488323,3489808,3489907,3491392,3492976,3494592,3496176,3497850,3493075,3494691,3488224,3497839,3486528,3488202,3484944],"length":1,"stats":{"Line":25}},{"line":392,"address":[3491431,3486567,3493015,3489847,3496215,3484983,3488263,3494631],"length":1,"stats":{"Line":24}},{"line":395,"address":[1833897,1833739,1833668,1835430,1835364,1835580],"length":1,"stats":{"Line":48}},{"line":398,"address":[],"length":0,"stats":{"Line":48}},{"line":399,"address":[3493518,3488660,3495078,3487025,3490244,3485380,3485430,3496723,3491828,3495028,3496673,3490294,3493468,3488710,3491878,3487075],"length":1,"stats":{"Line":49}},{"line":404,"address":[],"length":0,"stats":{"Line":25}},{"line":409,"address":[3487335,3485690,3496983,3493815,3492138,3495375,3490591,3487385,3493778,3497033,3488970,3490554,3489007,3492175,3485727,3495338],"length":1,"stats":{"Line":52}},{"line":414,"address":[1836143,1834515],"length":1,"stats":{"Line":26}},{"line":421,"address":[3497403,3487755,3495745,3489377,3494203,3492545,3486097,3490961],"length":1,"stats":{"Line":25}},{"line":422,"address":[1836270,1834636],"length":1,"stats":{"Line":26}},{"line":423,"address":[6185595,6187291,6188913,6166225,6163073,6167809,6164681,6158217,6150235,6171051,6153456,6159835,6169393,6155025,6148577,6161531,6146993,6172673,6174257,6175915,6177611,6179227,6180769,6182353,6156609,6151777,6183937],"length":1,"stats":{"Line":26}},{"line":424,"address":[6161593,6175977,6156671,6179289,6182415,6183999,6159897,6185657,6155087,6150297,6148639,6151839,6177673,6187353,6180831,6188975,6153525,6169455,6174319,6158279,6164743,6172735,6166287,6147055,6171113,6167871,6163135],"length":1,"stats":{"Line":25}},{"line":427,"address":[],"length":0,"stats":{"Line":25}},{"line":436,"address":[],"length":0,"stats":{"Line":1}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":438,"address":[6436182,6436247],"length":1,"stats":{"Line":1}},{"line":439,"address":[6436343,6436217,6436265],"length":1,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[6434652],"length":1,"stats":{"Line":1}},{"line":445,"address":[],"length":0,"stats":{"Line":2}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":2}},{"line":459,"address":[],"length":0,"stats":{"Line":1}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":462,"address":[],"length":0,"stats":{"Line":1}},{"line":463,"address":[6435357,6435487,6435525],"length":1,"stats":{"Line":2}},{"line":464,"address":[],"length":0,"stats":{"Line":2}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":1}},{"line":472,"address":[6435652],"length":1,"stats":{"Line":1}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":1}},{"line":477,"address":[],"length":0,"stats":{"Line":1}},{"line":478,"address":[],"length":0,"stats":{"Line":2}},{"line":479,"address":[],"length":0,"stats":{"Line":1}},{"line":483,"address":[],"length":0,"stats":{"Line":1}}],"covered":106,"coverable":133},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","const_air.rs"],"content":"//! [`ConstAir`] stores constants either in the base field or the extension field (of extension degree `D`).\n//!\n//! # Column layout\n//!\n//! The AIR is generic over an extension degree `D`.\n//! For each constant entry, we allocate `D + 1` base-field columns.\n//!\n//! - `D` columns for the constant value (basis coefficients),\n//! - `1` column for the `index`: the witness-bus index of the constant.\n//!\n//! The layout for a single row is:\n//!\n//! ```text\n//!     [value[0], value[1], ..., value[D-1], index]\n//! ```\n//!\n//! # Constraints\n//!\n//! The AIR has no constraints.\n//!\n//! # Global Interactions\n//!\n//! There is one interaction with the global witness bus:\n//!\n//! - send (index, value)\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_air::{\n    Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PairBuilder, PermutationAirBuilder,\n};\nuse p3_circuit::tables::ConstTrace;\nuse p3_circuit::utils::pad_to_power_of_two;\nuse p3_field::{BasedVectorSpace, Field};\nuse p3_lookup::lookup_traits::{AirLookupHandler, Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_uni_stark::SymbolicAirBuilder;\n\nuse crate::air::utils::get_index_lookups;\n\n/// ConstAir: vector-valued constant binding with generic extension degree D.\n///\n/// This chip exposes preprocessed constants that don't need to be committed during proving.\n/// It serves as the source of truth for constant values in the system, with each row\n/// representing a (value, index) pair where the index corresponds to a WitnessId.\n///\n/// Layout per row: [value[0..D-1], index] → width = D + 1\n/// - value[0..D-1]: Extension field value represented as D base field coefficients\n/// - index: Preprocessed WitnessId that this constant binds to\n#[derive(Debug, Clone)]\npub struct ConstAir\u003cF, const D: usize = 1\u003e {\n    /// Total number of constants defined in this trace.\n    pub height: usize,\n    /// Preprocessed values, corresponding to the indices in the trace.\n    pub preprocessed: Vec\u003cF\u003e,\n    /// Marker tying this AIR to its base field.\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, const D: usize\u003e ConstAir\u003cF, D\u003e {\n    /// Construct a new `ConstAir` instance.\n    ///\n    /// - `height`: The number of constant values to be exposed.\n    pub const fn new(height: usize) -\u003e Self {\n        Self {\n            height,\n            preprocessed: Vec::new(),\n            _phantom: PhantomData,\n        }\n    }\n\n    pub const fn new_with_preprocessed(height: usize, preprocessed: Vec\u003cF\u003e) -\u003e Self {\n        Self {\n            height,\n            preprocessed,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Number of preprocessed columns: multiplicity + index\n    pub const fn preprocessed_width() -\u003e usize {\n        2 // One column for multiplicity, one for index\n    }\n    /// Convert a `ConstTrace` into a `RowMajorMatrix` suitable for the STARK prover.\n    ///\n    /// This function is responsible for:\n    ///\n    /// 1. Decomposing each extension element in the trace into `D` basis coordinates.\n    /// 2. Padding the trace to have a power-of-two number of rows.\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026ConstTrace\u003cExtF\u003e,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        let height = trace.values.len();\n        assert_eq!(\n            height,\n            trace.index.len(),\n            \"ConstTrace column length mismatch: values vs indices\"\n        );\n        let width = D;\n\n        let mut values = Vec::with_capacity(height * width);\n\n        // Iterate over values and indices, populating the flat vector.\n        for i in 0..height {\n            // Extract basis coefficients.\n            let coeffs = trace.values[i].as_basis_coefficients_slice();\n            assert_eq!(\n                coeffs.len(),\n                D,\n                \"extension degree mismatch for ConstTrace value\"\n            );\n            // Copy coefficients into the first D columns.\n            values.extend_from_slice(coeffs);\n        }\n\n        // Pad to power of two by repeating last row\n        pad_to_power_of_two(\u0026mut values, width, height);\n\n        RowMajorMatrix::new(values, width)\n    }\n\n    pub fn trace_to_preprocessed\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(trace: \u0026ConstTrace\u003cExtF\u003e) -\u003e Vec\u003cF\u003e {\n        trace\n            .index\n            .iter()\n            .map(|widx| F::from_u64(widx.0 as u64))\n            .collect()\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for ConstAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        D\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        let mut preprocessed_values = self\n            .preprocessed\n            .iter()\n            .flat_map(|v| [F::ONE, *v])\n            .collect::\u003cVec\u003cF\u003e\u003e();\n        pad_to_power_of_two(\u0026mut preprocessed_values, 2, self.preprocessed.len());\n\n        Some(RowMajorMatrix::new(\n            preprocessed_values,\n            2, // Two columns: one for the multiplicity (0 for padding, 1 otherwise), one for the index\n        ))\n    }\n}\n\nimpl\u003cAB: AirBuilder, const D: usize\u003e Air\u003cAB\u003e for ConstAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn eval(\u0026self, _builder: \u0026mut AB) {\n        // No constraints for constants in Stage 1\n    }\n}\n\nimpl\u003cAB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues, const D: usize\u003e\n    AirLookupHandler\u003cAB\u003e for ConstAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        // There is only one lookup to register in this AIR.\n        vec![0]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e {\n        // Create symbolic air builder to access symbolic variables\n        let symbolic_air_builder = SymbolicAirBuilder::\u003cAB::F\u003e::new(\n            Self::preprocessed_width(),\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            1,\n            0,\n        );\n\n        let symbolic_main = symbolic_air_builder.main();\n        let symbolic_main_local = symbolic_main.row_slice(0).unwrap();\n\n        let preprocessed = symbolic_air_builder.preprocessed();\n        let preprocessed_local = preprocessed.row_slice(0).unwrap();\n\n        let lookup_inps = get_index_lookups::\u003cAB, D\u003e(\n            0,\n            0,\n            1,\n            \u0026symbolic_main_local,\n            \u0026preprocessed_local,\n            Direction::Send,\n        );\n\n        assert!(lookup_inps.len() == 1);\n        let lookup = AirLookupHandler::\u003cAB\u003e::register_lookup(\n            self,\n            Kind::Global(\"WitnessChecks\".to_string()),\n            \u0026lookup_inps[0],\n        );\n\n        vec![lookup]\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_circuit::WitnessId;\n    use p3_field::PrimeCharacteristicRing;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_matrix::Matrix;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    type F = BabyBear;\n    type EF = BinomialExtensionField\u003cF, 4\u003e;\n\n    #[test]\n    fn test_const_air_base_field() {\n        // Create a CONST trace with several constant values\n        // Toy example used: assert(37 * x - 111 = 0)\n        let const_values = vec![\n            F::from_u64(37),  // CONST 1 37\n            F::from_u64(111), // CONST 3 111\n            F::from_u64(0),   // CONST 4 0\n        ];\n        // Witness IDs these constants bind to\n        let const_indices = vec![WitnessId(1), WitnessId(3), WitnessId(4)];\n\n        let preprocessed_values = const_indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let trace = ConstTrace {\n            index: const_indices.clone(),\n            values: const_values,\n        };\n\n        // Convert to matrix using the ConstAir\n        let matrix = ConstAir::\u003cF, 1\u003e::trace_to_matrix(\u0026trace);\n\n        // Verify matrix dimensions\n        //\n        // D + 1 = 1 + 1 = 2 (value + index)\n        assert_eq!(matrix.width(), 1);\n\n        // Height should be next power of two \u003e= 3\n        let height = matrix.height();\n        assert_eq!(height, 4);\n\n        // Verify the data layout: [value, index] per row\n        let data = \u0026matrix.values;\n\n        // First row: value=37, index=1\n        assert_eq!(data[0], F::from_u64(37));\n\n        // Second row: value=111, index=3\n        assert_eq!(data[1], F::from_u64(111));\n\n        // Third row: value=0, index=4\n        assert_eq!(data[2], F::from_u64(0));\n\n        // Test that we can prove and verify (should succeed since no constraints)\n        let config = build_test_config();\n        // No public inputs for CONST chip\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let air = ConstAir::\u003cF, 1\u003e::new_with_preprocessed(height, preprocessed_values);\n\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), height);\n\n        // Assert the preprocessed values were properly created.\n        const_indices.iter().enumerate().for_each(|(i, const_idx)| {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            // The multiplicity should be 1 for all active rows.\n            assert_eq!(row[0], F::ONE);\n            // Check the witness index.\n            assert_eq!(row[1], F::from_u32(const_idx.0));\n        });\n        // Check the padding row\n        let last_row = preprocessed_matrix.row_slice(height - 1).unwrap();\n        assert_eq!(last_row[0], F::ZERO);\n        assert_eq!(last_row[1], F::ZERO);\n\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(height)).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"CONST chip verification failed\");\n    }\n\n    #[test]\n    fn test_const_air_extension_field() {\n        // Create extension field constants with all non-zero coefficients\n        let const1 = EF::from_basis_coefficients_slice(\u0026[\n            F::from_u64(1), // a0\n            F::from_u64(2), // a1\n            F::from_u64(3), // a2\n            F::from_u64(4), // a3\n        ])\n        .unwrap();\n\n        let const2 = EF::from_basis_coefficients_slice(\u0026[\n            F::from_u64(5), // b0\n            F::from_u64(6), // b1\n            F::from_u64(7), // b2\n            F::from_u64(8), // b3\n        ])\n        .unwrap();\n\n        let const_values = vec![const1, const2];\n        let const_indices = vec![WitnessId(10), WitnessId(20)];\n        let preprocessed_values = const_indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let trace = ConstTrace {\n            index: const_indices,\n            values: const_values,\n        };\n\n        // Convert to matrix for D=4 extension field\n        let matrix: RowMajorMatrix\u003cF\u003e = ConstAir::\u003cF, 4\u003e::trace_to_matrix(\u0026trace);\n\n        // Verify matrix dimensions: D = 4 (4 value coefficients)\n        assert_eq!(matrix.width(), 4);\n        let height = matrix.height();\n        assert_eq!(height, 2);\n\n        let data = \u0026matrix.values;\n\n        // First row: [a0, a1, a2, a3] = [1, 2, 3, 4]\n        assert_eq!(data[0], F::from_u64(1));\n        assert_eq!(data[1], F::from_u64(2));\n        assert_eq!(data[2], F::from_u64(3));\n        assert_eq!(data[3], F::from_u64(4));\n\n        // Second row: [b0, b1, b2, b3] = [5, 6, 7, 8]\n        assert_eq!(data[4], F::from_u64(5));\n        assert_eq!(data[5], F::from_u64(6));\n        assert_eq!(data[6], F::from_u64(7));\n        assert_eq!(data[7], F::from_u64(8));\n\n        // Test proving and verification for extension field\n        let config = build_test_config();\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let air = ConstAir::\u003cF, 4\u003e::new_with_preprocessed(height, preprocessed_values);\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        let row0 = preprocessed_matrix.row_slice(0).unwrap();\n        // Assert that the multipliticy is 1 since the furst row is active\n        assert_eq!(row0[0], F::ONE);\n        // Assert that the witness index is correct.\n        assert_eq!(row0[1], F::from_u64(10));\n        let last_row = preprocessed_matrix.row_slice(height - 1).unwrap();\n        // Assert that the multipliticy is 1 since the furst row is active\n        assert_eq!(last_row[0], F::ONE);\n        // Assert that the witness index is correct.\n        assert_eq!(last_row[1], F::from_u64(20));\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(height)).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"Extension field CONST verification failed\");\n    }\n}\n","traces":[{"line":68,"address":[2948640,2948448,2948256,2948160,2948544,2948352],"length":1,"stats":{"Line":7}},{"line":71,"address":[2948471,2948375,2948279,2948567,2948663,2948183],"length":1,"stats":{"Line":7}},{"line":76,"address":[],"length":0,"stats":{"Line":7}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[2947939,2947088,2947971],"length":1,"stats":{"Line":6}},{"line":97,"address":[2947126],"length":1,"stats":{"Line":6}},{"line":98,"address":[2947163],"length":1,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[6610131,6613715,6612819,6611027,6611923],"length":1,"stats":{"Line":6}},{"line":105,"address":[2947374,2947295],"length":1,"stats":{"Line":6}},{"line":108,"address":[2947344,2947438],"length":1,"stats":{"Line":12}},{"line":110,"address":[],"length":0,"stats":{"Line":12}},{"line":111,"address":[6610574,6611470,6613262,6614158,6612370],"length":1,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[6612578,6614266,6611578,6610682,6613470,6611678,6614366,6613370,6612478,6610782],"length":1,"stats":{"Line":12}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[2947597],"length":1,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[2948142,2948086,2948128],"length":1,"stats":{"Line":19}},{"line":136,"address":[6056768,6056928,6056896,6056704,6056816,6056736,6056800,6056864,6056848,6056880,6056832,6056784,6056752,6056912,6056720],"length":1,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[2895536,2895881,2895852],"length":1,"stats":{"Line":6}},{"line":141,"address":[6055157,6054805,6055509,6055877,6056229],"length":1,"stats":{"Line":6}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[2895888,2895898,2895610],"length":1,"stats":{"Line":18}},{"line":146,"address":[2895643,2895711],"length":1,"stats":{"Line":12}},{"line":148,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":159,"address":[2943744,2943776,2943792,2943808,2943760,2943840,2943824,2943856],"length":1,"stats":{"Line":23}},{"line":169,"address":[6444928],"length":1,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[6443814,6443738],"length":1,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":2}}],"covered":40,"coverable":52},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","mod.rs"],"content":"pub mod add_air;\npub mod const_air;\npub mod mul_air;\npub mod public_air;\npub mod utils;\npub mod witness_air;\n\n#[cfg(test)]\npub mod test_utils;\n\npub use add_air::AddAir;\npub use const_air::ConstAir;\npub use mul_air::MulAir;\npub use public_air::PublicAir;\npub use witness_air::WitnessAir;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","mul_air.rs"],"content":"//! [`MulAir`] defines the AIR for proving multiplication and division over both base and extension fields.\n//!\n//! Conceptually, each row of the trace encodes one or more multiplication constraints of the form\n//! $$\n//!     lhs * rhs = result\n//! $$\n//!\n//! When the circuit wants to prove a division, it is expressed as a multiplication by rewriting\n//! $$\n//!     a / b = c\n//! $$\n//!\n//! as\n//! $$\n//!     b * c = a\n//! $$\n//!\n//! so that division is handled uniformly as a multiplication gate in the AIR.\n//!\n//! The AIR is generic over an extension degree `D`. Each operand and result is treated as\n//! an element of an extension field of degree `D` over the base field. Internally, this is\n//! represented as `D` base-field coordinates (basis coefficients).\n//!\n//! The runtime parameter `lanes` controls how many independent multiplications are packed\n//! side-by-side in a single row of the trace.\n//!\n//! # Column layout\n//!\n//! For each logical operation (lane) we allocate `3 * D` base-field columns. These are\n//! grouped as:\n//!\n//! - `D` columns for the left operand (lhs) basis coefficients,\n//! - `D` columns for the right operand (rhs) basis coefficients,\n//! - `D` columns for the result operand basis coefficients,\n//!\n//! In other words, for a single lane the layout is:\n//!\n//! ```text\n//!     [lhs[0..D), rhs[0..D), result[0..D)]\n//! ```\n//!\n//! We also allocate `3` preprocessed base-field columns:\n//!\n//! - 1 column for the lhs operand index within the `Witness` table,\n//! - 1 column for the rhs operand index,\n//! - 1 column for the result operand index,\n//!\n//! A single row can pack several of these lanes side-by-side, so the full row layout is\n//! this pattern repeated `lanes` times.\n//!\n//! # Constraints\n//!\n//! ## Base Field (D=1)\n//!\n//! Let `left`, `right`, and `output` be the single base-field coordinates. The AIR\n//! enforces the constraint:\n//!\n//! $$\n//! left \\cdot right - output = 0.\n//! $$\n//!\n//! ## Binomial Extension (D \u003e 1)\n//!\n//! This AIR currently supports binomial extensions using a polynomial basis $\\{1, x, \\dots, x^{D-1}\\}$\n//! where the field is defined by $x^D = W$ for some $W \\in F$.\n//!\n//! - $L(x) = \\sum_{i=0}^{D-1} left[i] x^i$\n//! - $R(x) = \\sum_{i=0}^{D-1} right[i] x^i$\n//! - $O(x) = \\sum_{i=0}^{D-1} output[i] x^i$\n//!\n//! The AIR enforces the polynomial identity:\n//!\n//! $$\n//! L(x) \\cdot R(x) \\equiv O(x) \\pmod{x^D - W}\n//! $$\n//!\n//! # Global interactions\n//!\n//! Each operation (lane) has three interactions with the global witness bus:\n//!\n//! - send `(index_left,  left)`\n//! - send `(index_right, right)`\n//! - send `(index_output, result)`\n//!\n//! The AIR defined here focuses on the algebraic relation between the operands. The\n//! correctness of the indices with respect to the global witness bus is enforced by the\n//! bus interaction logic elsewhere in the system.\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::iter;\nuse core::marker::PhantomData;\n\nuse itertools::Itertools;\nuse p3_air::{\n    Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PairBuilder, PermutationAirBuilder,\n};\nuse p3_circuit::tables::MulTrace;\nuse p3_circuit::utils::pad_to_power_of_two;\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_lookup::lookup_traits::{AirLookupHandler, Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_uni_stark::SymbolicAirBuilder;\n\nuse crate::air::utils::get_index_lookups;\n\n/// AIR for proving multiplication operations: lhs * rhs = result.\n///\n/// Parameterised over extension degree `D` and a runtime lane count controlling how many\n/// multiplications are packed side-by-side in each row.\n///\n/// Column layout (main trace):\n///   - For D == 1 (base field):\n///     [lhs_value, rhs_value, result_value]  (width = 6)\n///\n///   - For D \u003e 1 (extension, using a basis of size D):\n///     [lhs[0..D-1], rhs[0..D-1], result[0..D-1]] (width = 3*D)\n///\n///   - Preprocessed columns:\n///     [lhs_index, rhs_index, result_index] (width = 3)\n///\n/// If `w_binomial` is `Some(W)`, we assume a polynomial basis {1, x, ..., x^(D-1)}\n/// for the binomial extension defined by x^D = W. Constraints are generated via\n/// schoolbook convolution with the reduction x^k = W * x^(k-D) for k \u003e= D.\n#[derive(Debug, Clone)]\npub struct MulAir\u003cF, const D: usize = 1\u003e {\n    /// Total number of logical multiplication operations (gates) in the trace.\n    pub num_ops: usize,\n    /// Number of independent multiplication gates packed per trace row.\n    ///\n    /// The last row is padded if the number of operations is not a multiple of this value.\n    pub lanes: usize,\n    /// For binomial extensions $x^D = W$ over a polynomial basis.\n    ///\n    /// This should be:\n    /// - `Some(W)` if `D \u003e 1`,\n    /// - `None` if `D == 1`.\n    pub w_binomial: Option\u003cF\u003e,\n    /// Flattened values of the preprocessed columns. They are used for generating the common data,\n    /// as well as by the prover, to compute the constraint polynomial.\n    ///\n    /// Note that the verifier does not need those values.\n    /// When providing instances to the verifier, this field can be left empty.\n    /// Preprocessed values correspond to the indices of the inputs and outputs within the `Witness` table.\n    pub preprocessed: Vec\u003cF\u003e,\n    /// Number of lookup columns registered so far.\n    pub num_lookup_columns: usize,\n    /// Marker tying this AIR to its base field.\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field + PrimeCharacteristicRing, const D: usize\u003e MulAir\u003cF, D\u003e {\n    /// Construct a new `MulAir` for base-field operations (D=1).\n    ///\n    /// Panics if `lanes == 0` or `D \u003e 1`.\n    pub const fn new(num_ops: usize, lanes: usize) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        assert!(D == 1, \"Use new_binomial for D \u003e 1\");\n        Self {\n            num_ops,\n            lanes,\n            w_binomial: None,\n            preprocessed: Vec::new(),\n            num_lookup_columns: 0,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `MulAir` for base-field operations (D=1).\n    ///\n    /// Panics if `lanes == 0` or `D \u003e 1`.\n    pub const fn new_with_preprocessed(num_ops: usize, lanes: usize, preprocessed: Vec\u003cF\u003e) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        assert!(D == 1, \"Use new_binomial for D \u003e 1\");\n        Self {\n            num_ops,\n            lanes,\n            w_binomial: None,\n            preprocessed,\n            num_lookup_columns: 0,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `MulAir` for binomial extension-field operations ($x^D = W$, D \u003e 1).\n    ///\n    /// Panics if `lanes == 0` or if `D \u003c 2`.\n    pub const fn new_binomial(num_ops: usize, lanes: usize, w: F) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        assert!(D \u003e= 2, \"Binomial constructor requires D \u003e= 2\");\n        Self {\n            num_ops,\n            lanes,\n            w_binomial: Some(w),\n            preprocessed: Vec::new(),\n            num_lookup_columns: 0,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `MulAir` for binomial extension-field operations ($x^D = W$, D \u003e 1).\n    ///\n    /// Panics if `lanes == 0` or if `D \u003c 2`.\n    pub const fn new_binomial_with_preprocessed(\n        num_ops: usize,\n        lanes: usize,\n        w: F,\n        preprocessed: Vec\u003cF\u003e,\n    ) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n        assert!(D \u003e= 2, \"Binomial constructor requires D \u003e= 2\");\n        Self {\n            num_ops,\n            lanes,\n            w_binomial: Some(w),\n            preprocessed,\n            num_lookup_columns: 0,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Number of base-field columns occupied by a single lane.\n    ///\n    /// Each lane stores:\n    /// - `3 * D` coordinates (for `lhs`, `rhs`, and `result`),\n    ///\n    /// The total width of a single row is `3 * D`\n    pub const fn lane_width() -\u003e usize {\n        3 * D\n    }\n\n    /// Total number of columns in the main trace for this AIR instance.\n    pub const fn total_width(\u0026self) -\u003e usize {\n        self.lanes * Self::lane_width()\n    }\n\n    /// Number of preprocessed base-field columns occupied by a single lane.\n    ///\n    /// Each lane stores 1 multiplicity (0 when the operation is padding, 1 otherwise) and 3 indices (one for each operand)\n    pub const fn preprocessed_lane_width() -\u003e usize {\n        4\n    }\n\n    /// Number of preprocessed columns for this AIR instance.\n    ///\n    /// Each lane stores 3 indices (one for each operand)\n    pub const fn preprocessed_width(\u0026self) -\u003e usize {\n        self.lanes * Self::preprocessed_lane_width()\n    }\n\n    /// Convert a `MulTrace` into a `RowMajorMatrix` suitable for the STARK prover.\n    ///\n    /// This function is responsible for:\n    ///\n    /// 1. Taking the logical operations from the `MulTrace`:\n    ///    - `lhs_values`, `rhs_values`, `result_values` (extension elements),\n    ///    - `lhs_index`, `rhs_index`, `result_index` (witness-bus indices),\n    /// 2. Decomposing each extension element into its `D` basis coordinates,\n    /// 3. Packing `lanes` operations side-by-side in each row,\n    /// 4. Padding the trace to have a power-of-two number of rows for FFT-friendly\n    ///    execution by the STARK prover.\n    ///\n    /// The resulting matrix has:\n    ///\n    /// - width = lanes * `LANE_WIDTH`,\n    /// - height equal to the number of rows after packing and padding.\n    ///\n    /// The layout within a row is:\n    ///\n    /// ```text\n    ///     [lhs[0..D), lhs_index, rhs[0..D), rhs_index, result[0..D), result_index] repeated `lanes` times.\n    /// ```\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026MulTrace\u003cExtF\u003e,\n        lanes: usize,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        // Lanes must be strictly positive.\n        //\n        // Zero lanes would make it impossible to construct a row.\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        // Per-lane width in base-field columns.\n        let lane_width = Self::lane_width();\n        // Total width of each row once all lanes are packed.\n        let width = lane_width * lanes;\n        // Number of logical operations we need to pack into the trace.\n        let op_count = trace.lhs_values.len();\n        // Number of rows needed to hold `op_count` operations.\n        let row_count = op_count.div_ceil(lanes);\n\n        // Pre-allocate the entire trace as a flat vector in row-major order.\n        //\n        // We start with `row_count` rows, each of width `width`, and fill it with zeros.\n        // This automatically provides a clean padding for any unused lanes in the final row.\n        let mut values = F::zero_vec(width * row_count.max(1));\n\n        // Iterate over all operations in lockstep across the trace arrays.\n        for (op_idx, ((lhs_val, rhs_val), res_val)) in trace\n            .lhs_values\n            .iter()\n            .zip(trace.rhs_values.iter())\n            .zip(trace.result_values.iter())\n            .enumerate()\n        {\n            // Determine the target row index.\n            let row = op_idx / lanes;\n            // Determine which lane within that row this operation occupies.\n            let lane = op_idx % lanes;\n\n            // Compute the starting column index (cursor) for this lane within the flat vector.\n            //\n            // Row-major layout means:\n            //   row_offset = row * width,\n            //   lane_offset = lane * lane_width.\n            let mut cursor = (row * width) + (lane * lane_width);\n\n            // Write LHS coordinates and LHS witness index.\n            //\n            // Extract the basis coefficients of the lhs extension element.\n            let lhs_coeffs = lhs_val.as_basis_coefficients_slice();\n            // Sanity check: the extension degree must match the generic parameter `D`.\n            assert_eq!(\n                lhs_coeffs.len(),\n                D,\n                \"Extension field degree mismatch for lhs\"\n            );\n            // Copy the `D` lhs coordinates into the trace row.\n            values[cursor..cursor + D].copy_from_slice(lhs_coeffs);\n            cursor += D;\n\n            // Write RHS coordinates and RHS witness index.\n            //\n            // Extract the basis coefficients of the rhs extension element.\n            let rhs_coeffs = rhs_val.as_basis_coefficients_slice();\n            // Sanity check: the extension degree must match the generic parameter `D`.\n            assert_eq!(\n                rhs_coeffs.len(),\n                D,\n                \"Extension field degree mismatch for rhs\"\n            );\n            // Copy the `D` rhs coordinates into the trace row.\n            values[cursor..cursor + D].copy_from_slice(rhs_coeffs);\n            cursor += D;\n\n            // Write result coordinates and result witness index.\n            //\n            // Extract the basis coefficients of the result extension element.\n            let res_coeffs = res_val.as_basis_coefficients_slice();\n            debug_assert_eq!(\n                res_coeffs.len(),\n                D,\n                \"Extension field degree mismatch for result\"\n            );\n            // Copy the `D` result coordinates into the trace row.\n            values[cursor..cursor + D].copy_from_slice(res_coeffs);\n        }\n\n        // Pad the matrix to a power-of-two height.\n        pad_to_power_of_two(\u0026mut values, width, row_count);\n\n        // Build the row-major matrix with the computed width.\n        RowMajorMatrix::new(values, width)\n    }\n\n    pub fn trace_to_preprocessed\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026MulTrace\u003cExtF\u003e,\n        lanes: usize,\n    ) -\u003e Vec\u003cF\u003e {\n        let total_preprocessed_len =\n            trace.lhs_values.len() * Self::preprocessed_lane_width() * lanes;\n        let mut preprocessed = Vec::with_capacity(total_preprocessed_len);\n        trace\n            .lhs_index\n            .iter()\n            .zip(trace.rhs_index.clone())\n            .zip(trace.result_index.clone())\n            .for_each(|((lhs_idx, rhs_idx), res_idx)| {\n                preprocessed.extend(\u0026[\n                    F::from_u64(lhs_idx.0 as u64),\n                    F::from_u64(rhs_idx.0 as u64),\n                    F::from_u64(res_idx.0 as u64),\n                ]);\n            });\n\n        preprocessed\n    }\n}\n\nimpl\u003cAB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues, const D: usize\u003e\n    AirLookupHandler\u003cAB\u003e for MulAir\u003cAB::F, D\u003e\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        let new_idx = self.num_lookup_columns;\n        self.num_lookup_columns += 1;\n        vec![new_idx]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e {\n        let mut lookups = Vec::new();\n        self.num_lookup_columns = 0;\n        let preprocessed_width = self.preprocessed_width();\n\n        // Create symbolic air builder to access symbolic variables\n        let symbolic_air_builder = SymbolicAirBuilder::\u003cAB::F\u003e::new(\n            preprocessed_width,\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            0,\n            0,\n        );\n\n        let symbolic_main = symbolic_air_builder.main();\n        let symbolic_main_local = symbolic_main.row_slice(0).unwrap();\n\n        let preprocessed = symbolic_air_builder.preprocessed();\n        let preprocessed_local = preprocessed.row_slice(0).unwrap();\n\n        for lane in 0..self.lanes {\n            let lane_offset = lane * Self::lane_width();\n            let preprocessed_lane_offset = lane * Self::preprocessed_lane_width();\n\n            let lane_lookup_inputs = get_index_lookups::\u003cAB, D\u003e(\n                lane_offset,\n                preprocessed_lane_offset,\n                3,\n                \u0026symbolic_main_local,\n                \u0026preprocessed_local,\n                Direction::Send,\n            );\n            lookups.extend(lane_lookup_inputs.into_iter().map(|inps| {\n                AirLookupHandler::\u003cAB\u003e::register_lookup(\n                    self,\n                    Kind::Global(\"WitnessChecks\".to_string()),\n                    \u0026inps,\n                )\n            }));\n        }\n        lookups\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for MulAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        self.total_width()\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        let original_height = self.num_ops.div_ceil(self.lanes);\n\n        // Add the multiplicity to the preprocessed values.\n        let mut preprocessed_values = self\n            .preprocessed\n            .iter()\n            .chunks(Self::preprocessed_lane_width() - 1)\n            .into_iter()\n            .flat_map(|chunk| iter::once(F::ONE).chain(chunk.into_iter().cloned()))\n            .collect::\u003cVec\u003cF\u003e\u003e();\n\n        debug_assert!(\n            preprocessed_values.len() % Self::preprocessed_lane_width() == 0,\n            \"Preprocessed trace length mismatch for MulAir: Got {} values, expected multiple of {}\",\n            preprocessed_values.len(),\n            Self::preprocessed_lane_width()\n        );\n\n        let padding_len =\n            self.preprocessed_width() - preprocessed_values.len() % self.preprocessed_width();\n        if padding_len != self.preprocessed_width() {\n            preprocessed_values.extend(vec![F::ZERO; padding_len]);\n        }\n        pad_to_power_of_two(\n            \u0026mut preprocessed_values,\n            self.preprocessed_width(),\n            original_height,\n        );\n        Some(RowMajorMatrix::new(\n            preprocessed_values,\n            self.preprocessed_width(),\n        ))\n    }\n}\n\nimpl\u003cAB: AirBuilder, const D: usize\u003e Air\u003cAB\u003e for MulAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        // Access the main trace view from the builder.\n        let main = builder.main();\n\n        // Make sure that the matrix width matches what this AIR expects.\n        debug_assert_eq!(main.width(), self.total_width(), \"column width mismatch\");\n\n        // Get the evaluation at evaluation point `zeta`\n        let local = main.row_slice(0).expect(\"matrix must be non-empty\");\n        let lane_width = Self::lane_width();\n\n        // Specialized Path for D=1 (Base Field)\n        if D == 1 {\n            // For D=1, lane_width is 3.\n            // Layout: [lhs, lhs_idx, rhs, rhs_idx, result, result_idx]\n            debug_assert_eq!(lane_width, 3);\n\n            for lane_data in local.chunks_exact(lane_width) {\n                let lhs_value = lane_data[0].clone();\n                // lane_data[1] is lhs_idx\n                let rhs_value = lane_data[1].clone();\n                // lane_data[3] is rhs_idx\n                let out_value = lane_data[2].clone();\n                // lane_data[5] is result_idx\n\n                // Enforce: lhs * rhs - result = 0\n                builder.assert_zero(lhs_value * rhs_value - out_value);\n            }\n        } else {\n            // Specialized Path for D \u003e 1 (Extension Field)\n\n            // For D \u003e 1, we must have the binomial parameter W.\n            //\n            // We can 'expect' it once, outside the loop.\n            let w = self\n                .w_binomial\n                .as_ref()\n                .map(|w| AB::Expr::from(*w))\n                .expect(\"MulAir with D\u003e1 requires binomial parameter W\");\n\n            for lane_data in local.chunks_exact(lane_width) {\n                // Data Extraction\n                //\n                // We are proving a polynomial multiplication:\n                //   L(x) * R(x) = O(x)  (mod x^D - W)\n                //\n                // L(x) = lhs[0] + lhs[1]x + ... + lhs[D-1]x^(D-1)\n                // R(x) = rhs[0] + rhs[1]x + ... + rhs[D-1]x^(D-1)\n                // O(x) = result[0] + result[1]x + ... + result[D-1]x^(D-1)\n                //\n                // Here, we extract the slices of coefficients for L(x), R(x), and O(x).\n\n                // Split off the lhs block and its index:\n                //   lhs_and_idx = [lhs[0..D), lhs_idx]\n                //   rest        = [rhs[0..D), rhs_idx, result[0..D), result_idx]\n                let (lhs_slice, rest) = lane_data.split_at(D);\n\n                // Split the remaining data:\n                //   rhs_and_idx    = [rhs[0..D), rhs_idx]\n                //   result_and_idx = [result[0..D), result_idx]\n                let (rhs_slice, result_slice) = rest.split_at(D);\n\n                // Compute the Product C(x) = L(x) * R(x) (mod x^D - W)\n                //\n                // Accumulator for the coefficients of the reduced product polynomial.\n                let mut acc = vec![AB::Expr::ZERO; D];\n\n                // We perform \"schoolbook\" multiplication term-by-term.\n                //\n                // We reduce each term *immediately* using the rule $x^D = W$.\n                for (i, lhs) in lhs_slice.iter().enumerate().take(D) {\n                    // This is the i-th term of L(x): lhs[i] * x^i\n                    for (j, rhs) in rhs_slice.iter().enumerate().take(D) {\n                        // This is the j-th term of R(x): rhs[j] * x^j\n\n                        // Multiplying them gives: (lhs[i] * rhs[j]) * x^(i+j)\n                        let term = lhs.clone() * rhs.clone();\n                        let k = i + j;\n\n                        // Now, we reduce the $x^k$ term and add its coefficient\n                        // (which is 'term') to the correct spot in 'acc'.\n                        if k \u003c D {\n                            // Case 1: k \u003c D\n                            //\n                            // The degree 'k' is already in the valid range [0, D-1].\n                            // No reduction is needed.\n                            // The term is: term * x^k\n                            // We add 'term' to the k-th coefficient in our accumulator.\n                            //\n                            // Math: acc[k] = acc[k] + term\n                            acc[k] += term;\n                        } else {\n                            // Case 2: k \u003e= D\n                            //\n                            // The degree 'k' is \"out of bounds\" and must be reduced.\n                            // We use the rule: $x^D = W$\n                            //\n                            // We can rewrite $x^k$ as:\n                            //   $x^k = x^{k-D} * x^D$\n                            //\n                            // Substituting the rule gives:\n                            //   $x^k = x^{k-D} * W$\n                            //\n                            // So our full term (term * x^k) becomes:\n                            //   term * (W * x^{k-D})\n                            //\n                            // This is a new term of degree (k-D), with a new\n                            // coefficient of (term * W).\n                            //\n                            // Math: acc[k-D] = acc[k-D] + (term * W)\n                            acc[k - D] += w.clone() * term;\n                        }\n                    }\n                }\n\n                // Enforce the Constraint\n                //\n                // At this point, 'acc' holds the coefficients of the correctly\n                // computed product C(x).\n                //\n                // 'result_slice' holds the coefficients of the polynomial O(x)\n                // provided by the prover (the witness).\n                //\n                // We must assert that they are equal, coefficient by coefficient.\n                //\n                // Enforces: C(x) = O(x)\n                for k in 0..D {\n                    // result_slice[k] - acc[k] = 0\n                    builder.assert_zero(result_slice[k].clone() - acc[k].clone());\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n    use alloc::vec::Vec;\n\n    use p3_baby_bear::BabyBear as Val;\n    use p3_circuit::WitnessId;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    #[test]\n    fn prove_verify_mul_base_field() {\n        let n = 8usize;\n        let lhs_values = vec![Val::from_u64(3); n];\n        let rhs_values = vec![Val::from_u64(7); n];\n        let result_values = vec![Val::from_u64(21); n];\n        let lhs_index = vec![WitnessId(1); n];\n        let rhs_index = vec![WitnessId(2); n];\n        let result_index = vec![WitnessId(3); n];\n        let mut preprocessed_values = Vec::with_capacity(n * 3);\n        lhs_index\n            .iter()\n            .zip(rhs_index.iter())\n            .zip(result_index.iter())\n            .for_each(|((lhs_idx, rhs_idx), result_idx)| {\n                preprocessed_values.extend(\u0026[\n                    Val::from_u32(lhs_idx.0),\n                    Val::from_u32(rhs_idx.0),\n                    Val::from_u32(result_idx.0),\n                ]);\n            });\n        let trace = MulTrace {\n            lhs_values,\n            lhs_index,\n            rhs_values,\n            rhs_index,\n            result_values,\n            result_index,\n        };\n\n        let matrix: RowMajorMatrix\u003cVal\u003e = MulAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n        assert_eq!(matrix.width(), MulAir::\u003cVal, 1\u003e::lane_width());\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = MulAir::\u003cVal, 1\u003e::new_with_preprocessed(n, 1, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn prove_verify_mul_extension_binomial_d4() {\n        type ExtField = BinomialExtensionField\u003cVal, 4\u003e;\n\n        let n = 4usize;\n\n        // Derive W from the field definition by computing x^4, where x = (0,1,0,0).\n        let x =\n            ExtField::from_basis_coefficients_slice(\u0026[Val::ZERO, Val::ONE, Val::ZERO, Val::ZERO])\n                .unwrap();\n        let x4 = x.exp_u64(4);\n\n        let x4_coeffs = \u003cExtField as BasedVectorSpace\u003cVal\u003e\u003e::as_basis_coefficients_slice(\u0026x4);\n        // In a binomial polynomial basis, x^4 should be scalar: (W, 0, 0, 0).\n        assert_eq!(x4_coeffs[1], Val::ZERO);\n        assert_eq!(x4_coeffs[2], Val::ZERO);\n        assert_eq!(x4_coeffs[3], Val::ZERO);\n\n        let w: Val = x4_coeffs[0];\n        assert!(!w.is_zero(), \"W must be non-zero\");\n\n        let lhs = ExtField::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(3), // a0\n            Val::from_u64(1), // a1\n            Val::from_u64(4), // a2\n            Val::from_u64(2), // a3\n        ])\n        .unwrap();\n\n        let rhs = ExtField::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(2), // b0\n            Val::from_u64(5), // b1\n            Val::from_u64(1), // b2\n            Val::from_u64(3), // b3\n        ])\n        .unwrap();\n\n        let result = lhs * rhs;\n\n        let lhs_values = vec![lhs; n];\n        let rhs_values = vec![rhs; n];\n        let result_values = vec![result; n];\n        let lhs_index = vec![WitnessId(1); n];\n        let rhs_index = vec![WitnessId(2); n];\n        let result_index = vec![WitnessId(3); n];\n\n        // Get preprocessed index values.\n        let mut preprocessed_values = Vec::with_capacity(n * 3);\n        lhs_index\n            .iter()\n            .zip(rhs_index.iter())\n            .zip(result_index.iter())\n            .for_each(|((lhs_idx, rhs_idx), result_idx)| {\n                preprocessed_values.extend(\u0026[\n                    Val::from_u32(lhs_idx.0),\n                    Val::from_u32(rhs_idx.0),\n                    Val::from_u32(result_idx.0),\n                ]);\n            });\n\n        let trace = MulTrace {\n            lhs_values,\n            lhs_index,\n            rhs_values,\n            rhs_index,\n            result_values,\n            result_index,\n        };\n\n        let matrix: RowMajorMatrix\u003cVal\u003e = MulAir::\u003cVal, 4\u003e::trace_to_matrix(\u0026trace, 1);\n        assert_eq!(matrix.height(), n);\n        assert_eq!(matrix.width(), MulAir::\u003cVal, 4\u003e::lane_width());\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = MulAir::\u003cVal, 4\u003e::new_binomial_with_preprocessed(n, 1, w, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"extension field verification failed\");\n    }\n\n    #[test]\n    fn trace_to_matrix_packs_multiple_lanes() {\n        let n = 3;\n        let lanes = 2;\n        let lhs_values = vec![Val::from_u64(1); n];\n        let rhs_values = vec![Val::from_u64(2); n];\n        let result_values = vec![Val::from_u64(2); n];\n        let lhs_index = vec![WitnessId(10); n];\n        let rhs_index = vec![WitnessId(20); n];\n        let result_index = vec![WitnessId(30); n];\n\n        let trace = MulTrace {\n            lhs_values,\n            lhs_index,\n            rhs_values,\n            rhs_index,\n            result_values,\n            result_index,\n        };\n\n        let matrix: RowMajorMatrix\u003cVal\u003e = MulAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, lanes);\n        assert_eq!(matrix.width(), MulAir::\u003cVal, 1\u003e::lane_width() * lanes);\n        assert_eq!(matrix.height(), 2);\n    }\n\n    #[test]\n    fn test_mul_air_padding() {\n        let n = 5;\n        let lanes = 2;\n        let lhs_values = vec![Val::from_u64(3); n];\n        let rhs_values = vec![Val::from_u64(5); n];\n        let result_values = vec![Val::from_u64(15); n];\n        let lhs_index = vec![WitnessId(1); n];\n        let rhs_index = vec![WitnessId(2); n];\n        let result_index = vec![WitnessId(3); n];\n\n        // Get preprocessed index values.\n        let mut preprocessed_values = Vec::with_capacity(n * 3);\n        lhs_index\n            .iter()\n            .zip(rhs_index.iter())\n            .zip(result_index.iter())\n            .for_each(|((lhs_idx, rhs_idx), result_idx)| {\n                preprocessed_values.extend(\u0026[\n                    Val::from_u32(lhs_idx.0),\n                    Val::from_u32(rhs_idx.0),\n                    Val::from_u32(result_idx.0),\n                ]);\n            });\n\n        let trace = MulTrace {\n            lhs_values,\n            lhs_index: lhs_index.clone(),\n            rhs_values,\n            rhs_index: rhs_index.clone(),\n            result_values,\n            result_index: result_index.clone(),\n        };\n\n        let matrix: RowMajorMatrix\u003cVal\u003e = MulAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, lanes);\n        assert_eq!(matrix.width(), 6);\n\n        let config = build_test_config();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let air = MulAir::\u003cVal, 1\u003e::new_with_preprocessed(n, lanes, preprocessed_values);\n\n        // Check the preprocessed trace has been padded correctly.\n        let preprocessed_trace = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_trace.height(), 4);\n\n        let lane_width = MulAir::\u003cVal, 1\u003e::preprocessed_lane_width();\n        let preprocessed_width = air.preprocessed_width();\n        for i in 0..preprocessed_trace.height() {\n            for j in 0..lanes {\n                let lane_idx = i * lanes + j;\n                if lane_idx \u003c n {\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j],\n                        Val::ONE\n                    );\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j + 1],\n                        Val::from_u32(lhs_index[lane_idx].0)\n                    );\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j + 2],\n                        Val::from_u32(rhs_index[lane_idx].0)\n                    );\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j + 3],\n                        Val::from_u32(result_index[lane_idx].0)\n                    );\n                } else {\n                    assert_eq!(\n                        preprocessed_trace.values[i * preprocessed_width + lane_width * j\n                            ..i * preprocessed_width + lane_width * (j + 1)],\n                        [Val::ZERO; 4]\n                    );\n                }\n            }\n        }\n\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n}\n","traces":[{"line":158,"address":[3834560,3834656,3834368,3835072,3834848,3834752],"length":1,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":160,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":4}},{"line":175,"address":[3833256,3833184],"length":1,"stats":{"Line":4}},{"line":176,"address":[3833213],"length":1,"stats":{"Line":4}},{"line":190,"address":[3829392,3830224,3829600,3830016,3829808],"length":1,"stats":{"Line":3}},{"line":191,"address":[3829446,3830070,3830254,3829862,3829654],"length":1,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[6933187,6933810,6932354,6931618,6931826,6932979,6932562,6932035,6933395,6933602,6931410,6932770],"length":1,"stats":{"Line":3}},{"line":206,"address":[3834349,3834176],"length":1,"stats":{"Line":3}},{"line":212,"address":[3834210,3834278],"length":1,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":3}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":8}},{"line":231,"address":[6929805,6929469,6929949,6929997,6929825,6929441,6929517,6929873,6929393,6929489,6929537,6930017,6929633,6929681,6929853,6929613,6929565,6929777,6929709,6929661,6929921,6929585,6929729,6929969,6930093,6929757,6929421,6930065,6930045,6929901],"length":1,"stats":{"Line":8}},{"line":235,"address":[1662336],"length":1,"stats":{"Line":8}},{"line":236,"address":[3829001,3829241,3829081,3828964,3829044,3829321,3829124,3828921,3829204,3829284,3829364,3829161],"length":1,"stats":{"Line":8}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[1662416],"length":1,"stats":{"Line":7}},{"line":250,"address":[1662425,1662468],"length":1,"stats":{"Line":7}},{"line":275,"address":[6942309,6947717,6934144,6939600,6944997,6939557,6936828,6939589,6942320,6942277,6936860,6945029,6947749,6936880,6945040],"length":1,"stats":{"Line":6}},{"line":282,"address":[3830391],"length":1,"stats":{"Line":6}},{"line":285,"address":[3830447],"length":1,"stats":{"Line":6}},{"line":287,"address":[3830611,3830476],"length":1,"stats":{"Line":6}},{"line":289,"address":[6942500,6945220,6937060,6934324,6939780],"length":1,"stats":{"Line":6}},{"line":291,"address":[],"length":0,"stats":{"Line":6}},{"line":297,"address":[6945336,6937176,6939948,6934379,6945388,6942616,6939835,6937228,6937115,6945275,6939896,6942555,6934492,6934440,6942668],"length":1,"stats":{"Line":14}},{"line":300,"address":[],"length":0,"stats":{"Line":14}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[3830754],"length":1,"stats":{"Line":7}},{"line":303,"address":[],"length":0,"stats":{"Line":7}},{"line":304,"address":[6942922,6945642,6940202,6937482,6934746],"length":1,"stats":{"Line":7}},{"line":305,"address":[3831059],"length":1,"stats":{"Line":7}},{"line":308,"address":[],"length":0,"stats":{"Line":13}},{"line":310,"address":[6935373,6940723,6946262,6938102,6935274,6943495,6935326,6938003,6946163,6940775,6938055,6946215,6940822,6943443,6943542],"length":1,"stats":{"Line":12}},{"line":317,"address":[3831540,3831736,3831592],"length":1,"stats":{"Line":12}},{"line":322,"address":[],"length":0,"stats":{"Line":12}},{"line":324,"address":[3831797,3831929],"length":1,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[6941303,6943863,6935854,6935694,6941143,6944023,6946583,6946743,6938583,6938423],"length":1,"stats":{"Line":12}},{"line":331,"address":[],"length":0,"stats":{"Line":6}},{"line":336,"address":[],"length":0,"stats":{"Line":12}},{"line":338,"address":[],"length":0,"stats":{"Line":6}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[3832486,3832338],"length":1,"stats":{"Line":12}},{"line":345,"address":[3832573,3832636],"length":1,"stats":{"Line":6}},{"line":350,"address":[6936434,6936482,6944603,6941931,6939163,6944651,6939211,6941883,6947323,6947371],"length":1,"stats":{"Line":12}},{"line":351,"address":[],"length":0,"stats":{"Line":6}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":12}},{"line":361,"address":[],"length":0,"stats":{"Line":6}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":367,"address":[6951041,6952193,6951072,6952199,6951047,6950496,6951617,6949895,6949920,6950471,6951623,6949344,6951648,6949889,6950465],"length":1,"stats":{"Line":6}},{"line":371,"address":[6951699,6951123,6949395,6950547,6949971],"length":1,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[6950647,6950071,6949495,6951223,6951799],"length":1,"stats":{"Line":6}},{"line":374,"address":[3833853,3833601],"length":1,"stats":{"Line":12}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[6951936,6950208,6950784,6949632,6951360],"length":1,"stats":{"Line":6}},{"line":378,"address":[3833812,3833793,3833885,3833975],"length":1,"stats":{"Line":12}},{"line":379,"address":[3834025,3834016,3833913],"length":1,"stats":{"Line":18}},{"line":380,"address":[3834055,3834123],"length":1,"stats":{"Line":12}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":382,"address":[3834082],"length":1,"stats":{"Line":6}},{"line":383,"address":[6952757,6952309,6952453,6952603,6952901],"length":1,"stats":{"Line":6}},{"line":387,"address":[3833930],"length":1,"stats":{"Line":6}},{"line":394,"address":[],"length":0,"stats":{"Line":1}},{"line":395,"address":[],"length":0,"stats":{"Line":1}},{"line":396,"address":[],"length":0,"stats":{"Line":1}},{"line":397,"address":[6928233,6928281,6928359],"length":1,"stats":{"Line":2}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":402,"address":[6926668],"length":1,"stats":{"Line":1}},{"line":403,"address":[6926748,6926676],"length":1,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[6926756],"length":1,"stats":{"Line":1}},{"line":414,"address":[6926829],"length":1,"stats":{"Line":1}},{"line":415,"address":[],"length":0,"stats":{"Line":2}},{"line":417,"address":[],"length":0,"stats":{"Line":1}},{"line":418,"address":[6927061,6927140],"length":1,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":1}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":2}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[6927605],"length":1,"stats":{"Line":1}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[6927872,6927768,6928131],"length":1,"stats":{"Line":2}},{"line":433,"address":[6928067],"length":1,"stats":{"Line":1}},{"line":434,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":1}},{"line":440,"address":[6927393],"length":1,"stats":{"Line":1}},{"line":445,"address":[],"length":0,"stats":{"Line":9}},{"line":446,"address":[6703093,6703189,6703029,6703013,6703061,6703205,6703173,6703221,6703077,6703109,6702997,6703045,6703125,6703141,6703157],"length":1,"stats":{"Line":9}},{"line":449,"address":[3744552,3743552,3744767],"length":1,"stats":{"Line":6}},{"line":450,"address":[3743582],"length":1,"stats":{"Line":6}},{"line":453,"address":[],"length":0,"stats":{"Line":6}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[3743671,3743756],"length":1,"stats":{"Line":6}},{"line":458,"address":[3743822,3744800,3744830],"length":1,"stats":{"Line":16}},{"line":461,"address":[6697683,6698931,6699643,6700179,6697147,6698395,6696435,6700893,6701451,6695899],"length":1,"stats":{"Line":1}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[6697127,6697299,6700920,6698375,6699795,6696051,6700881,6698547,6699666,6701061,6699623,6695879,6695922,6698418,6697170],"length":1,"stats":{"Line":12}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[3744210,3744167],"length":1,"stats":{"Line":12}},{"line":471,"address":[6696119,6698615,6697367,6701131,6699863],"length":1,"stats":{"Line":1}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[6697340,6698588,6699836,6696092,6701102],"length":1,"stats":{"Line":6}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":12}},{"line":479,"address":[6701196,6698680,6699928,6696184,6697432],"length":1,"stats":{"Line":6}},{"line":480,"address":[3744360],"length":1,"stats":{"Line":6}},{"line":489,"address":[3813744,3813760,3819536,3822368,3819667,3818000,3822352,3819508,3815168,3810928,3822481,3825312,3811059,3825443,3828128,3815299,3817984,3813888,3818585,3823776,3824361,3825284],"length":1,"stats":{"Line":25}},{"line":491,"address":[1660225,1658865],"length":1,"stats":{"Line":25}},{"line":494,"address":[3815500,3819718,3823942,3825494,3811260,3822526,3823880,3825428,3822667,3824088,3825644,3818166,3818312,3811044,3811110,3819868,3822469,3813936,3813873,3815350,3814082,3818104,3819652,3815284],"length":1,"stats":{"Line":49}},{"line":497,"address":[3819861,3822660,3814186,3824192,3811354,3825738,3818295,3819962,3814065,3818416,3822761,3825637,3824071,3815493,3811253,3815594],"length":1,"stats":{"Line":52}},{"line":498,"address":[1659273,1659317,1660714,1660670],"length":1,"stats":{"Line":52}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":16}},{"line":506,"address":[],"length":0,"stats":{"Line":33}},{"line":507,"address":[6837694,6793278,6817644,6786082,6824753,6824782,6781671,6781693,6817602,6780263,6837665,6793249,6841912,6841934,6780285,6786124],"length":1,"stats":{"Line":34}},{"line":509,"address":[1659775,1661182,1659886,1661292],"length":1,"stats":{"Line":34}},{"line":511,"address":[],"length":0,"stats":{"Line":33}},{"line":515,"address":[],"length":0,"stats":{"Line":33}},{"line":523,"address":[3820070,3815702,3825846,3811462],"length":1,"stats":{"Line":11}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":30}},{"line":529,"address":[3815794,3820162,3811554,3811620,3820228,3825938,3815860,3826004],"length":1,"stats":{"Line":20}},{"line":544,"address":[3816099,3811825,3820467,3820433,3816065,3826243,3826209,3811859],"length":1,"stats":{"Line":20}},{"line":549,"address":[3826323,3811939,3816179,3820547],"length":1,"stats":{"Line":10}},{"line":554,"address":[],"length":0,"stats":{"Line":10}},{"line":559,"address":[3812117,3826501,3826588,3816357,3820812,3816444,3820725,3812204],"length":1,"stats":{"Line":20}},{"line":561,"address":[3827340,3816721,3817196,3817923,3812956,3812481,3821564,3826865,3828067,3813683,3822291,3821089],"length":1,"stats":{"Line":30}},{"line":565,"address":[],"length":0,"stats":{"Line":10}},{"line":566,"address":[],"length":0,"stats":{"Line":10}},{"line":570,"address":[],"length":0,"stats":{"Line":10}},{"line":579,"address":[],"length":0,"stats":{"Line":20}},{"line":599,"address":[],"length":0,"stats":{"Line":20}},{"line":615,"address":[],"length":0,"stats":{"Line":10}},{"line":617,"address":[],"length":0,"stats":{"Line":20}}],"covered":125,"coverable":155},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","public_air.rs"],"content":"//! [`PublicAir`] stores public inputs either in the base field or the extension field (of extension degree `D`).\n//!\n//! # Columns:\n//!\n//! The AIR has a total of `D + 1` columns:\n//!\n//! - `D` main columns for the constant value,\n//! - 1 preprocessed column for the index of the constant within the witness table.\n//!\n//! # Constraints\n//!\n//! The AIR has no constraints.\n//!\n//! # Global Interactions\n//!\n//! There is one interaction with the witness bus:\n//! - send (index, value)\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_air::{\n    Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PairBuilder, PermutationAirBuilder,\n};\nuse p3_circuit::tables::PublicTrace;\nuse p3_circuit::utils::pad_to_power_of_two;\nuse p3_field::{BasedVectorSpace, Field};\nuse p3_lookup::lookup_traits::{AirLookupHandler, Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_uni_stark::SymbolicAirBuilder;\n\nuse crate::air::utils::get_index_lookups;\n\n/// PublicAir: vector-valued public input binding with generic extension degree D.\n/// Layout per row: [value[0..D-1], index] → width = D + 1\n#[derive(Debug, Clone)]\npub struct PublicAir\u003cF, const D: usize = 1\u003e {\n    /// Height of the trace, i.e., number of public inputs.\n    pub height: usize,\n    /// Preprocessed witness indices for the public inputs.\n    pub preprocessed: Vec\u003cF\u003e,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, const D: usize\u003e PublicAir\u003cF, D\u003e {\n    pub const fn new(height: usize) -\u003e Self {\n        Self {\n            height,\n            preprocessed: Vec::new(),\n            _phantom: PhantomData,\n        }\n    }\n\n    pub const fn new_with_preprocessed(height: usize, preprocessed: Vec\u003cF\u003e) -\u003e Self {\n        Self {\n            height,\n            preprocessed,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Number of preprocessed columns: multiplicity + index\n    pub const fn preprocessed_width() -\u003e usize {\n        2 // One column for multiplicity, one for index\n    }\n\n    /// Flatten a PublicTrace over an extension into a base-field matrix with D limbs + index.\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026PublicTrace\u003cExtF\u003e,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        let height = trace.values.len();\n        assert_eq!(\n            height,\n            trace.index.len(),\n            \"PublicTrace column length mismatch\"\n        );\n        let width = D;\n\n        let mut values = Vec::with_capacity(height * width);\n        for i in 0..height {\n            let coeffs = trace.values[i].as_basis_coefficients_slice();\n            assert_eq!(\n                coeffs.len(),\n                D,\n                \"extension degree mismatch for PublicTrace value\"\n            );\n            values.extend_from_slice(coeffs);\n        }\n\n        // Pad to power of two by repeating last row\n        pad_to_power_of_two(\u0026mut values, width, height);\n\n        RowMajorMatrix::new(values, width)\n    }\n\n    pub fn trace_to_preprocessed\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(trace: \u0026PublicTrace\u003cExtF\u003e) -\u003e Vec\u003cF\u003e {\n        trace\n            .index\n            .iter()\n            .map(|widx| F::from_u64(widx.0 as u64))\n            .collect()\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for PublicAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        D\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        let mut preprocessed_values = self\n            .preprocessed\n            .iter()\n            .flat_map(|v| [F::ONE, *v])\n            .collect::\u003cVec\u003cF\u003e\u003e();\n        pad_to_power_of_two(\u0026mut preprocessed_values, 2, self.height);\n\n        Some(RowMajorMatrix::new(\n            preprocessed_values,\n            2, // Two columns: one for the multiplicity (0 for padding, 1 otherwise), one for the index\n        ))\n    }\n}\n\nimpl\u003cAB: AirBuilder, const D: usize\u003e Air\u003cAB\u003e for PublicAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn eval(\u0026self, _builder: \u0026mut AB) {\n        // No constraints for public inputs in Stage 1\n    }\n}\n\nimpl\u003cAB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues, const D: usize\u003e\n    AirLookupHandler\u003cAB\u003e for PublicAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        // There is only one lookup to register in this AIR.\n        vec![0]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e {\n        // Create symbolic air builder to access symbolic variables\n        let symbolic_air_builder = SymbolicAirBuilder::\u003cAB::F\u003e::new(\n            Self::preprocessed_width(),\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            1,\n            0,\n        );\n\n        let symbolic_main = symbolic_air_builder.main();\n        let symbolic_main_local = symbolic_main.row_slice(0).unwrap();\n\n        let preprocessed = symbolic_air_builder.preprocessed();\n        let preprocessed_local = preprocessed.row_slice(0).unwrap();\n\n        let lookup_inps = get_index_lookups::\u003cAB, D\u003e(\n            0,\n            0,\n            1,\n            \u0026symbolic_main_local,\n            \u0026preprocessed_local,\n            Direction::Send,\n        );\n\n        assert!(lookup_inps.len() == 1);\n        let lookup = AirLookupHandler::\u003cAB\u003e::register_lookup(\n            self,\n            Kind::Global(\"WitnessChecks\".to_string()),\n            \u0026lookup_inps[0],\n        );\n\n        vec![lookup]\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n\n    use p3_baby_bear::BabyBear;\n    use p3_circuit::WitnessId;\n    use p3_field::PrimeCharacteristicRing;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_matrix::Matrix;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    type F = BabyBear;\n    type EF = BinomialExtensionField\u003cF, 4\u003e;\n\n    #[test]\n    fn test_public_air_base_field() {\n        let n = 8usize;\n        let values: Vec\u003cF\u003e = (1..=n as u64).map(F::from_u64).collect();\n        let indices: Vec\u003cWitnessId\u003e = (0..n as u32).map(WitnessId).collect();\n\n        // Get preprocessed index values.\n        let preprocessed_values = indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let trace = PublicTrace {\n            values,\n            index: indices,\n        };\n\n        let matrix = PublicAir::\u003cF, 1\u003e::trace_to_matrix(\u0026trace);\n\n        // Verify matrix dimensions\n        assert_eq!(matrix.width(), 1); // D = 1\n\n        // Check first row (scope the borrow)\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            assert_eq!(row0[0], F::from_u64(1)); // value\n        }\n\n        // Check last original row (scope the borrow)\n        {\n            let last_original_row = n - 1;\n            let row_last = matrix.row_slice(last_original_row).unwrap();\n            assert_eq!(row_last[0], F::from_u64(n as u64)); // value\n        }\n\n        let config = build_test_config();\n        let air = PublicAir::\u003cF, 1\u003e::new_with_preprocessed(n, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        // Check the correctness of preprocessed values.\n        let preprocessed = air.preprocessed_trace().unwrap();\n        let row0 = preprocessed.row_slice(0).unwrap();\n        let last_row = preprocessed.row_slice(n - 1).unwrap();\n        // The multiplicity is 1 for active rows.\n        assert_eq!(row0[0], F::from_u64(1)); // first index\n        assert_eq!(last_row[0], F::from_u64(1)); // last index\n        // Check the witness indices.\n        assert_eq!(row0[1], F::from_u64(0)); // first index\n        assert_eq!(last_row[1], F::from_u64((n - 1) as u64)); // last index\n\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"PublicAir base field verification failed\");\n    }\n\n    #[test]\n    fn test_public_air_padding() {\n        let n = 5usize;\n        let values: Vec\u003cF\u003e = (1..=n as u64).map(F::from_u64).collect();\n        let indices: Vec\u003cWitnessId\u003e = (0..n as u32).map(WitnessId).collect();\n\n        // Get preprocessed index values.\n        let preprocessed_values = indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let trace = PublicTrace {\n            values,\n            index: indices,\n        };\n\n        let matrix = PublicAir::\u003cF, 1\u003e::trace_to_matrix(\u0026trace);\n\n        // Verify matrix dimensions\n        assert_eq!(matrix.width(), 1); // D = 1\n        assert_eq!(matrix.height(), 8); // Padded to next power of two\n\n        // Check first row (scope the borrow)\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            assert_eq!(row0[0], F::from_u64(1)); // value\n        }\n\n        // Check last original row (scope the borrow)\n        {\n            let last_original_row = n - 1;\n            let row_last = matrix.row_slice(last_original_row).unwrap();\n            assert_eq!(row_last[0], F::from_u64(n as u64)); // value\n        }\n        // Check padded rows (scope the borrow)\n        {\n            for i in n..matrix.height() {\n                let row = matrix.row_slice(i).unwrap();\n                assert_eq!(row[0], F::ZERO); // value\n            }\n        }\n\n        let config = build_test_config();\n        let air = PublicAir::\u003cF, 1\u003e::new_with_preprocessed(n, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        // Check the correctness of preprocessed values.\n        let preprocessed = air.preprocessed_trace().unwrap();\n        assert!(preprocessed.height() == 8);\n        for i in 0..n {\n            let row = preprocessed.row_slice(i).unwrap();\n            // The multiplicity is 1 for active rows.\n            assert_eq!(row[0], F::from_u64(1)); // first index\n            // Check the witness indices.\n            assert_eq!(row[1], F::from_u64(i as u64)); // first index\n        }\n        for i in n..preprocessed.height() {\n            let row = preprocessed.row_slice(i).unwrap();\n            // The multiplicity is 0 for padded rows.\n            assert_eq!(row[0], F::ZERO); // first index\n            // Check the witness indices.\n            assert_eq!(row[1], F::ZERO); // last original index\n        }\n\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"PublicAir base field verification failed\");\n    }\n\n    #[test]\n    fn test_public_air_extension_field() {\n        let a = EF::from_basis_coefficients_slice(\u0026[\n            F::from_u64(1),\n            F::from_u64(2),\n            F::from_u64(3),\n            F::from_u64(4),\n        ])\n        .unwrap();\n\n        let b = EF::from_basis_coefficients_slice(\u0026[\n            F::from_u64(5),\n            F::from_u64(6),\n            F::from_u64(7),\n            F::from_u64(8),\n        ])\n        .unwrap();\n\n        let values = vec![a, b];\n        let indices = vec![WitnessId(10), WitnessId(20)];\n        let preprocessed_values = indices\n            .iter()\n            .map(|idx| F::from_u64(idx.0 as u64))\n            .collect();\n\n        let trace = PublicTrace {\n            values,\n            index: indices,\n        };\n        let matrix = PublicAir::\u003cF, 4\u003e::trace_to_matrix(\u0026trace);\n\n        // Verify matrix dimensions\n        assert_eq!(matrix.width(), 4); // D = 4\n\n        // Check first row - extension field coefficients (scope the borrow)\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            let a_coeffs = a.as_basis_coefficients_slice();\n            assert_eq!(\u0026row0[0..4], a_coeffs);\n        }\n\n        // Check second row (scope the borrow)\n        {\n            let row1 = matrix.row_slice(1).unwrap();\n            let b_coeffs = b.as_basis_coefficients_slice();\n            assert_eq!(\u0026row1[0..4], b_coeffs);\n        }\n\n        let config = build_test_config();\n        let air = PublicAir::\u003cF, 4\u003e::new_with_preprocessed(2, preprocessed_values);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        let prep = air.preprocessed_trace().unwrap();\n        // Check the correctness of preprocessed values.\n        let row0 = prep.row_slice(0).unwrap();\n        let last_row = prep.row_slice(1).unwrap();\n        // The multiplicity is 1 for active rows.\n        assert_eq!(row0[0], F::from_u64(1)); // first index\n        assert_eq!(last_row[0], F::from_u64(1)); // last index\n        // Check the witness indices.\n        assert_eq!(row0[1], F::from_u64(10)); // first index\n        assert_eq!(last_row[1], F::from_u64(20)); // last index\n\n        let pis: Vec\u003cF\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"PublicAir extension field verification failed\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_public_air_mismatched_lengths() {\n        let values = vec![F::from_u64(1), F::from_u64(2)];\n        let indices = vec![WitnessId(0)]; // Wrong length\n\n        let trace = PublicTrace {\n            values,\n            index: indices,\n        };\n        PublicAir::\u003cF, 1\u003e::trace_to_matrix(\u0026trace);\n    }\n}\n","traces":[{"line":49,"address":[2770560,2770656,2770752,2770848,2770944,2770464],"length":1,"stats":{"Line":7}},{"line":52,"address":[2770775,2770871,2770583,2770679,2770487,2770967],"length":1,"stats":{"Line":7}},{"line":57,"address":[],"length":0,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[2769392,2770243,2770275],"length":1,"stats":{"Line":6}},{"line":74,"address":[2769430],"length":1,"stats":{"Line":6}},{"line":75,"address":[2769467],"length":1,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[5046291,5047187,5048083,5044499,5045395],"length":1,"stats":{"Line":6}},{"line":82,"address":[2769678,2769599],"length":1,"stats":{"Line":6}},{"line":83,"address":[2769742,2769648],"length":1,"stats":{"Line":12}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":85,"address":[5047638,5046849,5044950,5045957,5045057,5046742,5045850,5047745,5048534,5048641],"length":1,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[5045150,5045950,5046942,5047838,5046050,5047738,5048634,5048734,5046842,5045050],"length":1,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":96,"address":[2769901],"length":1,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":7}},{"line":100,"address":[],"length":0,"stats":{"Line":7}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[2770432,2770446,2770390],"length":1,"stats":{"Line":20}},{"line":109,"address":[4891680,4891728,4891696,4891568,4891744,4891664,4891552,4891616,4891536,4891520,4891648,4891584,4891712,4891632,4891600],"length":1,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[2750160,2750468,2750497],"length":1,"stats":{"Line":6}},{"line":114,"address":[4889621,4891045,4890341,4889989,4890693],"length":1,"stats":{"Line":6}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[2750234,2750522,2750512],"length":1,"stats":{"Line":18}},{"line":119,"address":[2750277],"length":1,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[2761648,2761632,2761568,2761584,2761600,2761664,2761552,2761616],"length":1,"stats":{"Line":23}},{"line":142,"address":[5032880],"length":1,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":147,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[5031766,5031690],"length":1,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":179,"address":[],"length":0,"stats":{"Line":2}}],"covered":40,"coverable":52},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","test_utils.rs"],"content":"#![allow(clippy::type_complexity)]\n\nuse p3_baby_bear::{BabyBear as Val, Poseidon2BabyBear as Perm};\nuse p3_challenger::DuplexChallenger as Challenger;\nuse p3_commit::ExtensionMmcs;\nuse p3_dft::Radix2DitParallel as Dft;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_fri::{TwoAdicFriPcs as Pcs, create_test_fri_params};\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_symmetric::{PaddingFreeSponge as MyHash, TruncatedPermutation as MyCompress};\nuse p3_uni_stark::StarkConfig;\n\npub type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\npub type ValMmcs = MerkleTreeMmcs\u003c\n    \u003cVal as p3_field::Field\u003e::Packing,\n    \u003cVal as p3_field::Field\u003e::Packing,\n    MyHash\u003cPerm\u003c16\u003e, 16, 8, 8\u003e,\n    MyCompress\u003cPerm\u003c16\u003e, 2, 8, 16\u003e,\n    8,\n\u003e;\npub type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\n\n/// Build a test STARK config following the standard pattern from Plonky3 examples\npub fn build_test_config() -\u003e StarkConfig\u003c\n    Pcs\u003cVal, Dft\u003cVal\u003e, ValMmcs, ChallengeMmcs\u003e,\n    Challenge,\n    Challenger\u003cVal, Perm\u003c16\u003e, 16, 8\u003e,\n\u003e {\n    use rand::SeedableRng;\n    use rand::rngs::SmallRng;\n\n    let mut rng = SmallRng::seed_from_u64(1);\n    let perm = Perm::\u003c16\u003e::new_from_rng_128(\u0026mut rng);\n    let hash = MyHash::\u003cPerm\u003c16\u003e, 16, 8, 8\u003e::new(perm.clone());\n    let compress = MyCompress::\u003cPerm\u003c16\u003e, 2, 8, 16\u003e::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::\u003cVal\u003e::default();\n    let fri_params = create_test_fri_params::\u003cChallengeMmcs\u003e(challenge_mmcs, 0);\n    let pcs = Pcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::\u003cVal, Perm\u003c16\u003e, 16, 8\u003e::new(perm);\n\n    StarkConfig::new(pcs, challenger)\n}\n","traces":[{"line":24,"address":[9188948,9189026,9187856],"length":1,"stats":{"Line":1}},{"line":32,"address":[9187873],"length":1,"stats":{"Line":1}},{"line":33,"address":[9187946],"length":1,"stats":{"Line":2}},{"line":34,"address":[9188046,9187982],"length":1,"stats":{"Line":3}},{"line":35,"address":[9188135,9188074],"length":1,"stats":{"Line":3}},{"line":36,"address":[9188142],"length":1,"stats":{"Line":1}},{"line":37,"address":[9188349,9188285],"length":1,"stats":{"Line":3}},{"line":38,"address":[9188372],"length":1,"stats":{"Line":2}},{"line":39,"address":[9188417],"length":1,"stats":{"Line":1}},{"line":40,"address":[9188533],"length":1,"stats":{"Line":2}},{"line":41,"address":[9188660],"length":1,"stats":{"Line":1}},{"line":43,"address":[9188803],"length":1,"stats":{"Line":2}}],"covered":12,"coverable":12},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","utils.rs"],"content":"use alloc::vec::Vec;\nuse core::iter;\n\nuse itertools::Itertools;\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, PairBuilder, PermutationAirBuilder};\nuse p3_lookup::lookup_traits::{\n    AirLookupHandler, Direction, Lookup, LookupData, LookupGadget, LookupInput,\n};\nuse p3_uni_stark::{SymbolicExpression, SymbolicVariable};\n\npub fn get_index_lookups\u003c\n    AB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues,\n    const D: usize,\n\u003e(\n    main_start: usize,\n    preprocessed_start: usize,\n    num_lookups: usize,\n    main: \u0026[SymbolicVariable\u003c\u003cAB as AirBuilder\u003e::F\u003e],\n    preprocessed: \u0026[SymbolicVariable\u003c\u003cAB as AirBuilder\u003e::F\u003e],\n    direction: Direction,\n) -\u003e Vec\u003cVec\u003cLookupInput\u003cAB::F\u003e\u003e\u003e {\n    // Chunk by 2 so we can maintain a constraint degree 3 at most.\n    (0..num_lookups)\n        .chunks(2)\n        .into_iter()\n        .map(|chunk| {\n            chunk\n                .map(|i| {\n                    let idx = SymbolicExpression::from(preprocessed[1 + preprocessed_start + i]);\n\n                    let multiplicity = SymbolicExpression::from(preprocessed[preprocessed_start]);\n\n                    let values =\n                        (0..D).map(|j| SymbolicExpression::from(main[main_start + i * D + j]));\n                    let inps = iter::once(idx).chain(values).collect::\u003cVec\u003c_\u003e\u003e();\n\n                    (inps, multiplicity, direction)\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e()\n        })\n        .collect()\n}\n\n/// Object‑safe gadget shim.\npub trait LookupGadgetDyn\u003cAB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues\u003e {\n    fn num_aux_cols(\u0026self) -\u003e usize;\n    fn num_challenges(\u0026self) -\u003e usize;\n    fn eval_lookups_dyn(\n        \u0026self,\n        builder: \u0026mut AB,\n        contexts: \u0026[Lookup\u003cAB::F\u003e],\n        lookup_data: \u0026[LookupData\u003cAB::EF\u003e],\n    );\n}\n\n/// Blanket: any concrete `LookupGadget` becomes object‑safe.\nimpl\u003cAB, LG\u003e LookupGadgetDyn\u003cAB\u003e for LG\nwhere\n    AB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues,\n    LG: LookupGadget,\n{\n    fn num_aux_cols(\u0026self) -\u003e usize {\n        LG::num_aux_cols(self)\n    }\n    fn num_challenges(\u0026self) -\u003e usize {\n        LG::num_challenges(self)\n    }\n    fn eval_lookups_dyn(\n        \u0026self,\n        builder: \u0026mut AB,\n        contexts: \u0026[Lookup\u003cAB::F\u003e],\n        lookup_data: \u0026[LookupData\u003cAB::EF\u003e],\n    ) {\n        // forward to the generic method on the concrete handler\n        LG::eval_lookups(self, builder, contexts, lookup_data);\n    }\n}\n\n/// Object‑safe AIR lookup handler shim.\npub trait AirLookupHandlerDyn\u003cAB\u003e\nwhere\n    AB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues,\n{\n    fn add_lookup_columns_dyn(\u0026mut self) -\u003e Vec\u003cusize\u003e;\n    fn get_lookups_dyn(\u0026mut self) -\u003e Vec\u003cLookup\u003cAB::F\u003e\u003e;\n    fn eval_lookups_dyn(\n        \u0026self,\n        builder: \u0026mut AB,\n        contexts: \u0026[Lookup\u003cAB::F\u003e],\n        lookup_data: \u0026[LookupData\u003cAB::EF\u003e],\n        gadget: \u0026dyn LookupGadgetDyn\u003cAB\u003e,\n    );\n}\n\n/// Blanket: any existing `AirLookupHandler` now satisfies the object‑safe shim.\nimpl\u003cAB, T\u003e AirLookupHandlerDyn\u003cAB\u003e for T\nwhere\n    AB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues,\n    T: AirLookupHandler\u003cAB\u003e,\n{\n    fn add_lookup_columns_dyn(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        self.add_lookup_columns()\n    }\n    fn get_lookups_dyn(\u0026mut self) -\u003e Vec\u003cLookup\u003cAB::F\u003e\u003e {\n        self.get_lookups()\n    }\n    fn eval_lookups_dyn(\n        \u0026self,\n        builder: \u0026mut AB,\n        contexts: \u0026[Lookup\u003cAB::F\u003e],\n        lookup_data: \u0026[LookupData\u003cAB::EF\u003e],\n        gadget: \u0026dyn LookupGadgetDyn\u003cAB\u003e,\n    ) {\n        Air::\u003cAB\u003e::eval(self, builder);\n        if !lookup_data.is_empty() {\n            gadget.eval_lookups_dyn(builder, contexts, lookup_data);\n        }\n    }\n}\n","traces":[{"line":11,"address":[5899016,5898624,5899022],"length":1,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[4582992,4582960,4583024],"length":1,"stats":{"Line":0}},{"line":102,"address":[4582977,4583009,4583041],"length":1,"stats":{"Line":0}},{"line":104,"address":[6679296,6679392,6679264,6679168,6679232,6679328,6679136,6679360,6679200],"length":1,"stats":{"Line":0}},{"line":105,"address":[4582353,4582385,4582417],"length":1,"stats":{"Line":0}},{"line":107,"address":[4582608,4582432,4582784],"length":1,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}}],"covered":9,"coverable":25},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","air","witness_air.rs"],"content":"//! [`WitnessAir`] defines the AIR for the global witness bus used by all other circuit tables.\n//!\n//! Each logical witness element is stored once in this table together with its witness index.\n//! The generic parameter `D` allows the AIR to handle values from an extension field of degree\n//! `D` over the base field, while the runtime parameter `lanes` controls how many witness\n//! elements are packed side-by-side in every row of the trace.\n//!\n//! # Column layout\n//!\n//! For each witness element (lane) we allocate `D` base-field columns, corresponding to:\n//!\n//! - `D` columns to store the value, where `D` is the degree extension of the used field compared to the current field\n//!\n//! We also allocate two preprocessing columns:\n//!\n//! - 1 column for the indices of the witness elements\n//! - 1 column for the multiplicity at which each witness element appears in the circuit\n//!\n//! A single row can pack several of these lanes side-by-side, so the full row layout is\n//! this pattern repeated `lanes` times:\n//!\n//! ```text\n//!     [value[0..D), index] repeated `lanes` times.\n//! ```\n//!\n//! The logical ordering of witnesses matches the physical ordering of lanes: lane `ℓ + 1`\n//! always stores the witness with index `index_lane_ℓ + 1`, and the first lane of the next row\n//! continues the same sequence. When the final row is not completely filled, unused lanes are\n//! padded by repeating the last witness value and extending the index sequence.\n//!\n//! # Constraints\n//!\n//!  - In the first row, lane 0: `index = 0`.\n//!  - Within a row: for every adjacent pair of lanes, `index_next - index_current - 1 = 0`.\n//!  - Across rows: the index in the first lane of row `r + 1` must equal that of the last lane of row `r` plus 1.\n//!\n//! # Global Interactions\n//!\n//! This table acts as the canonical bus that other chips read from. The registers of all the other circuit\n//! tables receive interactions of the form `(index, value)`, guaranteeing that they fetch\n//! a value consistent with the witness bus maintained by this AIR.\n\nuse alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_air::{\n    Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PairBuilder, PermutationAirBuilder,\n};\nuse p3_circuit::tables::WitnessTrace;\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_lookup::lookup_traits::{AirLookupHandler, Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_uni_stark::SymbolicAirBuilder;\n\nuse crate::air::utils::get_index_lookups;\n\n/// AIR enforcing a monotonically increasing witness index column for the global bus.\n/// Layout per row: `[value[0..D), index]` repeated `lanes` times.\n///\n/// Constraints:\n///  - first index (lane 0, row 0) equals 0.\n///  - indices increase by 1 between consecutive lanes.\n///  - index of last lane of row *r* plus 1 equals index of first lane of row *r + 1*.\n#[derive(Debug, Clone)]\npub struct WitnessAir\u003cF, const D: usize = 1\u003e {\n    /// Total number of logical witness entries (before packing into lanes).\n    pub num_witnesses: usize,\n    /// Number of witness entries packed side-by-side in every row.\n    pub lanes: usize,\n    /// Multiplicities: number of times each witness index is used in the circuit.\n    pub multiplicities: Vec\u003cF\u003e,\n    /// Number of currently registered lookup columns.\n    pub num_lookup_columns: usize,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, const D: usize\u003e WitnessAir\u003cF, D\u003e {\n    /// Construct a new `WitnessAir`.\n    ///\n    /// - `num_witnesses`: total number of logical witness entries.\n    /// - `lanes`: how many witness entries are packed side-by-side in each trace row.\n    /// - `multiplicities`: vector of multiplicities for each witness index. It is only used by the prover.\n    pub const fn new(num_witnesses: usize, lanes: usize) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        Self {\n            num_witnesses,\n            lanes,\n            multiplicities: Vec::new(),\n            num_lookup_columns: 0,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Construct a new `WitnessAir` with given multiplicities.\n    ///\n    /// - `num_witnesses`: total number of logical witness entries.\n    /// - `lanes`: how many witness entries are packed side-by-side in each trace row.\n    /// - `multiplicities`: vector of multiplicities for each witness index. It is only used by the prover.\n    pub const fn new_with_preprocessed(\n        num_witnesses: usize,\n        lanes: usize,\n        multiplicities: Vec\u003cF\u003e,\n    ) -\u003e Self {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        Self {\n            num_witnesses,\n            lanes,\n            multiplicities,\n            num_lookup_columns: 0,\n            _phantom: PhantomData,\n        }\n    }\n\n    #[inline]\n    pub const fn lane_width() -\u003e usize {\n        D\n    }\n\n    #[inline]\n    pub const fn total_width(\u0026self) -\u003e usize {\n        self.lanes * Self::lane_width()\n    }\n\n    #[inline]\n    pub const fn preprocessed_lane_width() -\u003e usize {\n        2\n    }\n\n    #[inline]\n    pub const fn preprocessed_width(\u0026self) -\u003e usize {\n        self.lanes * Self::preprocessed_lane_width()\n    }\n\n    /// Convert a [`WitnessTrace`] into a [`RowMajorMatrix`] suitable for the STARK prover.\n    ///\n    /// This function is responsible for:\n    ///\n    /// 1. Decomposing each witness value into its `D` base-field coordinates,\n    /// 2. Packing `lanes` witnesses side-by-side per row, maintaining the natural witness order,\n    /// 3. Padding the trace to have a power-of-two number of rows for FFT-friendly\n    ///    execution by the STARK prover.\n    ///\n    /// The resulting matrix has:\n    ///\n    /// - width `= lanes * LANE_WIDTH`,\n    /// - height equal to the number of rows after packing and padding.\n    ///\n    /// The layout within a row is:\n    ///\n    /// ```text\n    ///     [value[0..D), index] repeated `lanes` times.\n    pub fn trace_to_matrix\u003cExtF: BasedVectorSpace\u003cF\u003e\u003e(\n        trace: \u0026WitnessTrace\u003cExtF\u003e,\n        lanes: usize,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        assert!(lanes \u003e 0, \"lane count must be non-zero\");\n\n        let witness_count = trace.values.len();\n        assert_eq!(\n            witness_count,\n            trace.index.len(),\n            \"WitnessTrace column length mismatch\"\n        );\n        assert!(\n            witness_count \u003e 0,\n            \"WitnessTrace must contain at least one witness entry\"\n        );\n\n        let lane_width = Self::lane_width();\n        let width = lane_width * lanes;\n        let logical_rows = witness_count.div_ceil(lanes).max(1);\n        let padded_rows = logical_rows.next_power_of_two();\n        let total_slots = padded_rows * lanes;\n\n        let mut values = F::zero_vec(width * padded_rows);\n\n        // Prepare last value coefficients for padding lanes/rows.\n        let last_coeffs = trace\n            .values\n            .last()\n            .expect(\"non-empty trace\")\n            .as_basis_coefficients_slice();\n        assert_eq!(\n            last_coeffs.len(),\n            D,\n            \"Extension field degree mismatch for witness value\"\n        );\n        let last_coeffs = last_coeffs.to_vec();\n\n        let mut next_virtual_index = trace\n            .index\n            .last()\n            .expect(\"non-empty trace\")\n            .0\n            .checked_add(1)\n            .expect(\"witness index overflow\");\n\n        for slot in 0..total_slots {\n            let row = slot / lanes;\n            let lane = slot % lanes;\n            let cursor = row * width + lane * lane_width;\n\n            if slot \u003c witness_count {\n                let coeffs = trace.values[slot].as_basis_coefficients_slice();\n                assert_eq!(\n                    coeffs.len(),\n                    D,\n                    \"Extension field degree mismatch for witness value\"\n                );\n                values[cursor..cursor + D].copy_from_slice(coeffs);\n            } else {\n                // padding: copy last value coefficients and increment virtual index\n                values[cursor..cursor + D].copy_from_slice(\u0026last_coeffs);\n                next_virtual_index = next_virtual_index\n                    .checked_add(1)\n                    .expect(\"witness index overflow\");\n            }\n        }\n\n        RowMajorMatrix::new(values, width)\n    }\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for WitnessAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        self.total_width()\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        debug_assert!(\n            self.num_witnesses == self.multiplicities.len(),\n            \"Mismatch between the number of witnesses ({}) and the length of the provided multiplicities ({})\",\n            self.num_witnesses,\n            self.multiplicities.len()\n        );\n        let height = (self.num_witnesses.div_ceil(self.lanes)).next_power_of_two() * self.lanes;\n        let all_vals = (0..height)\n            .flat_map(|i| {\n                if i \u003e= self.multiplicities.len() {\n                    return vec![F::ZERO, F::from_u32(i as u32)];\n                }\n                vec![self.multiplicities[i], F::from_u32(i as u32)]\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        Some(RowMajorMatrix::new(\n            all_vals,\n            self.lanes * Self::preprocessed_lane_width(),\n        ))\n    }\n}\n\nimpl\u003cAB: PairBuilder, const D: usize\u003e Air\u003cAB\u003e for WitnessAir\u003cAB::F, D\u003e\nwhere\n    AB::F: Field,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let lanes = self.lanes;\n\n        // First row: index == 0\n        {\n            let preprocessed = builder.preprocessed();\n            let local_prep = preprocessed\n                .row_slice(0)\n                .expect(\"Preprocessed matrix should be non-empty\");\n            // The index is in the first preprocessed column.\n            let index0 = local_prep[1].clone();\n            builder.when_first_row().assert_zero(index0);\n        }\n\n        // Enforce sequential indices within each row (lanes) and across rows.\n        {\n            let mut b = builder.when_transition();\n            let preprocessed = b.preprocessed();\n            let cur_prep = preprocessed.row_slice(0).expect(\"non-empty\");\n\n            let nxt_prep = preprocessed.row_slice(1).expect(\"has next row\");\n            let mut prev_idx = cur_prep[1].clone();\n            for lane in 1..lanes {\n                // The index is in the second column of each lane's preprocessed data.\n                let idx = cur_prep[lane * Self::preprocessed_lane_width() + 1].clone();\n                // between consecutive lanes in the same row: index_next - index_current - 1\n                b.assert_zero(idx.clone() - prev_idx.clone() - AB::Expr::ONE);\n                prev_idx = idx;\n            }\n            let next_first_idx = nxt_prep[1].clone();\n            // between the last lane of a row and the first lane of the next row: index_next - index_current - 1\n            b.assert_zero(next_first_idx - prev_idx - AB::Expr::ONE);\n        }\n\n        if self.lanes \u003e 1 {\n            let mut b = builder.when_last_row();\n            let preprocessed = b.preprocessed();\n            let last_prep = preprocessed.row_slice(0).expect(\"non-empty\");\n            let mut prev_idx = last_prep[1].clone();\n            for lane in 1..lanes {\n                let idx = last_prep[lane * Self::preprocessed_lane_width() + 1].clone();\n                // between consecutive lanes in the same row: index_next - index_current - 1\n                b.assert_zero(idx.clone() - prev_idx.clone() - AB::Expr::ONE);\n                prev_idx = idx;\n            }\n        }\n    }\n}\n\nimpl\u003cAB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues, const D: usize\u003e\n    AirLookupHandler\u003cAB\u003e for WitnessAir\u003cAB::F, D\u003e\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        let new_idx = self.num_lookup_columns;\n        self.num_lookup_columns += 1;\n        vec![new_idx]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e {\n        let mut lookups = Vec::new();\n        self.num_lookup_columns = 0;\n        let preprocessed_width = self.preprocessed_width();\n\n        // Create symbolic air builder to access symbolic variables\n        let symbolic_air_builder = SymbolicAirBuilder::\u003cAB::F\u003e::new(\n            preprocessed_width,\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            0, // Here, we do not need the permutation trace\n            0,\n        );\n\n        let symbolic_main = symbolic_air_builder.main();\n        let symbolic_main_local = symbolic_main.row_slice(0).unwrap();\n\n        let preprocessed = symbolic_air_builder.preprocessed();\n        let preprocessed_local = preprocessed.row_slice(0).unwrap();\n\n        for lane in 0..self.lanes {\n            let lane_offset = lane * Self::lane_width();\n            let preprocessed_lane_offset = lane * Self::preprocessed_lane_width();\n\n            // There is only 1 lookup per lane: the witness index and its value.\n            let lane_lookup_inputs = get_index_lookups::\u003cAB, D\u003e(\n                lane_offset,\n                preprocessed_lane_offset,\n                1,\n                \u0026symbolic_main_local,\n                \u0026preprocessed_local,\n                Direction::Receive,\n            );\n\n            lookups.push(AirLookupHandler::\u003cAB\u003e::register_lookup(\n                self,\n                Kind::Global(\"WitnessChecks\".to_string()),\n                \u0026lane_lookup_inputs[0],\n            ));\n        }\n\n        lookups\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use alloc::vec;\n    use alloc::vec::Vec;\n\n    use p3_baby_bear::BabyBear as Val;\n    use p3_circuit::WitnessId;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\n    use p3_util::log2_ceil_usize;\n\n    use super::*;\n    use crate::air::test_utils::build_test_config;\n\n    #[test]\n    fn prove_verify_witness_index_monotone() {\n        let n = 8usize;\n        // Use D=1; values can be arbitrary (unused by constraints)\n        let values: Vec\u003cVal\u003e = vec![Val::from_u64(123); n];\n        let indices: Vec\u003cWitnessId\u003e = (0..n as u32).map(WitnessId).collect();\n        let multiplicities: Vec\u003cVal\u003e = vec![Val::ONE; n];\n\n        let trace = WitnessTrace {\n            values,\n            index: indices,\n        };\n        let matrix = WitnessAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n        assert_eq!(matrix.height(), n);\n        assert_eq!(matrix.width(), 1);\n\n        let config = build_test_config();\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(n, 1, multiplicities);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"verification failed\");\n    }\n\n    #[test]\n    fn test_witness_air_extension_field() {\n        type Ext4 = BinomialExtensionField\u003cVal, 4\u003e;\n\n        let a = Ext4::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(1),\n            Val::from_u64(2),\n            Val::from_u64(3),\n            Val::from_u64(4),\n        ])\n        .unwrap();\n\n        let b = Ext4::from_basis_coefficients_slice(\u0026[\n            Val::from_u64(5),\n            Val::from_u64(6),\n            Val::from_u64(7),\n            Val::from_u64(8),\n        ])\n        .unwrap();\n\n        let values = vec![a, b];\n        let indices = vec![WitnessId(0), WitnessId(1)];\n        let multiplicities = vec![Val::from_u64(1); indices.len()];\n\n        let trace = WitnessTrace {\n            values,\n            index: indices,\n        };\n        let matrix = WitnessAir::\u003cVal, 4\u003e::trace_to_matrix(\u0026trace, 1);\n\n        // Verify dimensions: D = 4 columns\n        assert_eq!(matrix.width(), 4);\n        assert_eq!(matrix.height(), 2);\n\n        // Check first row layout: [a_coeffs[0..3], index]\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            let a_coeffs = a.as_basis_coefficients_slice();\n            assert_eq!(\u0026row0[0..4], a_coeffs);\n        }\n\n        let config = build_test_config();\n        let air = WitnessAir::\u003cVal, 4\u003e::new_with_preprocessed(2, 1, multiplicities);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        // Check the correctness of preprocessed values.\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), 2);\n        let row0 = preprocessed_matrix.row_slice(0).unwrap();\n        let row_last = preprocessed_matrix.row_slice(1).unwrap();\n        // The first column corresponds to the multiplicity (1 for actuve rows).\n        assert_eq!(row0[0], Val::from_u64(1));\n        assert_eq!(row_last[0], Val::from_u64(1));\n        // Check the witness indices.\n        assert_eq!(row0[1], Val::from_u64(0)); // index\n        assert_eq!(row_last[1], Val::from_u64(1)); // index\n\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"Extension field verification failed\");\n    }\n\n    #[test]\n    fn test_witness_air_single_element() {\n        let values = vec![Val::from_u64(42)];\n        let indices = vec![WitnessId(0)];\n\n        let trace = WitnessTrace {\n            values,\n            index: indices,\n        };\n        let matrix = WitnessAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n        let multiplicity = vec![Val::ONE; 1];\n\n        // Should be padded to power of two\n        assert!(matrix.height().is_power_of_two());\n        assert_eq!(matrix.width(), 1);\n\n        // Check the single element\n        {\n            let row0 = matrix.row_slice(0).unwrap();\n            assert_eq!(row0[0], Val::from_u64(42)); // value\n        }\n\n        let config = build_test_config();\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(1, 1, multiplicity);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), matrix.height());\n        for i in 0..matrix.height() {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            assert_eq!(row[0], Val::ONE);\n            assert_eq!(row[1], Val::from_u64(i as u64)); // index\n        }\n\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"Single element verification failed\");\n    }\n\n    #[test]\n    fn test_witness_air_matrix_padding() {\n        let n = 3; // Not a power of two\n        let values: Vec\u003cVal\u003e = (1..=n as u64).map(Val::from_u64).collect();\n        let indices: Vec\u003cWitnessId\u003e = (0..n as u32).map(WitnessId).collect();\n        let multiplicities: Vec\u003cVal\u003e = vec![Val::ONE; n];\n\n        let trace = WitnessTrace {\n            values,\n            index: indices,\n        };\n        let matrix = WitnessAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, 1);\n\n        // Should be padded to next power of two (4)\n        assert_eq!(matrix.height(), 4);\n        assert!(matrix.height().is_power_of_two());\n\n        // Original rows should be preserved\n        for i in 0..n {\n            let row = matrix.row_slice(i).unwrap();\n            assert_eq!(row[0], Val::from_u64((i + 1) as u64)); // value\n        }\n\n        // Padded row should continue monotonic sequence\n        {\n            let last_row = matrix.row_slice(3).unwrap();\n            assert_eq!(last_row[0], Val::from_u64(3)); // last value repeated\n        }\n\n        let config = build_test_config();\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(3, 1, multiplicities);\n        let (prover_data, verifier_data) =\n            setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(matrix.height())).unwrap();\n\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), matrix.height());\n        for i in 0..n {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            // The multiplicity is 1 for active rows.\n            assert_eq!(row[0], Val::ONE);\n            // Check the witness index.\n            assert_eq!(row[1], Val::from_u64(i as u64)); // index\n        }\n        for i in n..matrix.height() {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            // The multiplicity is 0 for padding rows.\n            assert_eq!(row[0], Val::ZERO);\n            // Check the witness index.\n            assert_eq!(row[1], Val::from_u64(i as u64));\n        }\n        let pis: Vec\u003cVal\u003e = vec![];\n\n        let proof = prove_with_preprocessed(\u0026config, \u0026air, matrix, \u0026pis, Some(\u0026prover_data));\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, Some(\u0026verifier_data))\n            .expect(\"Padding verification failed\");\n    }\n\n    #[test]\n    fn witness_air_multi_lane_packs_sequential_indices() {\n        let values: Vec\u003cVal\u003e = vec![\n            Val::from_u64(10),\n            Val::from_u64(20),\n            Val::from_u64(30),\n            Val::from_u64(40),\n            Val::from_u64(50),\n        ];\n        let multiplicities = vec![\n            Val::from_u64(3),\n            Val::from_u64(4),\n            Val::from_u64(5),\n            Val::from_u64(6),\n            Val::from_u64(7),\n        ];\n        let indices: Vec\u003cWitnessId\u003e = (0..values.len() as u32).map(WitnessId).collect();\n        let trace = WitnessTrace {\n            values: values.clone(),\n            index: indices,\n        };\n\n        let lanes = 2;\n        let matrix = WitnessAir::\u003cVal, 1\u003e::trace_to_matrix(\u0026trace, lanes);\n\n        // Width doubles because each row now contains two lanes.\n        assert_eq!(matrix.width(), lanes * WitnessAir::\u003cVal, 1\u003e::lane_width());\n        // 5 witnesses -\u003e ceil(5 / 2) = 3 logical rows -\u003e padded to 4.\n        assert_eq!(matrix.height(), 4);\n\n        // Row 0 holds witnesses 0 and 1.\n        let row0 = matrix.row_slice(0).unwrap();\n        assert_eq!(row0[0], values[0]);\n        assert_eq!(row0[1], values[1]);\n\n        // Row 1 holds witnesses 2 and 3.\n        let row1 = matrix.row_slice(1).unwrap();\n        assert_eq!(row1[0], values[2]);\n        assert_eq!(row1[1], values[3]);\n\n        // Row 2 holds witness 4 and a virtual filler lane continuing the sequence.\n        let row2 = matrix.row_slice(2).unwrap();\n        assert_eq!(row2[0], values[4]);\n        assert_eq!(row2[1], values[4]);\n\n        let air = WitnessAir::\u003cVal, 1\u003e::new_with_preprocessed(\n            values.len(),\n            lanes,\n            multiplicities.clone(),\n        );\n        let preprocessed_matrix = air.preprocessed_trace().unwrap();\n        assert_eq!(preprocessed_matrix.height(), matrix.height());\n\n        // Check that the indices and multiplicities in the preprocessed matrix are correct.\n        let preprocessed_width = WitnessAir::\u003cVal, 1\u003e::preprocessed_lane_width();\n        for i in 0..matrix.height() {\n            let row = preprocessed_matrix.row_slice(i).unwrap();\n            for j in 0..lanes {\n                assert_eq!(\n                    row[j * preprocessed_width],\n                    if i * lanes + j \u003c values.len() {\n                        multiplicities[i * lanes + j]\n                    } else {\n                        Val::ZERO\n                    }\n                );\n                assert_eq!(\n                    row[j * preprocessed_width + 1],\n                    Val::from_u64((i * lanes + j) as u64)\n                );\n            }\n        }\n\n        assert_eq!(air.total_width(), matrix.width());\n    }\n}\n","traces":[{"line":86,"address":[3224048,3223888,3224368,3224208,3224528,3224688],"length":1,"stats":{"Line":8}},{"line":87,"address":[1961089],"length":1,"stats":{"Line":8}},{"line":92,"address":[1961131],"length":1,"stats":{"Line":8}},{"line":103,"address":[3223761,3223520],"length":1,"stats":{"Line":6}},{"line":108,"address":[3223736,3223565],"length":1,"stats":{"Line":6}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[3220489,3220452,3220729,3220649,3220612,3220809,3220772,3220569,3220409,3220692,3220852,3220532],"length":1,"stats":{"Line":8}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[8520000],"length":1,"stats":{"Line":2}},{"line":136,"address":[1961012,1960969],"length":1,"stats":{"Line":2}},{"line":157,"address":[3223486,3223480,3220880],"length":1,"stats":{"Line":6}},{"line":161,"address":[3220935],"length":1,"stats":{"Line":6}},{"line":163,"address":[8517479,8512199,8509559,8506903,8514839],"length":1,"stats":{"Line":6}},{"line":164,"address":[3221024],"length":1,"stats":{"Line":6}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[8507096,8509752,8515032,8512392,8517672],"length":1,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[8512434,8507138,8515074,8517714,8509794],"length":1,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":6}},{"line":176,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[8512548,8515188,8517828,8509908,8507252],"length":1,"stats":{"Line":6}},{"line":178,"address":[3221377,3221432,3221458],"length":1,"stats":{"Line":12}},{"line":180,"address":[3221535,3221440,3221479],"length":1,"stats":{"Line":12}},{"line":183,"address":[8517988,8510068,8518189,8512909,8507412,8515348,8515549,8512708,8507613,8510269],"length":1,"stats":{"Line":12}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":6}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[8518311,8510391,8513031,8507735,8515671],"length":1,"stats":{"Line":6}},{"line":195,"address":[],"length":0,"stats":{"Line":18}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[8507938,8518514,8510594,8513234,8515874],"length":1,"stats":{"Line":6}},{"line":198,"address":[8515897,8518537,8513257,8510617,8507961],"length":1,"stats":{"Line":6}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[3222196],"length":1,"stats":{"Line":6}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":205,"address":[3222546,3222599,3222646],"length":1,"stats":{"Line":12}},{"line":206,"address":[],"length":0,"stats":{"Line":12}},{"line":208,"address":[8511358,8516955,8509027,8511675,8516638,8513998,8514315,8519595,8519278,8508706],"length":1,"stats":{"Line":12}},{"line":209,"address":[8516965,8519605,8509037,8514325,8508779,8511431,8514071,8516711,8519351,8511685],"length":1,"stats":{"Line":12}},{"line":210,"address":[8519656,8511736,8517126,8509088,8517016,8514376,8509198,8514486,8519766,8511846],"length":1,"stats":{"Line":6}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":12}},{"line":218,"address":[3222836,3222907],"length":1,"stats":{"Line":12}},{"line":219,"address":[8509020,8514239,8514308,8516879,8508951,8519519,8511599,8511668,8516948,8519588],"length":1,"stats":{"Line":12}},{"line":220,"address":[8508963,8514251,8516891,8519531,8511611],"length":1,"stats":{"Line":6}},{"line":221,"address":[],"length":0,"stats":{"Line":6}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":230,"address":[3168752,3168816,3168736,3168800,3168768,3168784],"length":1,"stats":{"Line":8}},{"line":231,"address":[],"length":0,"stats":{"Line":8}},{"line":234,"address":[8372438,8373872,8374566,8373152,8373110,8372448,8375238,8373142,8372406,8373820,8374534,8374576,8373852,8371744,8375270],"length":1,"stats":{"Line":6}},{"line":235,"address":[8372542,8371838,8373966,8373247,8374670],"length":1,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":12}},{"line":244,"address":[],"length":0,"stats":{"Line":6}},{"line":245,"address":[3168584,3168341],"length":1,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":6}},{"line":251,"address":[],"length":0,"stats":{"Line":12}},{"line":252,"address":[3167915],"length":1,"stats":{"Line":6}},{"line":253,"address":[8372179,8373017,8373589,8374441,8375011,8372883,8372264,8372313,8375096,8375145,8373674,8372968,8374307,8374392,8373727],"length":1,"stats":{"Line":12}},{"line":262,"address":[8431115,8463163,8431712,8486352,8437639,8450636,8428592,8422464,8470640,8496128,8470132,8434235,8483232,8460043,8460640,8492482,8467408,8412464,8447035,8434832,8479604,8485755,8488875,8466764,8476880,8493120,8463760,8418836,8473760,8457520,8482635,8440683,8444512,8447632,8489472,8456923,8419344,8450642,8421867,8499132,8476283,8480112,8451280,8427995,8473163,8444004,8424958,8441280,8415468,8454400,8495614,8438160,8425472,8416112,8466770,8453803,8499138,8492476,8415474],"length":1,"stats":{"Line":23}},{"line":263,"address":[],"length":0,"stats":{"Line":23}},{"line":267,"address":[1954331,1957339],"length":1,"stats":{"Line":23}},{"line":268,"address":[1957493],"length":1,"stats":{"Line":14}},{"line":272,"address":[1954440,1954495,1957517,1957575],"length":1,"stats":{"Line":50}},{"line":273,"address":[],"length":0,"stats":{"Line":48}},{"line":278,"address":[],"length":0,"stats":{"Line":24}},{"line":279,"address":[3215595,3209355,3203003,3195834,3206214,3212475,3192587,3199482],"length":1,"stats":{"Line":24}},{"line":280,"address":[8464577,8474369,8413205,8477572,8441972,8490289,8493792,8496945,8432321,8416804,8419984,8455009,8468163,8435595,8486961,8458160,8474400,8423136,8429201,8435532,8419953,8445121,8471249,8438800,8480721,8445152,8461249,8432352,8429232,8442035,8486992,8426081,8461280,8468100,8426112,8448449,8448373,8490213,8451889,8496869,8493761,8480752,8438769,8451920,8471280,8483841,8455040,8477635,8483872,8423105,8413281,8458129,8464501,8416867],"length":1,"stats":{"Line":48}},{"line":282,"address":[8448602,8471343,8423230,8471374,8493886,8413368,8426175,8442188,8445246,8458223,8477722,8429326,8426206,8435682,8416954,8452014,8468316,8413434,8423199,8442122,8480815,8487086,8435748,8455134,8432415,8455103,8458254,8461343,8432446,8420047,8429295,8438894,8445215,8464664,8468250,8451983,8464730,8474463,8474494,8461374,8420078,8480846,8483935,8487055,8490376,8490442,8448536,8417020,8497098,8438863,8477788,8483966,8497032,8493855],"length":1,"stats":{"Line":48}},{"line":283,"address":[3212704,3206616,3209639,3212759,3215824,3199910,3206558,3209584,3215879,3199852,3203232,3192816,3192871,3203287,3196262,3196204],"length":1,"stats":{"Line":50}},{"line":284,"address":[],"length":0,"stats":{"Line":50}},{"line":286,"address":[3201849,3198201,3213064,3217602,3216184,3194594,3214482,3193176,3209944,3211362,3206934,3203592,3208331,3205010,3200215,3196567],"length":1,"stats":{"Line":0}},{"line":288,"address":[1960843,1956945,1960518,1960470,1957024,1960549,1956997,1957187],"length":1,"stats":{"Line":0}},{"line":289,"address":[1960718,1957136],"length":1,"stats":{"Line":0}},{"line":291,"address":[1955431,1958665],"length":1,"stats":{"Line":25}},{"line":293,"address":[3207083,3200351,3193312,3196703,3213200,3216320,3203728,3210080],"length":1,"stats":{"Line":25}},{"line":296,"address":[],"length":0,"stats":{"Line":25}},{"line":297,"address":[1955666,1959007],"length":1,"stats":{"Line":0}},{"line":298,"address":[3200612,3193516,3213404,3216524,3203932,3210284,3196964,3207239],"length":1,"stats":{"Line":0}},{"line":299,"address":[3216578,3193570,3203986,3213458,3207348,3204017,3213489,3200671,3193601,3200747,3216609,3207285,3197099,3197023,3210369,3210338],"length":1,"stats":{"Line":0}},{"line":300,"address":[8491501,8491559,8456019,8494749,8427146,8418032,8498157,8439779,8414551,8436772,8478800,8421018,8417974,8472314,8478742,8452899,8462314,8469270,8443200,8498215,8487971,8446186,8465789,8424093,8481786,8484851,8459139,8494804,8443142,8433331,8424148,8430266,8414493,8420963,8449719,8433386,8456074,8462259,8465847,8449661,8446131,8436714,8469328,8427091,8472259,8475434,8481731,8475379,8430211,8452954,8459194,8484906,8488026,8439834],"length":1,"stats":{"Line":0}},{"line":301,"address":[8418821,8433540,8415453,8414699,8453033,8421097,8459348,8470117,8479589,8418199,8473148,8478967,8485740,8475588,8469420,8427300,8488860,8450621,8436942,8439988,8437624,8443989,8465995,8418124,8485060,8482620,8488105,8446265,8465926,8460028,8492461,8449867,8430420,8488180,8434220,8498363,8481865,8424240,8427980,8443367,8463148,8498294,8421172,8430345,8456228,8449798,8472468,8484985,8453788,8456908,8466749,8436867,8472393,8424943,8424315,8476268,8462393,8453108,8446340,8491707,8427225,8456153,8447020,8495599,8494971,8439913,8462468,8499117,8431100,8440668,8459273,8491638,8414630,8421852,8475513,8478892,8494896,8433465,8443292,8469495,8481940],"length":1,"stats":{"Line":0}},{"line":302,"address":[3194022,3193974,3207844,3201149,3213910,3204438,3213862,3197575,3201223,3204390,3210790,3216982,3210742,3217030,3197501,3207784],"length":1,"stats":{"Line":0}},{"line":304,"address":[3217283,3197860,3201508,3204691,3201429,3204961,3208282,3211043,3208100,3217553,3197781,3217235,3210995,3194227,3198146,3204643,3208127,3204722,3201477,3194306,3197829,3208048,3211313,3217314,3194545,3214433,3194275,3214194,3201794,3211074,3214115,3214163],"length":1,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[8541680],"length":1,"stats":{"Line":1}},{"line":315,"address":[],"length":0,"stats":{"Line":1}},{"line":316,"address":[8541718,8541783],"length":1,"stats":{"Line":1}},{"line":317,"address":[8541753,8541801,8541879],"length":1,"stats":{"Line":2}},{"line":320,"address":[8541640,8539968,8541646],"length":1,"stats":{"Line":1}},{"line":321,"address":[],"length":0,"stats":{"Line":1}},{"line":322,"address":[],"length":0,"stats":{"Line":1}},{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":1}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":2}},{"line":340,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":1}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":2}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":357,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":1}}],"covered":88,"coverable":127},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","batch_stark_prover.rs"],"content":"//! Batch STARK prover and verifier that unifies all circuit tables\n//! into a single batched STARK proof using `p3-batch-stark`.\n\nuse alloc::boxed::Box;\nuse alloc::string::String;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::borrow::Borrow;\nuse core::mem::transmute;\n\nuse p3_air::{Air, AirBuilder, BaseAir, PairBuilder};\nuse p3_baby_bear::{\n    BabyBear, GenericPoseidon2LinearLayersBabyBear, default_babybear_poseidon2_16,\n    default_babybear_poseidon2_24,\n};\nuse p3_batch_stark::{BatchProof, CommonData, StarkGenericConfig, StarkInstance, Val};\nuse p3_circuit::op::PrimitiveOpType;\nuse p3_circuit::tables::{\n    Poseidon2CircuitRow, Poseidon2CircuitTrace, Poseidon2Params, Poseidon2Trace, Traces,\n};\nuse p3_field::extension::{BinomialExtensionField, BinomiallyExtendable};\nuse p3_field::{BasedVectorSpace, ExtensionField, Field, PrimeCharacteristicRing, PrimeField};\nuse p3_koala_bear::{\n    GenericPoseidon2LinearLayersKoalaBear, KoalaBear, default_koalabear_poseidon2_16,\n    default_koalabear_poseidon2_24,\n};\nuse p3_lookup::folder::{ProverConstraintFolderWithLookups, VerifierConstraintFolderWithLookups};\nuse p3_lookup::lookup_traits::{AirLookupHandler, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_poseidon2_air::RoundConstants;\nuse p3_poseidon2_circuit_air::*;\nuse p3_symmetric::CryptographicPermutation;\nuse p3_uni_stark::{ProverConstraintFolder, SymbolicAirBuilder, VerifierConstraintFolder};\nuse thiserror::Error;\nuse tracing::instrument;\n\nuse crate::air::utils::AirLookupHandlerDyn;\nuse crate::air::{AddAir, ConstAir, MulAir, PublicAir, WitnessAir};\nuse crate::common::CircuitTableAir;\nuse crate::config::StarkField;\nuse crate::field_params::ExtractBinomialW;\n\n/// Configuration for packing multiple primitive operations into a single AIR row.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct TablePacking {\n    witness_lanes: usize,\n    add_lanes: usize,\n    mul_lanes: usize,\n}\n\nimpl TablePacking {\n    pub fn new(witness_lanes: usize, add_lanes: usize, mul_lanes: usize) -\u003e Self {\n        Self {\n            witness_lanes: witness_lanes.max(1),\n            add_lanes: add_lanes.max(1),\n            mul_lanes: mul_lanes.max(1),\n        }\n    }\n\n    pub fn from_counts(witness_lanes: usize, add_lanes: usize, mul_lanes: usize) -\u003e Self {\n        Self::new(witness_lanes, add_lanes, mul_lanes)\n    }\n\n    pub const fn witness_lanes(self) -\u003e usize {\n        self.witness_lanes\n    }\n\n    pub const fn add_lanes(self) -\u003e usize {\n        self.add_lanes\n    }\n\n    pub const fn mul_lanes(self) -\u003e usize {\n        self.mul_lanes\n    }\n}\n\nimpl Default for TablePacking {\n    fn default() -\u003e Self {\n        Self::new(1, 1, 1)\n    }\n}\n\n/// Metadata describing a non-primitive table inside a batch proof.\n///\n/// Every non-primitive dynamic plugin produces exactly one `NonPrimitiveTableEntry`\n/// per batch instance. The entry is stored inside a `BatchStarkProof` and later provided\n/// back to the plugin during verification through\n/// [`TableProver::batch_air_from_table_entry`].\npub struct NonPrimitiveTableEntry\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    /// Plugin identifier (it should match `TableProver::id`).\n    pub id: \u0026'static str,\n    /// Number of logical rows produced for this table.\n    pub rows: usize,\n    /// Public values exposed by this table (if any).\n    pub public_values: Vec\u003cVal\u003cSC\u003e\u003e,\n}\n\n/// Type-erased AIR implementation for dynamically registered non-primitive tables.\n///\n/// This allows the batch prover to mix primitive AIRs with plugin AIRs in a single heterogeneous\n/// batch.\n/// Internally,`DynamicAirEntry` wraps the boxed plugin AIR and exposes a shared accessor\n/// so that both prover and verifier can operate without knowing the concrete underlying type.\npub struct DynamicAirEntry\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    air: Box\u003cdyn BatchAir\u003cSC\u003e\u003e,\n}\n\nimpl\u003cSC\u003e DynamicAirEntry\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    pub fn new(inner: Box\u003cdyn BatchAir\u003cSC\u003e\u003e) -\u003e Self {\n        Self { air: inner }\n    }\n\n    pub fn air(\u0026self) -\u003e \u0026dyn BatchAir\u003cSC\u003e {\n        \u0026*self.air\n    }\n\n    pub fn air_mut(\u0026mut self) -\u003e \u0026mut dyn BatchAir\u003cSC\u003e {\n        \u0026mut *self.air\n    }\n}\n\n/// Simple super trait of [`Air`] describing the behaviour of a non-primitive\n/// dynamically dispatched AIR used in batched proofs.\npub trait BatchAir\u003cSC\u003e:\n    BaseAir\u003cVal\u003cSC\u003e\u003e\n    + Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e\n    + for\u003c'a\u003e Air\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e\n    + for\u003c'a\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e\n    + AirLookupHandlerDyn\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e\n    + for\u003c'a\u003e AirLookupHandlerDyn\u003cProverConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    + for\u003c'a\u003e AirLookupHandlerDyn\u003cVerifierConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    + Send\n    + Sync\nwhere\n    SC: StarkGenericConfig,\n{\n}\n\n/// Data needed to insert a dynamic table instance into the batched prover.\n///\n/// A `BatchTableInstance` bundles everything the batch prover needs from a\n/// non-primitive table plugin: the AIR, its populated trace matrix, any\n/// public values it exposes, and the number of rows it produces.\npub struct BatchTableInstance\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    /// Plugin identifier (it should match `TableProver::id`).\n    pub id: \u0026'static str,\n    /// The AIR implementation for this table.\n    pub air: DynamicAirEntry\u003cSC\u003e,\n    /// The populated trace matrix for this table.\n    pub trace: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e,\n    /// Public values exposed by this table.\n    pub public_values: Vec\u003cVal\u003cSC\u003e\u003e,\n    /// Number of rows produced for this table.\n    pub rows: usize,\n}\n\n#[inline(always)]\n/// # Safety\n///\n/// Caller must ensure that both `Traces\u003cFromEF\u003e` and `Traces\u003cToEF\u003e` share an\n/// identical in-memory representation.\npub(crate) unsafe fn transmute_traces\u003cFromEF, ToEF\u003e(t: \u0026Traces\u003cFromEF\u003e) -\u003e \u0026Traces\u003cToEF\u003e {\n    debug_assert_eq!(\n        core::mem::size_of::\u003cTraces\u003cFromEF\u003e\u003e(),\n        core::mem::size_of::\u003cTraces\u003cToEF\u003e\u003e()\n    );\n    debug_assert_eq!(\n        core::mem::align_of::\u003cTraces\u003cFromEF\u003e\u003e(),\n        core::mem::align_of::\u003cTraces\u003cToEF\u003e\u003e()\n    );\n\n    unsafe { \u0026*(t as *const _ as *const Traces\u003cToEF\u003e) }\n}\n\n/// Trait implemented by all non-primitive table plugins used by the batch prover.\n///\n/// Implementors would typically delegate to an existing AIR type, define a base case\n/// for base-field traces, and then use the [`impl_table_prover_batch_instances_from_base!`]\n/// macro to generate the degree-specific implementations.\n///\n/// ```ignore\n/// impl\u003cSC\u003e TableProver\u003cSC\u003e for MyPlugin {\n///     fn id(\u0026self) -\u003e \u0026'static str { \"my_plugin\" }\n///\n///     impl_table_prover_batch_instances_from_base!(batch_instance_base);\n/// }\n/// ```\npub trait TableProver\u003cSC\u003e: Send + Sync\nwhere\n    SC: StarkGenericConfig + 'static,\n{\n    /// Identifier for this prover.\n    fn id(\u0026self) -\u003e \u0026'static str;\n\n    /// Produce a batched table instance for base-field traces.\n    fn batch_instance_d1(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cVal\u003cSC\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Produce a batched table instance for degree-2 extension traces.\n    fn batch_instance_d2(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 2\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Produce a batched table instance for degree-4 extension traces.\n    fn batch_instance_d4(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 4\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Produce a batched table instance for degree-6 extension traces.\n    fn batch_instance_d6(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 6\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Produce a batched table instance for degree-8 extension traces.\n    fn batch_instance_d8(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 8\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e;\n\n    /// Rebuild the AIR for verification from the recorded non-primitive table entry.\n    fn batch_air_from_table_entry(\n        \u0026self,\n        config: \u0026SC,\n        degree: usize,\n        table_entry: \u0026NonPrimitiveTableEntry\u003cSC\u003e,\n    ) -\u003e Result\u003cDynamicAirEntry\u003cSC\u003e, String\u003e;\n}\n\n/// Convenience macro for deriving all degree-specific helpers from a single base\n/// implementation.\n///\n/// Plugins usually implement a single `batch_instance_base` method that operates on\n/// base-field traces. This macro reuses that method to provide the `batch_instance_d*`\n/// variants by casting higher-degree traces back to the base field.\n///\n/// Users can invoke it inside their `TableProver` impl:\n///\n/// ```ignore\n/// impl\u003cSC\u003e TableProver\u003cSC\u003e for MyPlugin {\n///     fn id(\u0026self) -\u003e \u0026'static str { \"my_plugin\" }\n///\n///     impl_table_prover_batch_instances_from_base!(batch_instance_base);\n///\n///     fn batch_air_from_table_entry(\n///         \u0026self,\n///         config: \u0026SC,\n///         degree: usize,\n///         table_entry: \u0026NonPrimitiveTableEntry\u003cSC\u003e,\n///     ) -\u003e Result\u003cDynamicAirEntry\u003cSC\u003e, String\u003e {\n///         Ok(DynamicAirEntry::new(Box::new(MyPluginAir::\u003cVal\u003cSC\u003e\u003e::new(config))))\n///     }\n/// }\n/// ```\n#[macro_export]\nmacro_rules! impl_table_prover_batch_instances_from_base {\n    ($base:ident) =\u003e {\n        fn batch_instance_d1(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            self.$base::\u003cSC\u003e(config, packing, traces)\n        }\n\n        fn batch_instance_d2(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003c\n                p3_field::extension::BinomialExtensionField\u003cp3_batch_stark::Val\u003cSC\u003e, 2\u003e,\n            \u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            let t: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e =\n                unsafe { transmute_traces(traces) };\n            self.$base::\u003cSC\u003e(config, packing, t)\n        }\n\n        fn batch_instance_d4(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003c\n                p3_field::extension::BinomialExtensionField\u003cp3_batch_stark::Val\u003cSC\u003e, 4\u003e,\n            \u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            let t: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e =\n                unsafe { transmute_traces(traces) };\n            self.$base::\u003cSC\u003e(config, packing, t)\n        }\n\n        fn batch_instance_d6(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003c\n                p3_field::extension::BinomialExtensionField\u003cp3_batch_stark::Val\u003cSC\u003e, 6\u003e,\n            \u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            let t: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e =\n                unsafe { transmute_traces(traces) };\n            self.$base::\u003cSC\u003e(config, packing, t)\n        }\n\n        fn batch_instance_d8(\n            \u0026self,\n            config: \u0026SC,\n            packing: TablePacking,\n            traces: \u0026p3_circuit::tables::Traces\u003c\n                p3_field::extension::BinomialExtensionField\u003cp3_batch_stark::Val\u003cSC\u003e, 8\u003e,\n            \u003e,\n        ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n            let t: \u0026p3_circuit::tables::Traces\u003cp3_batch_stark::Val\u003cSC\u003e\u003e =\n                unsafe { transmute_traces(traces) };\n            self.$base::\u003cSC\u003e(config, packing, t)\n        }\n    };\n}\n\n/// Poseidon2 configuration that can be selected at runtime.\n/// This enum represents different Poseidon2 configurations (field type, width, etc.).\n#[derive(Debug, Clone)]\npub enum Poseidon2Config {\n    /// BabyBear D=4, WIDTH=16 configuration\n    BabyBearD4Width16 {\n        permutation: p3_baby_bear::Poseidon2BabyBear\u003c16\u003e,\n        constants: RoundConstants\u003cp3_baby_bear::BabyBear, 16, 4, 13\u003e,\n    },\n    /// BabyBear D=4, WIDTH=24 configuration\n    BabyBearD4Width24 {\n        permutation: p3_baby_bear::Poseidon2BabyBear\u003c24\u003e,\n        constants: RoundConstants\u003cp3_baby_bear::BabyBear, 24, 4, 21\u003e,\n    },\n    /// KoalaBear D=4, WIDTH=16 configuration\n    KoalaBearD4Width16 {\n        permutation: p3_koala_bear::Poseidon2KoalaBear\u003c16\u003e,\n        constants: RoundConstants\u003cp3_koala_bear::KoalaBear, 16, 4, 20\u003e,\n    },\n    /// KoalaBear D=4, WIDTH=24 configuration\n    KoalaBearD4Width24 {\n        permutation: p3_koala_bear::Poseidon2KoalaBear\u003c24\u003e,\n        constants: RoundConstants\u003cp3_koala_bear::KoalaBear, 24, 4, 23\u003e,\n    },\n}\n\nimpl Poseidon2Config {\n    /// Create BabyBear D=4 WIDTH=16 configuration from default permutation.\n    /// Uses the same permutation and constants as `default_babybear_poseidon2_16()`.\n    pub fn baby_bear_d4_width16() -\u003e Self {\n        let perm = default_babybear_poseidon2_16();\n\n        let beginning_full: [[BabyBear; 16]; 4] = p3_baby_bear::BABYBEAR_RC16_EXTERNAL_INITIAL;\n        let partial: [BabyBear; 13] = p3_baby_bear::BABYBEAR_RC16_INTERNAL;\n        let ending_full: [[BabyBear; 16]; 4] = p3_baby_bear::BABYBEAR_RC16_EXTERNAL_FINAL;\n\n        let constants = RoundConstants::new(beginning_full, partial, ending_full);\n\n        Self::BabyBearD4Width16 {\n            permutation: perm,\n            constants,\n        }\n    }\n\n    /// Create BabyBear D=4 WIDTH=24 configuration from default permutation.\n    /// Uses the same permutation and constants as `default_babybear_poseidon2_24()`.\n    pub fn baby_bear_d4_width24() -\u003e Self {\n        let perm = default_babybear_poseidon2_24();\n\n        let beginning_full: [[BabyBear; 24]; 4] = p3_baby_bear::BABYBEAR_RC24_EXTERNAL_INITIAL;\n        let partial: [BabyBear; 21] = p3_baby_bear::BABYBEAR_RC24_INTERNAL;\n        let ending_full: [[BabyBear; 24]; 4] = p3_baby_bear::BABYBEAR_RC24_EXTERNAL_FINAL;\n\n        let constants = RoundConstants::new(beginning_full, partial, ending_full);\n\n        Self::BabyBearD4Width24 {\n            permutation: perm,\n            constants,\n        }\n    }\n\n    /// Create KoalaBear D=4 WIDTH=16 configuration from default permutation.\n    /// Uses the same permutation and constants as `default_koalabear_poseidon2_16()`.\n    pub fn koala_bear_d4_width16() -\u003e Self {\n        let perm = default_koalabear_poseidon2_16();\n\n        let beginning_full: [[KoalaBear; 16]; 4] = p3_koala_bear::KOALABEAR_RC16_EXTERNAL_INITIAL;\n        let partial: [KoalaBear; 20] = p3_koala_bear::KOALABEAR_RC16_INTERNAL;\n        let ending_full: [[KoalaBear; 16]; 4] = p3_koala_bear::KOALABEAR_RC16_EXTERNAL_FINAL;\n\n        let constants = RoundConstants::new(beginning_full, partial, ending_full);\n\n        Self::KoalaBearD4Width16 {\n            permutation: perm,\n            constants,\n        }\n    }\n\n    /// Create KoalaBear D=4 WIDTH=24 configuration from default permutation.\n    /// Uses the same permutation and constants as `default_koalabear_poseidon2_24()`.\n    pub fn koala_bear_d4_width24() -\u003e Self {\n        let perm = default_koalabear_poseidon2_24();\n\n        let beginning_full: [[KoalaBear; 24]; 4] = p3_koala_bear::KOALABEAR_RC24_EXTERNAL_INITIAL;\n        let partial: [KoalaBear; 23] = p3_koala_bear::KOALABEAR_RC24_INTERNAL;\n        let ending_full: [[KoalaBear; 24]; 4] = p3_koala_bear::KOALABEAR_RC24_EXTERNAL_FINAL;\n\n        let constants = RoundConstants::new(beginning_full, partial, ending_full);\n\n        Self::KoalaBearD4Width24 {\n            permutation: perm,\n            constants,\n        }\n    }\n\n    fn to_air_wrapper(\u0026self) -\u003e Poseidon2AirWrapperInner {\n        match self {\n            Self::BabyBearD4Width16 { constants, .. } =\u003e {\n                Poseidon2AirWrapperInner::BabyBearD4Width16(Box::new(\n                    Poseidon2CircuitAirBabyBearD4Width16::new(constants.clone()),\n                ))\n            }\n            Self::BabyBearD4Width24 { constants, .. } =\u003e {\n                Poseidon2AirWrapperInner::BabyBearD4Width24(Box::new(\n                    Poseidon2CircuitAirBabyBearD4Width24::new(constants.clone()),\n                ))\n            }\n            Self::KoalaBearD4Width16 { constants, .. } =\u003e {\n                Poseidon2AirWrapperInner::KoalaBearD4Width16(Box::new(\n                    Poseidon2CircuitAirKoalaBearD4Width16::new(constants.clone()),\n                ))\n            }\n            Self::KoalaBearD4Width24 { constants, .. } =\u003e {\n                Poseidon2AirWrapperInner::KoalaBearD4Width24(Box::new(\n                    Poseidon2CircuitAirKoalaBearD4Width24::new(constants.clone()),\n                ))\n            }\n        }\n    }\n}\n\n/// Wrapper for Poseidon2CircuitAir that implements BatchAir\u003cSC\u003e\n// We need this because `BatchAir` requires `BaseAir\u003cVal\u003cSC\u003e\u003e`.\n// but `Poseidon2CircuitAir` works over a specific field.\nenum Poseidon2AirWrapperInner {\n    BabyBearD4Width16(Box\u003cPoseidon2CircuitAirBabyBearD4Width16\u003e),\n    BabyBearD4Width24(Box\u003cPoseidon2CircuitAirBabyBearD4Width24\u003e),\n    KoalaBearD4Width16(Box\u003cPoseidon2CircuitAirKoalaBearD4Width16\u003e),\n    KoalaBearD4Width24(Box\u003cPoseidon2CircuitAirKoalaBearD4Width24\u003e),\n}\n\nimpl Poseidon2AirWrapperInner {\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::BabyBearD4Width16(air) =\u003e air.width(),\n            Self::BabyBearD4Width24(air) =\u003e air.width(),\n            Self::KoalaBearD4Width16(air) =\u003e air.width(),\n            Self::KoalaBearD4Width24(air) =\u003e air.width(),\n        }\n    }\n}\n\nstruct Poseidon2AirWrapper\u003cSC: StarkGenericConfig\u003e {\n    inner: Poseidon2AirWrapperInner,\n    width: usize,\n    preprocessed: Vec\u003cVal\u003cSC\u003e\u003e,\n    _phantom: core::marker::PhantomData\u003cSC\u003e,\n}\n\nimpl\u003cSC\u003e BatchAir\u003cSC\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField,\n{\n}\n\nimpl\u003cSC\u003e BaseAir\u003cVal\u003cSC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField,\n{\n    fn width(\u0026self) -\u003e usize {\n        self.width\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e {\n        let height = self\n            .preprocessed\n            .len()\n            .div_ceil(poseidon2_preprocessed_width())\n            .next_power_of_two()\n            * poseidon2_preprocessed_width();\n\n        let mut values = self.preprocessed.clone();\n        values.resize(height, Val::\u003cSC\u003e::ZERO);\n        Some(RowMajorMatrix::new(values, poseidon2_preprocessed_width()))\n    }\n}\n\nimpl\u003cSC\u003e Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField,\n{\n    fn eval(\u0026self, builder: \u0026mut SymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e) {\n        const BABY_BEAR_MODULUS: u64 = 2013265921;\n        const KOALA_BEAR_MODULUS: u64 = 2147483649;\n\n        // Delegate to the actual AIR instance stored in the wrapper\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                // Runtime check: verify Val\u003cSC\u003e == BabyBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                // SAFETY: Val\u003cSC\u003e == BabyBear when this variant is used\n                // SymbolicAirBuilder\u003cBabyBear\u003e and SymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e have the same layout\n                unsafe {\n                    let builder_bb: \u0026mut SymbolicAirBuilder\u003cBabyBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_bb);\n                }\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                // Runtime check: verify Val\u003cSC\u003e == BabyBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                // SAFETY: Val\u003cSC\u003e == BabyBear when this variant is used\n                // SymbolicAirBuilder\u003cBabyBear\u003e and SymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e have the same layout\n                unsafe {\n                    let builder_bb: \u0026mut SymbolicAirBuilder\u003cBabyBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_bb);\n                }\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                // Runtime check: verify Val\u003cSC\u003e == KoalaBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                // SAFETY: Val\u003cSC\u003e == KoalaBear when this variant is used\n                // SymbolicAirBuilder\u003cKoalaBear\u003e and SymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e have the same layout\n                unsafe {\n                    let builder_kb: \u0026mut SymbolicAirBuilder\u003cKoalaBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_kb);\n                }\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                // Runtime check: verify Val\u003cSC\u003e == KoalaBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                // SAFETY: Val\u003cSC\u003e == KoalaBear when this variant is used\n                // SymbolicAirBuilder\u003cKoalaBear\u003e and SymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e have the same layout\n                unsafe {\n                    let builder_kb: \u0026mut SymbolicAirBuilder\u003cKoalaBear\u003e =\n                        core::mem::transmute(builder);\n                    Air::eval(air.as_ref(), builder_kb);\n                }\n            }\n        }\n    }\n}\n\n/// Helper function to evaluate a Poseidon2 variant with a given builder.\n/// This encapsulates the common pattern of transmuting slices and calling eval_unchecked.\nunsafe fn eval_poseidon2_variant\u003c\n    SC,\n    F: PrimeField,\n    AB: PairBuilder,\n    LinearLayers,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e(\n    air: \u0026Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e,\n    builder: \u0026mut AB,\n    local_slice: \u0026[\u003cAB as AirBuilder\u003e::Var],\n    next_slice: \u0026[\u003cAB as AirBuilder\u003e::Var],\n    next_preprocessed_slice: \u0026[\u003cAB as AirBuilder\u003e::Var],\n) where\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n    AB::F: PrimeField,\n    LinearLayers: p3_poseidon2::GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n{\n    // Transmute slices from PackedVal\u003cSC\u003e to F::Packing\n    // SAFETY: Val\u003cSC\u003e == F at runtime\n    unsafe {\n        let local_slice_ptr = local_slice.as_ptr() as *const \u003cF as p3_field::Field\u003e::Packing;\n        let local_slice_f = core::slice::from_raw_parts(local_slice_ptr, local_slice.len());\n        let local_f: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitCols\u003c\n            \u003cF as p3_field::Field\u003e::Packing,\n            p3_poseidon2_air::Poseidon2Cols\u003c\n                \u003cF as p3_field::Field\u003e::Packing,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = (*local_slice_f).borrow();\n\n        let next_slice_ptr = next_slice.as_ptr() as *const \u003cF as p3_field::Field\u003e::Packing;\n        let next_slice_f = core::slice::from_raw_parts(next_slice_ptr, next_slice.len());\n        let next_f: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitCols\u003c\n            \u003cF as p3_field::Field\u003e::Packing,\n            p3_poseidon2_air::Poseidon2Cols\u003c\n                \u003cF as p3_field::Field\u003e::Packing,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = (*next_slice_f).borrow();\n\n        let next_preprocessed_ptr =\n            next_preprocessed_slice.as_ptr() as *const \u003cF as p3_field::Field\u003e::Packing;\n        let next_preprocessed_f =\n            core::slice::from_raw_parts(next_preprocessed_ptr, next_preprocessed_slice.len());\n\n        // Transmute struct references to match builder's Var type\n        let local_var: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitCols\u003c\n            AB::Var,\n            p3_poseidon2_air::Poseidon2Cols\u003c\n                AB::Var,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = core::mem::transmute(local_f);\n\n        let next_var: \u0026p3_poseidon2_circuit_air::Poseidon2CircuitCols\u003c\n            AB::Var,\n            p3_poseidon2_air::Poseidon2Cols\u003c\n                AB::Var,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = core::mem::transmute(next_f);\n\n        let next_preprocessed_var: \u0026[AB::Var] = core::mem::transmute(next_preprocessed_f);\n\n        eval_unchecked::\u003c\n            F,\n            AB,\n            LinearLayers,\n            D,\n            WIDTH,\n            WIDTH_EXT,\n            RATE_EXT,\n            CAPACITY_EXT,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e(air, builder, local_var, next_var, next_preprocessed_var);\n    }\n}\n\nimpl\u003c'a, SC\u003e Air\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut ProverConstraintFolder\u003c'a, SC\u003e) {\n        // Extract row data (same pattern as Poseidon2CircuitAir::eval)\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder.preprocessed();\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    ProverConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    ProverConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    ProverConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    ProverConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n}\n\nimpl\u003c'a, SC\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut VerifierConstraintFolder\u003c'a, SC\u003e) {\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder.preprocessed();\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    VerifierConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    VerifierConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    VerifierConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    VerifierConstraintFolder\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n}\n\nimpl\u003c'a, SC\u003e Air\u003cProverConstraintFolderWithLookups\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut ProverConstraintFolderWithLookups\u003c'a, SC\u003e) {\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder.preprocessed();\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    ProverConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n}\n\nimpl\u003c'a, SC\u003e Air\u003cVerifierConstraintFolderWithLookups\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut VerifierConstraintFolderWithLookups\u003c'a, SC\u003e) {\n        let main = builder.main();\n        let local_slice = main.row_slice(0).expect(\"The matrix is empty?\");\n        let next_slice = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let preprocessed = builder.preprocessed();\n        let next_preprocessed_slice = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n\n        match \u0026self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width16::D },\n                    { BabyBearD4Width16::WIDTH },\n                    { BabyBearD4Width16::WIDTH_EXT },\n                    { BabyBearD4Width16::RATE_EXT },\n                    { BabyBearD4Width16::CAPACITY_EXT },\n                    { BabyBearD4Width16::SBOX_DEGREE },\n                    { BabyBearD4Width16::SBOX_REGISTERS },\n                    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    BabyBear,\n                    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersBabyBear,\n                    { BabyBearD4Width24::D },\n                    { BabyBearD4Width24::WIDTH },\n                    { BabyBearD4Width24::WIDTH_EXT },\n                    { BabyBearD4Width24::RATE_EXT },\n                    { BabyBearD4Width24::CAPACITY_EXT },\n                    { BabyBearD4Width24::SBOX_DEGREE },\n                    { BabyBearD4Width24::SBOX_REGISTERS },\n                    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n                    { BabyBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width16::D },\n                    { KoalaBearD4Width16::WIDTH },\n                    { KoalaBearD4Width16::WIDTH_EXT },\n                    { KoalaBearD4Width16::RATE_EXT },\n                    { KoalaBearD4Width16::CAPACITY_EXT },\n                    { KoalaBearD4Width16::SBOX_DEGREE },\n                    { KoalaBearD4Width16::SBOX_REGISTERS },\n                    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                eval_poseidon2_variant::\u003c\n                    SC,\n                    KoalaBear,\n                    VerifierConstraintFolderWithLookups\u003c'a, SC\u003e,\n                    GenericPoseidon2LinearLayersKoalaBear,\n                    { KoalaBearD4Width24::D },\n                    { KoalaBearD4Width24::WIDTH },\n                    { KoalaBearD4Width24::WIDTH_EXT },\n                    { KoalaBearD4Width24::RATE_EXT },\n                    { KoalaBearD4Width24::CAPACITY_EXT },\n                    { KoalaBearD4Width24::SBOX_DEGREE },\n                    { KoalaBearD4Width24::SBOX_REGISTERS },\n                    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n                    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n                \u003e(\n                    air.as_ref(),\n                    builder,\n                    \u0026local_slice,\n                    \u0026next_slice,\n                    \u0026next_preprocessed_slice,\n                );\n            },\n        }\n    }\n}\n\nimpl\u003cSC\u003e AirLookupHandler\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width16 as AirLookupHandler\u003c\n                    SymbolicAirBuilder\u003cBabyBear\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e {\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirBabyBearD4Width24 as AirLookupHandler\u003c\n                    SymbolicAirBuilder\u003cBabyBear\u003e,\n                \u003e\u003e::add_lookup_columns(air_bb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width16 as AirLookupHandler\u003c\n                    SymbolicAirBuilder\u003cKoalaBear\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e {\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                \u003cPoseidon2CircuitAirKoalaBearD4Width24 as AirLookupHandler\u003c\n                    SymbolicAirBuilder\u003cKoalaBear\u003e,\n                \u003e\u003e::add_lookup_columns(air_kb)\n            }\n        }\n    }\n\n    #[allow(clippy::missing_transmute_annotations)] // this gets overly verbose otherwise\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cp3_lookup::lookup_traits::Lookup\u003cVal\u003cSC\u003e\u003e\u003e {\n        const BABY_BEAR_MODULUS: u64 = 2013265921;\n        const KOALA_BEAR_MODULUS: u64 = 2147483649;\n\n        match \u0026mut self.inner {\n            Poseidon2AirWrapperInner::BabyBearD4Width16(air) =\u003e unsafe {\n                // Runtime check: verify Val\u003cSC\u003e == BabyBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width16 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width16 as AirLookupHandler\u003c\n                    SymbolicAirBuilder\u003cBabyBear\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::BabyBearD4Width24(air) =\u003e unsafe {\n                // Runtime check: verify Val\u003cSC\u003e == BabyBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(BABY_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_bb: \u0026mut Poseidon2CircuitAirBabyBearD4Width24 = air.as_mut();\n                let lookups_bb = \u003cPoseidon2CircuitAirBabyBearD4Width24 as AirLookupHandler\u003c\n                    SymbolicAirBuilder\u003cBabyBear\u003e,\n                \u003e\u003e::get_lookups(air_bb);\n                core::mem::transmute(lookups_bb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width16(air) =\u003e unsafe {\n                // Runtime check: verify Val\u003cSC\u003e == KoalaBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width16 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width16 as AirLookupHandler\u003c\n                    SymbolicAirBuilder\u003cKoalaBear\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n            Poseidon2AirWrapperInner::KoalaBearD4Width24(air) =\u003e unsafe {\n                // Runtime check: verify Val\u003cSC\u003e == KoalaBear before transmute\n                assert_eq!(Val::\u003cSC\u003e::from_u64(KOALA_BEAR_MODULUS), Val::\u003cSC\u003e::ZERO,);\n                let air_kb: \u0026mut Poseidon2CircuitAirKoalaBearD4Width24 = air.as_mut();\n                let lookups_kb = \u003cPoseidon2CircuitAirKoalaBearD4Width24 as AirLookupHandler\u003c\n                    SymbolicAirBuilder\u003cKoalaBear\u003e,\n                \u003e\u003e::get_lookups(air_kb);\n                core::mem::transmute(lookups_kb)\n            },\n        }\n    }\n}\n\nimpl\u003c'a, SC\u003e AirLookupHandler\u003cProverConstraintFolderWithLookups\u003c'a, SC\u003e\u003e for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        \u003cSelf as AirLookupHandler\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e\u003e::add_lookup_columns(self)\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cp3_lookup::lookup_traits::Lookup\u003cVal\u003cSC\u003e\u003e\u003e {\n        \u003cSelf as AirLookupHandler\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e\u003e::get_lookups(self)\n    }\n}\n\nimpl\u003c'a, SC\u003e AirLookupHandler\u003cVerifierConstraintFolderWithLookups\u003c'a, SC\u003e\u003e\n    for Poseidon2AirWrapper\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + Send + Sync,\n    Val\u003cSC\u003e: StarkField + PrimeField,\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        \u003cSelf as AirLookupHandler\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e\u003e::add_lookup_columns(self)\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cp3_lookup::lookup_traits::Lookup\u003cVal\u003cSC\u003e\u003e\u003e {\n        \u003cSelf as AirLookupHandler\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e\u003e::get_lookups(self)\n    }\n}\n\n/// Poseidon2 prover plugin that supports runtime configuration\n///\n/// This prover handles Poseidon2 hash operations in the circuit.\n/// It stores a configuration enum that can represent different\n/// Poseidon2 configurations (BabyBear/KoalaBear, different widths, etc).\n#[derive(Clone)]\npub struct Poseidon2Prover {\n    /// The configuration that provides permutation and constants\n    config: Poseidon2Config,\n}\n\nunsafe impl Send for Poseidon2Prover {}\nunsafe impl Sync for Poseidon2Prover {}\n\nimpl Poseidon2Prover {\n    /// Create a new Poseidon2Prover with the given configuration\n    pub const fn new(config: Poseidon2Config) -\u003e Self {\n        Self { config }\n    }\n\n    pub fn wrapper_from_config_with_preprocessed\u003cSC\u003e(\n        \u0026self,\n        preprocessed: Vec\u003cVal\u003cSC\u003e\u003e,\n    ) -\u003e DynamicAirEntry\u003cSC\u003e\n    where\n        SC: StarkGenericConfig + 'static + Send + Sync,\n        Val\u003cSC\u003e: StarkField,\n    {\n        DynamicAirEntry::new(Box::new(Poseidon2AirWrapper {\n            inner: self.config.to_air_wrapper(),\n            width: self.width_from_config(),\n            preprocessed,\n            _phantom: core::marker::PhantomData::\u003cSC\u003e,\n        }))\n    }\n\n    pub fn width_from_config(\u0026self) -\u003e usize {\n        match \u0026self.config {\n            Poseidon2Config::BabyBearD4Width16 { constants, .. } =\u003e {\n                let air = Poseidon2CircuitAirBabyBearD4Width16::new(constants.clone());\n                air.width()\n            }\n            Poseidon2Config::BabyBearD4Width24 { constants, .. } =\u003e {\n                let air = Poseidon2CircuitAirBabyBearD4Width24::new(constants.clone());\n                air.width()\n            }\n            Poseidon2Config::KoalaBearD4Width16 { constants, .. } =\u003e {\n                Poseidon2CircuitAirKoalaBearD4Width16::new(constants.clone()).width()\n            }\n            Poseidon2Config::KoalaBearD4Width24 { constants, .. } =\u003e {\n                Poseidon2CircuitAirKoalaBearD4Width24::new(constants.clone()).width()\n            }\n        }\n    }\n\n    pub const fn preprocessed_width_from_config(\u0026self) -\u003e usize {\n        match \u0026self.config {\n            Poseidon2Config::BabyBearD4Width16 { .. } =\u003e {\n                Poseidon2CircuitAirBabyBearD4Width16::preprocessed_width()\n            }\n            Poseidon2Config::BabyBearD4Width24 { .. } =\u003e {\n                Poseidon2CircuitAirBabyBearD4Width24::preprocessed_width()\n            }\n            Poseidon2Config::KoalaBearD4Width16 { .. } =\u003e {\n                Poseidon2CircuitAirKoalaBearD4Width16::preprocessed_width()\n            }\n            Poseidon2Config::KoalaBearD4Width24 { .. } =\u003e {\n                Poseidon2CircuitAirKoalaBearD4Width24::preprocessed_width()\n            }\n        }\n    }\n\n    fn batch_instance_from_traces\u003cSC, CF\u003e(\n        \u0026self,\n        _config: \u0026SC,\n        _packing: TablePacking,\n        traces: \u0026Traces\u003cCF\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e\n    where\n        SC: StarkGenericConfig + 'static + Send + Sync,\n        Val\u003cSC\u003e: StarkField,\n        CF: Field + ExtensionField\u003cVal\u003cSC\u003e\u003e,\n    {\n        let t = traces.non_primitive_trace::\u003cPoseidon2Trace\u003cVal\u003cSC\u003e\u003e\u003e(\"poseidon2\")?;\n\n        let rows = t.total_rows();\n        if rows == 0 {\n            return None;\n        }\n\n        // Pad to power of two and generate trace matrix based on configuration\n        match \u0026self.config {\n            Poseidon2Config::BabyBearD4Width16 {\n                permutation,\n                constants,\n            } =\u003e self.batch_instance_base_impl::\u003cSC, p3_baby_bear::BabyBear, _, 16, 4, 13, 2\u003e(\n                t,\n                permutation,\n                constants,\n            ),\n            Poseidon2Config::BabyBearD4Width24 {\n                permutation,\n                constants,\n            } =\u003e self.batch_instance_base_impl::\u003cSC, p3_baby_bear::BabyBear, _, 24, 4, 21, 4\u003e(\n                t,\n                permutation,\n                constants,\n            ),\n            Poseidon2Config::KoalaBearD4Width16 {\n                permutation,\n                constants,\n            } =\u003e self.batch_instance_base_impl::\u003cSC, p3_koala_bear::KoalaBear, _, 16, 4, 20, 2\u003e(\n                t,\n                permutation,\n                constants,\n            ),\n            Poseidon2Config::KoalaBearD4Width24 {\n                permutation,\n                constants,\n            } =\u003e self.batch_instance_base_impl::\u003cSC, p3_koala_bear::KoalaBear, _, 24, 4, 23, 4\u003e(\n                t,\n                permutation,\n                constants,\n            ),\n        }\n    }\n\n    fn batch_instance_base_impl\u003c\n        SC,\n        F,\n        P,\n        const WIDTH: usize,\n        const HALF_FULL_ROUNDS: usize,\n        const PARTIAL_ROUNDS: usize,\n        const RATE_EXT: usize,\n    \u003e(\n        \u0026self,\n        t: \u0026Poseidon2Trace\u003cVal\u003cSC\u003e\u003e,\n        _permutation: \u0026P,\n        _constants: \u0026RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e\n    where\n        SC: StarkGenericConfig + 'static + Send + Sync,\n        F: StarkField + PrimeCharacteristicRing,\n        P: CryptographicPermutation\u003c[F; WIDTH]\u003e + Clone,\n        Val\u003cSC\u003e: StarkField,\n    {\n        let rows = t.total_rows();\n\n        // Pad to power of two\n        let padded_rows = rows.next_power_of_two();\n        let mut padded_ops = t.operations.clone();\n        while padded_ops.len() \u003c padded_rows {\n            padded_ops.push(\n                padded_ops\n                    .last()\n                    .cloned()\n                    .unwrap_or_else(|| Poseidon2CircuitRow {\n                        new_start: true,\n                        merkle_path: false,\n                        mmcs_bit: false,\n                        mmcs_index_sum: Val::\u003cSC\u003e::ZERO,\n                        input_values: vec![Val::\u003cSC\u003e::ZERO; WIDTH],\n                        in_ctl: [false; 4],\n                        input_indices: [0; 4],\n                        out_ctl: [false; 2],\n                        output_indices: [0; 2],\n                        mmcs_index_sum_idx: 0,\n                    }),\n            );\n        }\n\n        // Convert trace from Val\u003cSC\u003e to F using unsafe transmute\n        // This is safe when Val\u003cSC\u003e and F have the same size and layout\n        // For BabyBear/KoalaBear configs, Val\u003cSC\u003e should be BabyBear/KoalaBear\n        let ops_converted: Poseidon2CircuitTrace\u003cF\u003e = unsafe { transmute(padded_ops) };\n\n        // Create an AIR instance based on the configuration\n        // This is a bit verbose but we can't get over const generics\n        let (air, matrix) = match \u0026self.config {\n            Poseidon2Config::BabyBearD4Width16 {\n                permutation,\n                constants,\n            } =\u003e {\n                let preprocessed =\n                    extract_preprocessed_from_operations::\u003cBabyBear, Val\u003cSC\u003e\u003e(\u0026t.operations);\n                let air = Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(\n                    constants.clone(),\n                    preprocessed,\n                );\n                let ops_babybear: Poseidon2CircuitTrace\u003cBabyBear\u003e =\n                    unsafe { transmute(ops_converted) };\n                let matrix_f = air.generate_trace_rows(\u0026ops_babybear, constants, 0, permutation);\n                let matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e = unsafe { transmute(matrix_f) };\n                (\n                    // Preprocessed values are already stored in the AIR, so we don't need to pass them again in the wrapper.\n                    Poseidon2AirWrapper {\n                        inner: self.config.to_air_wrapper(),\n                        width: air.width(),\n                        preprocessed: Vec::new(),\n                        _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                    },\n                    matrix,\n                )\n            }\n            Poseidon2Config::BabyBearD4Width24 {\n                permutation,\n                constants,\n            } =\u003e {\n                let preprocessed =\n                    extract_preprocessed_from_operations::\u003cBabyBear, Val\u003cSC\u003e\u003e(\u0026t.operations);\n                let air = Poseidon2CircuitAirBabyBearD4Width24::new_with_preprocessed(\n                    constants.clone(),\n                    preprocessed,\n                );\n                let ops_babybear: Poseidon2CircuitTrace\u003cBabyBear\u003e =\n                    unsafe { transmute(ops_converted) };\n                let matrix_f = air.generate_trace_rows(\u0026ops_babybear, constants, 0, permutation);\n                let matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e = unsafe { transmute(matrix_f) };\n                (\n                    // Preprocessed values are already stored in the AIR, so we don't need to pass them again in the wrapper.\n                    Poseidon2AirWrapper {\n                        inner: self.config.to_air_wrapper(),\n                        width: air.width(),\n                        preprocessed: Vec::new(),\n                        _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                    },\n                    matrix,\n                )\n            }\n            Poseidon2Config::KoalaBearD4Width16 {\n                permutation,\n                constants,\n            } =\u003e {\n                let preprocessed =\n                    extract_preprocessed_from_operations::\u003cKoalaBear, Val\u003cSC\u003e\u003e(\u0026t.operations);\n                let air = Poseidon2CircuitAirKoalaBearD4Width16::new_with_preprocessed(\n                    constants.clone(),\n                    preprocessed,\n                );\n                let ops_koalabear: Poseidon2CircuitTrace\u003cKoalaBear\u003e =\n                    unsafe { transmute(ops_converted) };\n                let matrix_f = air.generate_trace_rows(\u0026ops_koalabear, constants, 0, permutation);\n                let matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e = unsafe { transmute(matrix_f) };\n                (\n                    // Preprocessed values are already stored in the AIR, so we don't need to pass them again in the wrapper.\n                    Poseidon2AirWrapper {\n                        inner: self.config.to_air_wrapper(),\n                        width: air.width(),\n                        preprocessed: Vec::new(),\n                        _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                    },\n                    matrix,\n                )\n            }\n            Poseidon2Config::KoalaBearD4Width24 {\n                permutation,\n                constants,\n            } =\u003e {\n                let preprocessed =\n                    extract_preprocessed_from_operations::\u003cKoalaBear, Val\u003cSC\u003e\u003e(\u0026t.operations);\n                let air = Poseidon2CircuitAirKoalaBearD4Width24::new_with_preprocessed(\n                    constants.clone(),\n                    preprocessed,\n                );\n                let ops_koalabear: p3_circuit::tables::Poseidon2CircuitTrace\u003cKoalaBear\u003e =\n                    unsafe { core::mem::transmute(ops_converted) };\n                let matrix_f = air.generate_trace_rows(\u0026ops_koalabear, constants, 0, permutation);\n                let matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e = unsafe { core::mem::transmute(matrix_f) };\n                (\n                    // Preprocessed values are already stored in the AIR, so we don't need to pass them again in the wrapper.\n                    Poseidon2AirWrapper {\n                        inner: self.config.to_air_wrapper(),\n                        width: air.width(),\n                        preprocessed: Vec::new(),\n                        _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                    },\n                    matrix,\n                )\n            }\n        };\n\n        Some(BatchTableInstance {\n            id: \"poseidon2\",\n            air: DynamicAirEntry::new(Box::new(air)),\n            trace: matrix,\n            public_values: Vec::new(),\n            rows: padded_rows,\n        })\n    }\n}\n\nimpl\u003cSC\u003e TableProver\u003cSC\u003e for Poseidon2Prover\nwhere\n    SC: StarkGenericConfig + 'static + Send + Sync,\n    Val\u003cSC\u003e: StarkField + BinomiallyExtendable\u003c4\u003e,\n{\n    fn id(\u0026self) -\u003e \u0026'static str {\n        \"poseidon2\"\n    }\n\n    fn batch_instance_d1(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cVal\u003cSC\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        self.batch_instance_from_traces::\u003cSC, Val\u003cSC\u003e\u003e(config, packing, traces)\n    }\n\n    fn batch_instance_d2(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 2\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        // Not supported for Poseidon2 table; extension circuits use D=4.\n        let _ = (config, packing, traces);\n        None\n    }\n\n    fn batch_instance_d4(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 4\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        self.batch_instance_from_traces::\u003cSC, BinomialExtensionField\u003cVal\u003cSC\u003e, 4\u003e\u003e(\n            config, packing, traces,\n        )\n    }\n\n    fn batch_instance_d6(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 6\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        // Not supported for Poseidon2 table; extension circuits use D=4.\n        let _ = (config, packing, traces);\n        None\n    }\n\n    fn batch_instance_d8(\n        \u0026self,\n        config: \u0026SC,\n        packing: TablePacking,\n        traces: \u0026Traces\u003cBinomialExtensionField\u003cVal\u003cSC\u003e, 8\u003e\u003e,\n    ) -\u003e Option\u003cBatchTableInstance\u003cSC\u003e\u003e {\n        // Not supported for Poseidon2 table; extension circuits use D=4.\n        let _ = (config, packing, traces);\n        None\n    }\n\n    fn batch_air_from_table_entry(\n        \u0026self,\n        _config: \u0026SC,\n        _degree: usize,\n        _table_entry: \u0026NonPrimitiveTableEntry\u003cSC\u003e,\n    ) -\u003e Result\u003cDynamicAirEntry\u003cSC\u003e, String\u003e {\n        // Recreate the AIR wrapper from the configuration\n        match \u0026self.config {\n            Poseidon2Config::BabyBearD4Width16 { .. } =\u003e {\n                let inner = self.config.to_air_wrapper();\n                let width = inner.width();\n                let wrapper = Poseidon2AirWrapper {\n                    inner,\n                    width,\n                    preprocessed: Vec::new(),\n                    _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                };\n                Ok(DynamicAirEntry::new(Box::new(wrapper)))\n            }\n            Poseidon2Config::BabyBearD4Width24 { .. } =\u003e {\n                let inner = self.config.to_air_wrapper();\n                let width = inner.width();\n                let wrapper = Poseidon2AirWrapper {\n                    inner,\n                    width,\n                    preprocessed: Vec::new(),\n                    _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                };\n                Ok(DynamicAirEntry::new(Box::new(wrapper)))\n            }\n            Poseidon2Config::KoalaBearD4Width16 { .. } =\u003e {\n                let inner = self.config.to_air_wrapper();\n                let width = inner.width();\n                let wrapper = Poseidon2AirWrapper {\n                    inner,\n                    width,\n                    preprocessed: Vec::new(),\n                    _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                };\n                Ok(DynamicAirEntry::new(Box::new(wrapper)))\n            }\n            Poseidon2Config::KoalaBearD4Width24 { .. } =\u003e {\n                let inner = self.config.to_air_wrapper();\n                let width = inner.width();\n                let wrapper = Poseidon2AirWrapper {\n                    inner,\n                    width,\n                    preprocessed: Vec::new(),\n                    _phantom: core::marker::PhantomData::\u003cSC\u003e,\n                };\n                Ok(DynamicAirEntry::new(Box::new(wrapper)))\n            }\n        }\n    }\n}\n\npub type PrimitiveTable = PrimitiveOpType;\n\n/// Number of primitive circuit tables included in the unified batch STARK proof.\npub const NUM_PRIMITIVE_TABLES: usize = PrimitiveTable::Mul as usize + 1;\n\n/// Row counts wrapper with type-safe indexing.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct RowCounts([usize; NUM_PRIMITIVE_TABLES]);\n\nimpl RowCounts {\n    /// Creates a new RowCounts with the given row counts for each table.\n    pub const fn new(rows: [usize; NUM_PRIMITIVE_TABLES]) -\u003e Self {\n        // Validate that all row counts are non-zero\n        let mut i = 0;\n        while i \u003c rows.len() {\n            assert!(rows[i] \u003e 0);\n            i += 1;\n        }\n        Self(rows)\n    }\n\n    /// Gets the row count for a specific table.\n    #[inline]\n    pub const fn get(\u0026self, t: PrimitiveTable) -\u003e usize {\n        self.0[t as usize]\n    }\n}\n\nimpl core::ops::Index\u003cPrimitiveTable\u003e for RowCounts {\n    type Output = usize;\n    fn index(\u0026self, table: PrimitiveTable) -\u003e \u0026Self::Output {\n        \u0026self.0[table as usize]\n    }\n}\n\nimpl From\u003c[usize; NUM_PRIMITIVE_TABLES]\u003e for RowCounts {\n    fn from(rows: [usize; NUM_PRIMITIVE_TABLES]) -\u003e Self {\n        Self(rows)\n    }\n}\n\n/// Proof bundle and metadata for the unified batch STARK proof across all circuit tables.\npub struct BatchStarkProof\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    /// The core cryptographic proof generated by `p3-batch-stark`.\n    pub proof: BatchProof\u003cSC\u003e,\n    /// Packing configuration used for the Witness, Add, and Mul tables.\n    pub table_packing: TablePacking,\n    /// The number of rows in each of the circuit tables.\n    pub rows: RowCounts,\n    /// The degree of the field extension (`D`) used for the proof.\n    pub ext_degree: usize,\n    /// The binomial coefficient `W` for extension field multiplication, if `ext_degree \u003e 1`.\n    pub w_binomial: Option\u003cVal\u003cSC\u003e\u003e,\n    /// Manifest describing batched non-primitive tables defined at runtime.\n    pub non_primitives: Vec\u003cNonPrimitiveTableEntry\u003cSC\u003e\u003e,\n}\n\nimpl\u003cSC\u003e core::fmt::Debug for BatchStarkProof\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n        f.debug_struct(\"BatchStarkProof\")\n            .field(\"table_packing\", \u0026self.table_packing)\n            .field(\"rows\", \u0026self.rows)\n            .field(\"ext_degree\", \u0026self.ext_degree)\n            .field(\"w_binomial\", \u0026self.w_binomial)\n            .finish()\n    }\n}\n\n/// Produces a single batch STARK proof covering all circuit tables.\npub struct BatchStarkProver\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + 'static,\n{\n    config: SC,\n    table_packing: TablePacking,\n    /// Registered dynamic non-primitive table provers.\n    non_primitive_provers: Vec\u003cBox\u003cdyn TableProver\u003cSC\u003e\u003e\u003e,\n}\n\n/// Errors for the batch STARK table prover.\n#[derive(Debug, Error)]\npub enum BatchStarkProverError {\n    #[error(\"unsupported extension degree: {0} (supported: 1,2,4,6,8)\")]\n    UnsupportedDegree(usize),\n\n    #[error(\"missing binomial parameter W for extension-field multiplication\")]\n    MissingWForExtension,\n\n    #[error(\"verification failed: {0}\")]\n    Verify(String),\n\n    #[error(\"missing table prover for non-primitive table `{0}`\")]\n    MissingTableProver(\u0026'static str),\n}\n\nimpl\u003cSC, const D: usize\u003e BaseAir\u003cVal\u003cSC\u003e\u003e for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::Witness(a) =\u003e a.width(),\n            Self::Const(a) =\u003e a.width(),\n            Self::Public(a) =\u003e a.width(),\n            Self::Add(a) =\u003e a.width(),\n            Self::Mul(a) =\u003e a.width(),\n            Self::Dynamic(a) =\u003e \u003cdyn BatchAir\u003cSC\u003e as BaseAir\u003cVal\u003cSC\u003e\u003e\u003e::width(a.air()),\n        }\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e {\n        match self {\n            Self::Witness(a) =\u003e a.preprocessed_trace(),\n            Self::Const(a) =\u003e a.preprocessed_trace(),\n            Self::Public(a) =\u003e a.preprocessed_trace(),\n            Self::Add(a) =\u003e a.preprocessed_trace(),\n            Self::Mul(a) =\u003e a.preprocessed_trace(),\n            Self::Dynamic(a) =\u003e \u003cdyn BatchAir\u003cSC\u003e as BaseAir\u003cVal\u003cSC\u003e\u003e\u003e::preprocessed_trace(a.air()),\n        }\n    }\n}\n\nimpl\u003cSC, const D: usize\u003e Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut SymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e) {\n        match self {\n            Self::Witness(a) =\u003e Air::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::eval(a, builder),\n            Self::Const(a) =\u003e Air::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::eval(a, builder),\n            Self::Public(a) =\u003e Air::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::eval(a, builder),\n            Self::Add(a) =\u003e Air::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::eval(a, builder),\n            Self::Mul(a) =\u003e Air::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::eval(a, builder),\n            Self::Dynamic(a) =\u003e {\n                \u003cdyn BatchAir\u003cSC\u003e as Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e\u003e::eval(a.air(), builder);\n            }\n        }\n    }\n}\n\nimpl\u003c'a, SC, const D: usize\u003e Air\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut ProverConstraintFolder\u003c'a, SC\u003e) {\n        match self {\n            Self::Witness(a) =\u003e Air::\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Const(a) =\u003e Air::\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Public(a) =\u003e Air::\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Add(a) =\u003e Air::\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Mul(a) =\u003e Air::\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Dynamic(a) =\u003e {\n                \u003cdyn BatchAir\u003cSC\u003e as Air\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e\u003e::eval(a.air(), builder);\n            }\n        }\n    }\n}\n\nimpl\u003c'a, SC, const D: usize\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField,\n{\n    fn eval(\u0026self, builder: \u0026mut VerifierConstraintFolder\u003c'a, SC\u003e) {\n        match self {\n            Self::Witness(a) =\u003e Air::\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Const(a) =\u003e Air::\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Public(a) =\u003e Air::\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Add(a) =\u003e Air::\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Mul(a) =\u003e Air::\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e::eval(a, builder),\n            Self::Dynamic(a) =\u003e {\n                \u003cdyn BatchAir\u003cSC\u003e as Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e\u003e::eval(a.air(), builder);\n            }\n        }\n    }\n}\n\nimpl\u003cSC, const D: usize\u003e AirLookupHandler\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e for CircuitTableAir\u003cSC, D\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: PrimeField,\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        match self {\n            Self::Witness(a) =\u003e {\n                AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::add_lookup_columns(a)\n            }\n            Self::Const(a) =\u003e {\n                AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::add_lookup_columns(a)\n            }\n            Self::Public(a) =\u003e {\n                AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::add_lookup_columns(a)\n            }\n            Self::Add(a) =\u003e AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::add_lookup_columns(a),\n            Self::Mul(a) =\u003e AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::add_lookup_columns(a),\n            Self::Dynamic(a) =\u003e {\n                AirLookupHandlerDyn::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::add_lookup_columns_dyn(\n                    a.air_mut(),\n                )\n            }\n        }\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003cVal\u003cSC\u003e\u003e\u003e {\n        match self {\n            Self::Witness(a) =\u003e AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::get_lookups(a),\n            Self::Const(a) =\u003e AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::get_lookups(a),\n            Self::Public(a) =\u003e AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::get_lookups(a),\n            Self::Add(a) =\u003e AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::get_lookups(a),\n            Self::Mul(a) =\u003e AirLookupHandler::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::get_lookups(a),\n            Self::Dynamic(a) =\u003e {\n                AirLookupHandlerDyn::\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e::get_lookups_dyn(a.air_mut())\n            }\n        }\n    }\n}\n\nimpl\u003cSC\u003e BatchStarkProver\u003cSC\u003e\nwhere\n    SC: StarkGenericConfig + 'static,\n    Val\u003cSC\u003e: StarkField,\n{\n    pub fn new(config: SC) -\u003e Self {\n        Self {\n            config,\n            table_packing: TablePacking::default(),\n            non_primitive_provers: Vec::new(),\n        }\n    }\n\n    #[must_use]\n    pub const fn with_table_packing(mut self, table_packing: TablePacking) -\u003e Self {\n        self.table_packing = table_packing;\n        self\n    }\n\n    /// Register a dynamic non-primitive table prover.\n    pub fn register_table_prover(\u0026mut self, prover: Box\u003cdyn TableProver\u003cSC\u003e\u003e) {\n        self.non_primitive_provers.push(prover);\n    }\n\n    /// Builder-style registration for a dynamic non-primitive table prover.\n    #[must_use]\n    pub fn with_table_prover(mut self, prover: Box\u003cdyn TableProver\u003cSC\u003e\u003e) -\u003e Self {\n        self.register_table_prover(prover);\n        self\n    }\n\n    /// Register the non-primitive Poseidon2 prover plugin with the given configuration.\n    pub fn register_poseidon2_table(\u0026mut self, config: Poseidon2Config)\n    where\n        SC: Send + Sync,\n        Val\u003cSC\u003e: BinomiallyExtendable\u003c4\u003e,\n    {\n        self.register_table_prover(Box::new(Poseidon2Prover::new(config)));\n    }\n\n    #[inline]\n    pub const fn table_packing(\u0026self) -\u003e TablePacking {\n        self.table_packing\n    }\n\n    /// Generate a unified batch STARK proof for all circuit tables.\n    #[instrument(skip_all)]\n    pub fn prove_all_tables\u003cEF\u003e(\n        \u0026self,\n        traces: \u0026Traces\u003cEF\u003e,\n        common: \u0026CommonData\u003cSC\u003e,\n    ) -\u003e Result\u003cBatchStarkProof\u003cSC\u003e, BatchStarkProverError\u003e\n    where\n        EF: Field + BasedVectorSpace\u003cVal\u003cSC\u003e\u003e + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    {\n        let w_opt = EF::extract_w();\n        match EF::DIMENSION {\n            1 =\u003e self.prove::\u003cEF, 1\u003e(traces, None, common),\n            2 =\u003e self.prove::\u003cEF, 2\u003e(traces, w_opt, common),\n            4 =\u003e self.prove::\u003cEF, 4\u003e(traces, w_opt, common),\n            6 =\u003e self.prove::\u003cEF, 6\u003e(traces, w_opt, common),\n            8 =\u003e self.prove::\u003cEF, 8\u003e(traces, w_opt, common),\n            d =\u003e Err(BatchStarkProverError::UnsupportedDegree(d)),\n        }\n    }\n\n    /// Verify the unified batch STARK proof against all tables.\n    pub fn verify_all_tables(\n        \u0026self,\n        proof: \u0026BatchStarkProof\u003cSC\u003e,\n        common: \u0026CommonData\u003cSC\u003e,\n    ) -\u003e Result\u003c(), BatchStarkProverError\u003e {\n        match proof.ext_degree {\n            1 =\u003e self.verify::\u003c1\u003e(proof, None, common),\n            2 =\u003e self.verify::\u003c2\u003e(proof, proof.w_binomial, common),\n            4 =\u003e self.verify::\u003c4\u003e(proof, proof.w_binomial, common),\n            6 =\u003e self.verify::\u003c6\u003e(proof, proof.w_binomial, common),\n            8 =\u003e self.verify::\u003c8\u003e(proof, proof.w_binomial, common),\n            d =\u003e Err(BatchStarkProverError::UnsupportedDegree(d)),\n        }\n    }\n\n    /// Generate a batch STARK proof for a specific extension field degree.\n    ///\n    /// This is the core proving logic that handles all circuit tables for a given\n    /// extension field dimension. It constructs AIRs, converts traces to matrices,\n    /// and generates the unified proof.\n    fn prove\u003cEF, const D: usize\u003e(\n        \u0026self,\n        traces: \u0026Traces\u003cEF\u003e,\n        w_binomial: Option\u003cVal\u003cSC\u003e\u003e,\n        common: \u0026CommonData\u003cSC\u003e,\n    ) -\u003e Result\u003cBatchStarkProof\u003cSC\u003e, BatchStarkProverError\u003e\n    where\n        EF: Field + BasedVectorSpace\u003cVal\u003cSC\u003e\u003e,\n    {\n        // TODO: Consider parallelizing AIR construction and trace-to-matrix conversions.\n        // Build matrices and AIRs per table.\n        let packing = self.table_packing;\n        let witness_lanes = packing.witness_lanes();\n        let add_lanes = packing.add_lanes();\n        let mul_lanes = packing.mul_lanes();\n\n        // Witness\n        let witness_rows = traces.witness_trace.values.len();\n        let witness_air = WitnessAir::\u003cVal\u003cSC\u003e, D\u003e::new(witness_rows, witness_lanes);\n        let witness_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            WitnessAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.witness_trace, witness_lanes);\n\n        // Const\n        let const_rows = traces.const_trace.values.len();\n        let const_prep = ConstAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_preprocessed(\u0026traces.const_trace);\n        let const_air = ConstAir::\u003cVal\u003cSC\u003e, D\u003e::new_with_preprocessed(const_rows, const_prep);\n        let const_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            ConstAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.const_trace);\n\n        // Public\n        let public_rows = traces.public_trace.values.len();\n        let public_prep = PublicAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_preprocessed(\u0026traces.public_trace);\n        let public_air = PublicAir::\u003cVal\u003cSC\u003e, D\u003e::new_with_preprocessed(public_rows, public_prep);\n        let public_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            PublicAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.public_trace);\n\n        // Add\n        let add_rows = traces.add_trace.lhs_values.len();\n        let add_prep = AddAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_preprocessed(\u0026traces.add_trace, add_lanes);\n        let add_air = AddAir::\u003cVal\u003cSC\u003e, D\u003e::new_with_preprocessed(add_rows, add_lanes, add_prep);\n        let add_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            AddAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.add_trace, add_lanes);\n\n        // Mul\n        let mul_rows = traces.mul_trace.lhs_values.len();\n        let mul_prep = MulAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_preprocessed(\u0026traces.mul_trace, mul_lanes);\n        let mul_air: MulAir\u003cVal\u003cSC\u003e, D\u003e = if D == 1 {\n            MulAir::\u003cVal\u003cSC\u003e, D\u003e::new_with_preprocessed(mul_rows, mul_lanes, mul_prep)\n        } else {\n            let w = w_binomial.ok_or(BatchStarkProverError::MissingWForExtension)?;\n            MulAir::\u003cVal\u003cSC\u003e, D\u003e::new_binomial_with_preprocessed(mul_rows, mul_lanes, w, mul_prep)\n        };\n        let mul_matrix: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e =\n            MulAir::\u003cVal\u003cSC\u003e, D\u003e::trace_to_matrix(\u0026traces.mul_trace, mul_lanes);\n\n        // We first handle all non-primitive tables dynamically, which will then be batched alongside primitive ones.\n        // Each trace must have a corresponding registered prover for it to be provable.\n        for (\u0026id, trace) in \u0026traces.non_primitive_traces {\n            if trace.rows() == 0 {\n                continue;\n            }\n            if !self.non_primitive_provers.iter().any(|p| p.id() == id) {\n                return Err(BatchStarkProverError::MissingTableProver(id));\n            }\n        }\n\n        let mut dynamic_instances: Vec\u003cBatchTableInstance\u003cSC\u003e\u003e = Vec::new();\n        if D == 1 {\n            let t: \u0026Traces\u003cVal\u003cSC\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d1(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        } else if D == 2 {\n            type EF2\u003cF\u003e = BinomialExtensionField\u003cF, 2\u003e;\n            let t: \u0026Traces\u003cEF2\u003cVal\u003cSC\u003e\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d2(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        } else if D == 4 {\n            type EF4\u003cF\u003e = BinomialExtensionField\u003cF, 4\u003e;\n            let t: \u0026Traces\u003cEF4\u003cVal\u003cSC\u003e\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d4(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        } else if D == 6 {\n            type EF6\u003cF\u003e = BinomialExtensionField\u003cF, 6\u003e;\n            let t: \u0026Traces\u003cEF6\u003cVal\u003cSC\u003e\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d6(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        } else if D == 8 {\n            type EF8\u003cF\u003e = BinomialExtensionField\u003cF, 8\u003e;\n            let t: \u0026Traces\u003cEF8\u003cVal\u003cSC\u003e\u003e\u003e = unsafe { transmute_traces(traces) };\n            for p in \u0026self.non_primitive_provers {\n                if let Some(instance) = p.batch_instance_d8(\u0026self.config, packing, t) {\n                    dynamic_instances.push(instance);\n                }\n            }\n        }\n\n        // Wrap AIRs in enum for heterogeneous batching and build instances in fixed order.\n        // TODO: Support public values for tables\n        let mut air_storage: Vec\u003cCircuitTableAir\u003cSC, D\u003e\u003e =\n            Vec::with_capacity(NUM_PRIMITIVE_TABLES + dynamic_instances.len());\n        let mut trace_storage: Vec\u003cRowMajorMatrix\u003cVal\u003cSC\u003e\u003e\u003e =\n            Vec::with_capacity(NUM_PRIMITIVE_TABLES + dynamic_instances.len());\n        let mut public_storage: Vec\u003cVec\u003cVal\u003cSC\u003e\u003e\u003e =\n            Vec::with_capacity(NUM_PRIMITIVE_TABLES + dynamic_instances.len());\n        let mut non_primitives: Vec\u003cNonPrimitiveTableEntry\u003cSC\u003e\u003e =\n            Vec::with_capacity(dynamic_instances.len());\n\n        air_storage.push(CircuitTableAir::Witness(witness_air));\n        trace_storage.push(witness_matrix);\n        public_storage.push(Vec::new());\n\n        air_storage.push(CircuitTableAir::Const(const_air));\n        trace_storage.push(const_matrix);\n        public_storage.push(Vec::new());\n\n        air_storage.push(CircuitTableAir::Public(public_air));\n        trace_storage.push(public_matrix);\n        public_storage.push(Vec::new());\n\n        air_storage.push(CircuitTableAir::Add(add_air));\n        trace_storage.push(add_matrix);\n        public_storage.push(Vec::new());\n\n        air_storage.push(CircuitTableAir::Mul(mul_air));\n        trace_storage.push(mul_matrix);\n        public_storage.push(Vec::new());\n\n        for instance in dynamic_instances {\n            let BatchTableInstance {\n                id,\n                air,\n                trace,\n                public_values,\n                rows,\n            } = instance;\n            air_storage.push(CircuitTableAir::Dynamic(air));\n            trace_storage.push(trace);\n            public_storage.push(public_values.clone());\n            non_primitives.push(NonPrimitiveTableEntry {\n                id,\n                rows,\n                public_values,\n            });\n        }\n\n        let instances: Vec\u003cStarkInstance\u003c'_, SC, CircuitTableAir\u003cSC, D\u003e\u003e\u003e = air_storage\n            .iter()\n            .zip(trace_storage)\n            .zip(public_storage)\n            .map(|((air, trace), public_values)| StarkInstance {\n                air,\n                trace,\n                public_values,\n            })\n            .collect();\n\n        let proof = p3_batch_stark::prove_batch(\u0026self.config, instances, common);\n\n        // Ensure all primitive table row counts are at least 1\n        // RowCounts::new requires non-zero counts, so pad zeros to 1\n        let witness_rows_padded = witness_rows.max(1);\n        let const_rows_padded = const_rows.max(1);\n        let public_rows_padded = public_rows.max(1);\n        let add_rows_padded = add_rows.max(1);\n        let mul_rows_padded = mul_rows.max(1);\n\n        Ok(BatchStarkProof {\n            proof,\n            table_packing: packing,\n            rows: RowCounts::new([\n                witness_rows_padded,\n                const_rows_padded,\n                public_rows_padded,\n                add_rows_padded,\n                mul_rows_padded,\n            ]),\n            ext_degree: D,\n            w_binomial: if D \u003e 1 { w_binomial } else { None },\n            non_primitives,\n        })\n    }\n\n    /// Verify a batch STARK proof for a specific extension field degree.\n    ///\n    /// This reconstructs the AIRs from the proof metadata and verifies the proof\n    /// against all circuit tables. The AIRs are reconstructed using the same\n    /// configuration that was used during proof generation.\n    fn verify\u003cconst D: usize\u003e(\n        \u0026self,\n        proof: \u0026BatchStarkProof\u003cSC\u003e,\n        w_binomial: Option\u003cVal\u003cSC\u003e\u003e,\n        common: \u0026CommonData\u003cSC\u003e,\n    ) -\u003e Result\u003c(), BatchStarkProverError\u003e {\n        // Rebuild AIRs in the same order as prove.\n        let packing = proof.table_packing;\n        let witness_lanes = packing.witness_lanes();\n        let add_lanes = packing.add_lanes();\n        let mul_lanes = packing.mul_lanes();\n\n        let witness_air = CircuitTableAir::Witness(WitnessAir::\u003cVal\u003cSC\u003e, D\u003e::new(\n            proof.rows[PrimitiveTable::Witness],\n            witness_lanes,\n        ));\n        let const_air = CircuitTableAir::Const(ConstAir::\u003cVal\u003cSC\u003e, D\u003e::new(\n            proof.rows[PrimitiveTable::Const],\n        ));\n        let public_air = CircuitTableAir::Public(PublicAir::\u003cVal\u003cSC\u003e, D\u003e::new(\n            proof.rows[PrimitiveTable::Public],\n        ));\n        let add_air = CircuitTableAir::Add(AddAir::\u003cVal\u003cSC\u003e, D\u003e::new(\n            proof.rows[PrimitiveTable::Add],\n            add_lanes,\n        ));\n        let mul_air: CircuitTableAir\u003cSC, D\u003e = if D == 1 {\n            CircuitTableAir::Mul(MulAir::\u003cVal\u003cSC\u003e, D\u003e::new(\n                proof.rows[PrimitiveTable::Mul],\n                mul_lanes,\n            ))\n        } else {\n            let w = w_binomial.ok_or(BatchStarkProverError::MissingWForExtension)?;\n            CircuitTableAir::Mul(MulAir::\u003cVal\u003cSC\u003e, D\u003e::new_binomial(\n                proof.rows[PrimitiveTable::Mul],\n                mul_lanes,\n                w,\n            ))\n        };\n        let mut airs = vec![witness_air, const_air, public_air, add_air, mul_air];\n        // TODO: Handle public values.\n        let mut pvs: Vec\u003cVec\u003cVal\u003cSC\u003e\u003e\u003e = vec![Vec::new(); NUM_PRIMITIVE_TABLES];\n\n        for entry in \u0026proof.non_primitives {\n            let plugin = self\n                .non_primitive_provers\n                .iter()\n                .find(|p| {\n                    let tp = p.as_ref();\n                    TableProver::id(tp) == entry.id\n                })\n                .ok_or_else(|| {\n                    BatchStarkProverError::Verify(format!(\n                        \"unknown non-primitive plugin: {}\",\n                        entry.id\n                    ))\n                })?;\n            let air = plugin\n                .batch_air_from_table_entry(\u0026self.config, D, entry)\n                .map_err(BatchStarkProverError::Verify)?;\n            airs.push(CircuitTableAir::Dynamic(air));\n            pvs.push(entry.public_values.clone());\n        }\n\n        p3_batch_stark::verify_batch(\u0026self.config, \u0026airs, \u0026proof.proof, \u0026pvs, common)\n            .map_err(|e| BatchStarkProverError::Verify(format!(\"{e:?}\")))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n    use p3_circuit::builder::CircuitBuilder;\n    use p3_field::PrimeCharacteristicRing;\n    use p3_goldilocks::Goldilocks;\n    use p3_koala_bear::KoalaBear;\n\n    use super::*;\n    use crate::common::get_airs_and_degrees_with_prep;\n    use crate::config;\n\n    #[test]\n    fn test_babybear_batch_stark_base_field() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let cfg = config::baby_bear().build();\n\n        // x + 5*2 - 3 + (-1) == expected\n        let x = builder.add_public_input();\n        let expected = builder.add_public_input();\n        let c5 = builder.add_const(BabyBear::from_u64(5));\n        let c2 = builder.add_const(BabyBear::from_u64(2));\n        let c3 = builder.add_const(BabyBear::from_u64(3));\n        let neg_one = builder.add_const(BabyBear::NEG_ONE);\n\n        let mul_result = builder.mul(c5, c2); // 10\n        let add_result = builder.add(x, mul_result); // x + 10\n        let sub_result = builder.sub(add_result, c3); // x + 7\n        let final_result = builder.add(sub_result, neg_one); // x + 6\n\n        let diff = builder.sub(final_result, expected);\n        builder.assert_zero(diff);\n\n        let circuit = builder.build().unwrap();\n        let airs_degrees =\n            get_airs_and_degrees_with_prep::\u003c_, _, 1\u003e(\u0026circuit, TablePacking::default(), None)\n                .unwrap();\n        let (airs, log_degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n        let mut runner = circuit.runner();\n\n        let x_val = BabyBear::from_u64(7);\n        let expected_val = BabyBear::from_u64(13); // 7 + 10 - 3 - 1 = 13\n        runner.set_public_inputs(\u0026[x_val, expected_val]).unwrap();\n        let traces = runner.run().unwrap();\n        let common = CommonData::from_airs_and_degrees(\u0026cfg, \u0026airs, \u0026log_degrees);\n\n        let prover = BatchStarkProver::new(cfg);\n\n        let proof = prover.prove_all_tables(\u0026traces, \u0026common).unwrap();\n        assert_eq!(proof.ext_degree, 1);\n        assert!(proof.w_binomial.is_none());\n\n        assert!(prover.verify_all_tables(\u0026proof, \u0026common).is_ok());\n    }\n\n    #[test]\n    fn test_table_lookups() {\n        let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let cfg = config::baby_bear().build();\n\n        // x + 5*2 - 3 + (-1) == expected\n        let x = builder.add_public_input();\n        let expected = builder.add_public_input();\n        let c5 = builder.add_const(BabyBear::from_u64(5));\n        let c2 = builder.add_const(BabyBear::from_u64(2));\n        let c3 = builder.add_const(BabyBear::from_u64(3));\n        let neg_one = builder.add_const(BabyBear::NEG_ONE);\n\n        let mul_result = builder.mul(c5, c2); // 10\n        let add_result = builder.add(x, mul_result); // x + 10\n        let sub_result = builder.sub(add_result, c3); // x + 7\n        let final_result = builder.add(sub_result, neg_one); // x + 6\n\n        let diff = builder.sub(final_result, expected);\n        builder.assert_zero(diff);\n\n        let circuit = builder.build().unwrap();\n        let default_packing = TablePacking::default();\n        let airs_degrees =\n            get_airs_and_degrees_with_prep::\u003c_, _, 1\u003e(\u0026circuit, default_packing, None).unwrap();\n        let (mut airs, log_degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n        // Check that the multiplicities of `WitnessAir` are computed correctly.\n        // We can count the number of times the witness addresses appear in the various tables. We get:\n        let mut expected_multiplicities = vec![BabyBear::from_u64(2); 11];\n        // Pad multiplicities.\n        let total_witness_length = (expected_multiplicities\n            .len()\n            .div_ceil(default_packing.witness_lanes()))\n        .next_power_of_two()\n            * default_packing.witness_lanes();\n        expected_multiplicities.resize(total_witness_length, BabyBear::ZERO);\n\n        // Get expected preprocessed trace for `WitnessAir`.\n        let expected_preprocessed_trace = RowMajorMatrix::new(\n            expected_multiplicities\n                .iter()\n                .enumerate()\n                .flat_map(|(i, m)| vec![*m, BabyBear::from_usize(i)])\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            2 * TablePacking::default().witness_lanes(),\n        );\n        assert_eq!(\n            airs[0]\n                .preprocessed_trace()\n                .expect(\"Witness table should have preprocessed trace\"),\n            expected_preprocessed_trace,\n            \"witness_multiplicities {:?} expected {:?}\",\n            airs[0].preprocessed_trace(),\n            expected_preprocessed_trace,\n        );\n\n        let mut runner = circuit.runner();\n\n        let x_val = BabyBear::from_u64(7);\n        let expected_val = BabyBear::from_u64(13); // 7 + 10 - 3 - 1 = 13\n        runner.set_public_inputs(\u0026[x_val, expected_val]).unwrap();\n        let traces = runner.run().unwrap();\n        let common = CommonData::from_airs_and_degrees(\u0026cfg, \u0026airs, \u0026log_degrees);\n\n        let prover = BatchStarkProver::new(cfg);\n\n        let proof = prover.prove_all_tables(\u0026traces, \u0026common).unwrap();\n        assert_eq!(proof.ext_degree, 1);\n        assert!(proof.w_binomial.is_none());\n\n        assert!(prover.verify_all_tables(\u0026proof, \u0026common).is_ok());\n\n        // Check that the generated lookups are correct and consistent across tables.\n        for air in airs.iter_mut() {\n            let lookups = air.get_lookups();\n\n            match air {\n                CircuitTableAir::Witness(_) =\u003e {\n                    assert_eq!(\n                        lookups.len(),\n                        default_packing.witness_lanes(),\n                        \"Witness table should have {} lookups, found {}\",\n                        default_packing.witness_lanes(),\n                        lookups.len()\n                    );\n                }\n                CircuitTableAir::Const(_) =\u003e {\n                    assert_eq!(lookups.len(), 1, \"Const table should have one lookup\");\n                }\n                CircuitTableAir::Public(_) =\u003e {\n                    assert_eq!(lookups.len(), 1, \"Public table should have one lookup\");\n                }\n                CircuitTableAir::Add(_) =\u003e {\n                    let expected_num_lookups = default_packing.add_lanes()\n                        * AddAir::\u003cBabyBear, 1\u003e::lane_width().div_ceil(2);\n                    assert_eq!(\n                        lookups.len(),\n                        expected_num_lookups,\n                        \"Add table should have {} lookups, found {}\",\n                        expected_num_lookups,\n                        lookups.len()\n                    );\n                }\n                CircuitTableAir::Mul(_) =\u003e {\n                    let expected_num_lookups = default_packing.mul_lanes()\n                        * MulAir::\u003cBabyBear, 1\u003e::lane_width().div_ceil(2);\n                    assert_eq!(\n                        lookups.len(),\n                        expected_num_lookups,\n                        \"Mul table should have {} lookups, found {}\",\n                        expected_num_lookups,\n                        lookups.len()\n                    );\n                }\n                CircuitTableAir::Dynamic(_dynamic_air) =\u003e {\n                    assert!(\n                        lookups.is_empty(),\n                        \"There is no dynamic table in this test, so no lookups expected\"\n                    );\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_extension_field_batch_stark() {\n        const D: usize = 4;\n        type Ext4 = BinomialExtensionField\u003cBabyBear, D\u003e;\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n        let x = builder.add_public_input();\n        let y = builder.add_public_input();\n        let z = builder.add_public_input();\n        let expected = builder.add_public_input();\n        let xy = builder.mul(x, y);\n        let res = builder.add(xy, z);\n        let diff = builder.sub(res, expected);\n        builder.assert_zero(diff);\n        let circuit = builder.build().unwrap();\n        let airs_degrees =\n            get_airs_and_degrees_with_prep::\u003c_, _, D\u003e(\u0026circuit, TablePacking::default(), None)\n                .unwrap();\n        let (airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n        let mut runner = circuit.runner();\n        let xv = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(2),\n            BabyBear::from_u64(3),\n            BabyBear::from_u64(5),\n            BabyBear::from_u64(7),\n        ])\n        .unwrap();\n        let yv = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(11),\n            BabyBear::from_u64(13),\n            BabyBear::from_u64(17),\n            BabyBear::from_u64(19),\n        ])\n        .unwrap();\n        let zv = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(23),\n            BabyBear::from_u64(29),\n            BabyBear::from_u64(31),\n            BabyBear::from_u64(37),\n        ])\n        .unwrap();\n        let expected_v = xv * yv + zv;\n        runner.set_public_inputs(\u0026[xv, yv, zv, expected_v]).unwrap();\n        let traces = runner.run().unwrap();\n\n        let cfg = config::baby_bear().build();\n        let common = CommonData::from_airs_and_degrees(\u0026cfg, \u0026airs, \u0026degrees);\n        let prover = BatchStarkProver::new(cfg);\n        let proof = prover.prove_all_tables(\u0026traces, \u0026common).unwrap();\n        assert_eq!(proof.ext_degree, 4);\n        // Ensure W was captured\n        let expected_w = \u003cExt4 as ExtractBinomialW\u003cBabyBear\u003e\u003e::extract_w().unwrap();\n        assert_eq!(proof.w_binomial, Some(expected_w));\n        prover.verify_all_tables(\u0026proof, \u0026common).unwrap();\n    }\n\n    #[test]\n    fn test_extension_field_table_lookups() {\n        const D: usize = 4;\n        type Ext4 = BinomialExtensionField\u003cBabyBear, D\u003e;\n        let mut builder = CircuitBuilder::\u003cExt4\u003e::new();\n\n        let x = builder.add_public_input();\n        let y = builder.add_public_input();\n        let z = builder.add_public_input();\n        let expected = builder.add_public_input();\n        let xy = builder.mul(x, y);\n        let res = builder.add(xy, z);\n        let diff = builder.sub(res, expected);\n        builder.assert_zero(diff);\n\n        let circuit = builder.build().unwrap();\n        let default_packing = TablePacking::default();\n        let airs_degrees =\n            get_airs_and_degrees_with_prep::\u003c_, _, 1\u003e(\u0026circuit, default_packing, None).unwrap();\n        let (mut airs, log_degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n\n        // Check that the multiplicities of `WitnessAir` are computed correctly.\n        // We can count the number of times the witness addresses appear in the various tables. We get:\n        let mut expected_multiplicities = vec![BabyBear::from_u64(2); 7];\n        // Pad multiplicities.\n        let total_witness_length = (expected_multiplicities\n            .len()\n            .div_ceil(default_packing.witness_lanes()))\n        .next_power_of_two()\n            * default_packing.witness_lanes();\n        expected_multiplicities.resize(total_witness_length, BabyBear::ZERO);\n\n        // Get expected preprocessed trace for `WitnessAir`.\n        let expected_preprocessed_trace = RowMajorMatrix::new(\n            expected_multiplicities\n                .iter()\n                .enumerate()\n                .flat_map(|(i, m)| vec![*m, BabyBear::from_usize(i)])\n                .collect::\u003cVec\u003c_\u003e\u003e(),\n            2 * TablePacking::default().witness_lanes(),\n        );\n        assert_eq!(\n            airs[0]\n                .preprocessed_trace()\n                .expect(\"Witness table should have preprocessed trace\"),\n            expected_preprocessed_trace,\n            \"witness_multiplicities {:?} expected {:?}\",\n            airs[0].preprocessed_trace(),\n            expected_preprocessed_trace,\n        );\n\n        let mut runner = circuit.runner();\n\n        let xv = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(2),\n            BabyBear::from_u64(3),\n            BabyBear::from_u64(5),\n            BabyBear::from_u64(7),\n        ])\n        .unwrap();\n        let yv = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(11),\n            BabyBear::from_u64(13),\n            BabyBear::from_u64(17),\n            BabyBear::from_u64(19),\n        ])\n        .unwrap();\n        let zv = Ext4::from_basis_coefficients_slice(\u0026[\n            BabyBear::from_u64(23),\n            BabyBear::from_u64(29),\n            BabyBear::from_u64(31),\n            BabyBear::from_u64(37),\n        ])\n        .unwrap();\n        let expected_v = xv * yv + zv;\n        runner.set_public_inputs(\u0026[xv, yv, zv, expected_v]).unwrap();\n        let traces = runner.run().unwrap();\n\n        let cfg = config::baby_bear().build();\n        let common = CommonData::from_airs_and_degrees(\u0026cfg, \u0026airs, \u0026log_degrees);\n\n        let prover = BatchStarkProver::new(cfg);\n\n        let proof = prover.prove_all_tables(\u0026traces, \u0026common).unwrap();\n        assert_eq!(proof.ext_degree, 4);\n        // Ensure W was captured\n        let expected_w = \u003cExt4 as ExtractBinomialW\u003cBabyBear\u003e\u003e::extract_w().unwrap();\n        assert_eq!(proof.w_binomial, Some(expected_w));\n\n        assert!(prover.verify_all_tables(\u0026proof, \u0026common).is_ok());\n\n        // Check that the generated lookups are correct and consistent across tables.\n        for air in airs.iter_mut() {\n            let lookups = air.get_lookups();\n\n            match air {\n                CircuitTableAir::Witness(_) =\u003e {\n                    assert_eq!(\n                        lookups.len(),\n                        default_packing.witness_lanes(),\n                        \"Witness table should have {} lookups, found {}\",\n                        default_packing.witness_lanes(),\n                        lookups.len()\n                    );\n                }\n                CircuitTableAir::Const(_) =\u003e {\n                    assert_eq!(lookups.len(), 1, \"Const table should have one lookup\");\n                }\n                CircuitTableAir::Public(_) =\u003e {\n                    assert_eq!(lookups.len(), 1, \"Public table should have one lookup\");\n                }\n                CircuitTableAir::Add(_) =\u003e {\n                    let expected_num_lookups = default_packing.add_lanes()\n                        * AddAir::\u003cBabyBear, 1\u003e::lane_width().div_ceil(2);\n                    assert_eq!(\n                        lookups.len(),\n                        expected_num_lookups,\n                        \"Add table should have {} lookups, found {}\",\n                        expected_num_lookups,\n                        lookups.len()\n                    );\n                }\n                CircuitTableAir::Mul(_) =\u003e {\n                    let expected_num_lookups = default_packing.mul_lanes()\n                        * MulAir::\u003cBabyBear, 1\u003e::lane_width().div_ceil(2);\n                    assert_eq!(\n                        lookups.len(),\n                        expected_num_lookups,\n                        \"Mul table should have {} lookups, found {}\",\n                        expected_num_lookups,\n                        lookups.len()\n                    );\n                }\n                CircuitTableAir::Dynamic(_dynamic_air) =\u003e {\n                    assert!(\n                        lookups.is_empty(),\n                        \"There is no dynamic table in this test, so no lookups expected\"\n                    );\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_koalabear_batch_stark_base_field() {\n        let mut builder = CircuitBuilder::\u003cKoalaBear\u003e::new();\n\n        // a * b + 100 - (-1) == expected\n        let a = builder.add_public_input();\n        let b = builder.add_public_input();\n        let expected = builder.add_public_input();\n        let c = builder.add_const(KoalaBear::from_u64(100));\n        let d = builder.add_const(KoalaBear::NEG_ONE);\n\n        let ab = builder.mul(a, b);\n        let add = builder.add(ab, c);\n        let final_res = builder.sub(add, d);\n        let diff = builder.sub(final_res, expected);\n        builder.assert_zero(diff);\n\n        let circuit = builder.build().unwrap();\n        let airs_degrees =\n            get_airs_and_degrees_with_prep::\u003c_, _, 1\u003e(\u0026circuit, TablePacking::default(), None)\n                .unwrap();\n        let (airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n        let mut runner = circuit.runner();\n\n        let a_val = KoalaBear::from_u64(42);\n        let b_val = KoalaBear::from_u64(13);\n        let expected_val = KoalaBear::from_u64(647); // 42*13 + 100 - (-1)\n        runner\n            .set_public_inputs(\u0026[a_val, b_val, expected_val])\n            .unwrap();\n        let traces = runner.run().unwrap();\n\n        let cfg = config::koala_bear().build();\n        let common = CommonData::from_airs_and_degrees(\u0026cfg, \u0026airs, \u0026degrees);\n        let prover = BatchStarkProver::new(cfg);\n        let proof = prover.prove_all_tables(\u0026traces, \u0026common).unwrap();\n        assert_eq!(proof.ext_degree, 1);\n        assert!(proof.w_binomial.is_none());\n        prover.verify_all_tables(\u0026proof, \u0026common).unwrap();\n    }\n\n    #[test]\n    fn test_koalabear_batch_stark_extension_field_d8() {\n        const D: usize = 8;\n        type KBExtField = BinomialExtensionField\u003cKoalaBear, D\u003e;\n        let mut builder = CircuitBuilder::\u003cKBExtField\u003e::new();\n\n        // x * y * z == expected\n        let x = builder.add_public_input();\n        let y = builder.add_public_input();\n        let expected = builder.add_public_input();\n        let z = builder.add_const(\n            KBExtField::from_basis_coefficients_slice(\u0026[\n                KoalaBear::from_u64(1),\n                KoalaBear::NEG_ONE,\n                KoalaBear::from_u64(2),\n                KoalaBear::from_u64(3),\n                KoalaBear::from_u64(4),\n                KoalaBear::from_u64(5),\n                KoalaBear::from_u64(6),\n                KoalaBear::from_u64(7),\n            ])\n            .unwrap(),\n        );\n\n        let xy = builder.mul(x, y);\n        let xyz = builder.mul(xy, z);\n        let diff = builder.sub(xyz, expected);\n        builder.assert_zero(diff);\n\n        let circuit = builder.build().unwrap();\n        let airs_degrees =\n            get_airs_and_degrees_with_prep::\u003c_, _, D\u003e(\u0026circuit, TablePacking::default(), None)\n                .unwrap();\n        let (airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n        let mut runner = circuit.runner();\n\n        let x_val = KBExtField::from_basis_coefficients_slice(\u0026[\n            KoalaBear::from_u64(4),\n            KoalaBear::from_u64(6),\n            KoalaBear::from_u64(8),\n            KoalaBear::from_u64(10),\n            KoalaBear::from_u64(12),\n            KoalaBear::from_u64(14),\n            KoalaBear::from_u64(16),\n            KoalaBear::from_u64(18),\n        ])\n        .unwrap();\n        let y_val = KBExtField::from_basis_coefficients_slice(\u0026[\n            KoalaBear::from_u64(12),\n            KoalaBear::from_u64(14),\n            KoalaBear::from_u64(16),\n            KoalaBear::from_u64(18),\n            KoalaBear::from_u64(20),\n            KoalaBear::from_u64(22),\n            KoalaBear::from_u64(24),\n            KoalaBear::from_u64(26),\n        ])\n        .unwrap();\n        let z_val = KBExtField::from_basis_coefficients_slice(\u0026[\n            KoalaBear::from_u64(1),\n            KoalaBear::NEG_ONE,\n            KoalaBear::from_u64(2),\n            KoalaBear::from_u64(3),\n            KoalaBear::from_u64(4),\n            KoalaBear::from_u64(5),\n            KoalaBear::from_u64(6),\n            KoalaBear::from_u64(7),\n        ])\n        .unwrap();\n\n        let expected_val = x_val * y_val * z_val;\n        runner\n            .set_public_inputs(\u0026[x_val, y_val, expected_val])\n            .unwrap();\n        let traces = runner.run().unwrap();\n\n        let cfg = config::koala_bear().build();\n        let common = CommonData::from_airs_and_degrees(\u0026cfg, \u0026airs, \u0026degrees);\n        let prover = BatchStarkProver::new(cfg);\n        let proof = prover.prove_all_tables(\u0026traces, \u0026common).unwrap();\n        assert_eq!(proof.ext_degree, 8);\n        let expected_w = \u003cKBExtField as ExtractBinomialW\u003cKoalaBear\u003e\u003e::extract_w().unwrap();\n        assert_eq!(proof.w_binomial, Some(expected_w));\n        prover.verify_all_tables(\u0026proof, \u0026common).unwrap();\n    }\n\n    #[test]\n    fn test_goldilocks_batch_stark_extension_field_d2() {\n        const D: usize = 2;\n        type Ext2 = BinomialExtensionField\u003cGoldilocks, D\u003e;\n        let mut builder = CircuitBuilder::\u003cExt2\u003e::new();\n\n        // x * y + z == expected\n        let x = builder.add_public_input();\n        let y = builder.add_public_input();\n        let z = builder.add_public_input();\n        let expected = builder.add_public_input();\n\n        let xy = builder.mul(x, y);\n        let res = builder.add(xy, z);\n        let diff = builder.sub(res, expected);\n        builder.assert_zero(diff);\n\n        let circuit = builder.build().unwrap();\n        let airs_degrees =\n            get_airs_and_degrees_with_prep::\u003c_, _, D\u003e(\u0026circuit, TablePacking::default(), None)\n                .unwrap();\n        let (airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n        let mut runner = circuit.runner();\n\n        let x_val =\n            Ext2::from_basis_coefficients_slice(\u0026[Goldilocks::from_u64(3), Goldilocks::NEG_ONE])\n                .unwrap();\n        let y_val = Ext2::from_basis_coefficients_slice(\u0026[\n            Goldilocks::from_u64(7),\n            Goldilocks::from_u64(11),\n        ])\n        .unwrap();\n        let z_val = Ext2::from_basis_coefficients_slice(\u0026[\n            Goldilocks::from_u64(13),\n            Goldilocks::from_u64(17),\n        ])\n        .unwrap();\n        let expected_val = x_val * y_val + z_val;\n\n        runner\n            .set_public_inputs(\u0026[x_val, y_val, z_val, expected_val])\n            .unwrap();\n        let traces = runner.run().unwrap();\n\n        let cfg = config::goldilocks().build();\n        let common = CommonData::from_airs_and_degrees(\u0026cfg, \u0026airs, \u0026degrees);\n        let prover = BatchStarkProver::new(cfg);\n        let proof = prover.prove_all_tables(\u0026traces, \u0026common).unwrap();\n        assert_eq!(proof.ext_degree, 2);\n        let expected_w = \u003cExt2 as ExtractBinomialW\u003cGoldilocks\u003e\u003e::extract_w().unwrap();\n        assert_eq!(proof.w_binomial, Some(expected_w));\n        prover.verify_all_tables(\u0026proof, \u0026common).unwrap();\n    }\n}\n","traces":[{"line":53,"address":[7713904],"length":1,"stats":{"Line":2}},{"line":55,"address":[2275284],"length":1,"stats":{"Line":2}},{"line":56,"address":[2994617],"length":1,"stats":{"Line":2}},{"line":57,"address":[2994638],"length":1,"stats":{"Line":2}},{"line":61,"address":[2994480],"length":1,"stats":{"Line":0}},{"line":62,"address":[7713867],"length":1,"stats":{"Line":0}},{"line":66,"address":[3638240],"length":1,"stats":{"Line":2}},{"line":70,"address":[3638400],"length":1,"stats":{"Line":2}},{"line":74,"address":[3638416],"length":1,"stats":{"Line":2}},{"line":79,"address":[7737536],"length":1,"stats":{"Line":2}},{"line":80,"address":[3018184],"length":1,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[6480576,6480592,6480560],"length":1,"stats":{"Line":0}},{"line":124,"address":[4532245],"length":1,"stats":{"Line":0}},{"line":127,"address":[6480704],"length":1,"stats":{"Line":0}},{"line":128,"address":[6480709],"length":1,"stats":{"Line":0}},{"line":175,"address":[4524688,4524976,4524400,4524112,4525264],"length":1,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":7}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":6}},{"line":377,"address":[2995168,2995629,2995635],"length":1,"stats":{"Line":0}},{"line":378,"address":[3523188],"length":1,"stats":{"Line":0}},{"line":380,"address":[6448784],"length":1,"stats":{"Line":0}},{"line":381,"address":[3523110],"length":1,"stats":{"Line":0}},{"line":382,"address":[2275982],"length":1,"stats":{"Line":0}},{"line":384,"address":[4900270],"length":1,"stats":{"Line":0}},{"line":394,"address":[3523520,3524047,3524041],"length":1,"stats":{"Line":0}},{"line":395,"address":[2995826],"length":1,"stats":{"Line":0}},{"line":397,"address":[7715024],"length":1,"stats":{"Line":0}},{"line":398,"address":[2995718],"length":1,"stats":{"Line":0}},{"line":399,"address":[2276492],"length":1,"stats":{"Line":0}},{"line":401,"address":[7715228],"length":1,"stats":{"Line":0}},{"line":411,"address":[3639904,3640407,3640413],"length":1,"stats":{"Line":0}},{"line":412,"address":[4901272],"length":1,"stats":{"Line":0}},{"line":414,"address":[3524081],"length":1,"stats":{"Line":0}},{"line":415,"address":[4901175],"length":1,"stats":{"Line":0}},{"line":416,"address":[3524210],"length":1,"stats":{"Line":0}},{"line":418,"address":[6450002],"length":1,"stats":{"Line":0}},{"line":428,"address":[7716080,7716594,7716588],"length":1,"stats":{"Line":0}},{"line":429,"address":[3524775],"length":1,"stats":{"Line":0}},{"line":431,"address":[3640449],"length":1,"stats":{"Line":0}},{"line":432,"address":[3640503],"length":1,"stats":{"Line":0}},{"line":433,"address":[2996881],"length":1,"stats":{"Line":0}},{"line":435,"address":[2996945],"length":1,"stats":{"Line":0}},{"line":443,"address":[2994720],"length":1,"stats":{"Line":0}},{"line":444,"address":[2994754],"length":1,"stats":{"Line":0}},{"line":445,"address":[3638529],"length":1,"stats":{"Line":0}},{"line":446,"address":[3638574],"length":1,"stats":{"Line":0}},{"line":447,"address":[3522701],"length":1,"stats":{"Line":0}},{"line":450,"address":[6448509],"length":1,"stats":{"Line":0}},{"line":451,"address":[7714304],"length":1,"stats":{"Line":0}},{"line":452,"address":[7714268],"length":1,"stats":{"Line":0}},{"line":455,"address":[4899893],"length":1,"stats":{"Line":0}},{"line":456,"address":[3638741],"length":1,"stats":{"Line":0}},{"line":457,"address":[2275681],"length":1,"stats":{"Line":0}},{"line":460,"address":[3638775],"length":1,"stats":{"Line":0}},{"line":461,"address":[4900023],"length":1,"stats":{"Line":0}},{"line":462,"address":[7714435],"length":1,"stats":{"Line":0}},{"line":480,"address":[2278864],"length":1,"stats":{"Line":0}},{"line":481,"address":[4823566],"length":1,"stats":{"Line":0}},{"line":482,"address":[3526278,3526098],"length":1,"stats":{"Line":0}},{"line":483,"address":[3642204,3641983],"length":1,"stats":{"Line":0}},{"line":484,"address":[6480156,6480406],"length":1,"stats":{"Line":0}},{"line":485,"address":[2998647,2998361],"length":1,"stats":{"Line":0}},{"line":509,"address":[6623776,6623760,6623744],"length":1,"stats":{"Line":0}},{"line":510,"address":[6623765,6623781,6623749],"length":1,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[4563014,4563097,4563178],"length":1,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[6622250,6622778,6623290],"length":1,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[6622817,6622290,6623329],"length":1,"stats":{"Line":0}},{"line":519,"address":[4563083],"length":1,"stats":{"Line":0}},{"line":521,"address":[6622345,6622872,6623384],"length":1,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[6635984,6635120,6634256],"length":1,"stats":{"Line":0}},{"line":537,"address":[6635153,6634289,6636017],"length":1,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[6636500,6634342,6634747,6635611,6636070,6635206],"length":1,"stats":{"Line":0}},{"line":544,"address":[6635667,6636556,6634803],"length":1,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[4571271],"length":1,"stats":{"Line":0}},{"line":551,"address":[6636172,6635304,6635701,6636590,6634440,6634837],"length":1,"stats":{"Line":0}},{"line":555,"address":[4571741],"length":1,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[6636266,6635385,6634521],"length":1,"stats":{"Line":0}},{"line":562,"address":[4571386,4571769],"length":1,"stats":{"Line":0}},{"line":566,"address":[4571837],"length":1,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[6636386,6634637,6635501],"length":1,"stats":{"Line":0}},{"line":573,"address":[4571501,4571868],"length":1,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[4571943],"length":1,"stats":{"Line":0}},{"line":588,"address":[6467120,6472944,6475024,6475440,6468368,6467536,6461712,6476688,6479600,6464208,6470448,6466704,6470032,6464624,6462960,6465456,6465872,6473360,6476272,6468784,6478768,6472528,6475856,6471696,6463792,6477520,6460880,6477936,6477104,6478352,6474192,6479184,6473776,6463376,6470864,6461296,6471280,6469616,6465040,6472112,6466288,6462128,6460048,6469200,6460464,6462544,6474608,6467952],"length":1,"stats":{"Line":0}},{"line":629,"address":[4527371,4529867,4526955,4528203,4530283,4530699,4525707,4529035,4526123,4526539,4531947,4527787,4528619,4529451,4531115,4531531],"length":1,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[4527475,4529139,4529971,4531635,4531219,4525811,4528723,4530387,4530803,4526227,4527059,4532051,4528307,4526643,4527891,4529555],"length":1,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[4528444,4526364,4530940,4530524,4531772,4528860,4526780,4527612,4532188,4531356,4529276,4529692,4530108,4525948,4528028,4527196],"length":1,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[4528036,4526372,4528452,4530116,4527204,4531780,4531364,4525956,4529284,4526788,4530532,4529700,4528868,4532196,4530948,4527620],"length":1,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[6469580,6470412,6471660,6464172,6468748,6473743,6476652,6477068,6479151,6467916,6466668,6475820,6462092,6468332,6472908,6472076,6474156,6478316,6477900,6479980,6474572,6460844,6474991,6466252,6469996,6461676,6471244,6465004,6476236,6477484,6473324,6463756,6467503,6472492,6469164,6478735,6460431,6479564,6475404,6470831,6467084,6465420,6462924,6463340,6461260,6465836,6464591,6462508],"length":1,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[4458279],"length":1,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[6428704,6430656,6429680],"length":1,"stats":{"Line":0}},{"line":716,"address":[4458443],"length":1,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[4458523],"length":1,"stats":{"Line":0}},{"line":738,"address":[6430868,6428916,6429892],"length":1,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[6431107,6429155,6430131],"length":1,"stats":{"Line":0}},{"line":784,"address":[4458916],"length":1,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":787,"address":[6431237,6430261,6429285],"length":1,"stats":{"Line":0}},{"line":788,"address":[4458972],"length":1,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[6429432,6430408,6431384],"length":1,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":825,"address":[6431576,6432584,6433592],"length":1,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":0}},{"line":827,"address":[4459439],"length":1,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[4459529],"length":1,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[6433903,6431887,6432895],"length":1,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[6432110,6434126,6433118],"length":1,"stats":{"Line":0}},{"line":895,"address":[4459916],"length":1,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[6434230,6432214,6433222],"length":1,"stats":{"Line":0}},{"line":898,"address":[6433245,6432237,6434253],"length":1,"stats":{"Line":0}},{"line":899,"address":[6434276,6432260,6433268],"length":1,"stats":{"Line":0}},{"line":918,"address":[6434367,6432351,6433359],"length":1,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[4460096],"length":1,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[4521799],"length":1,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[4521888],"length":1,"stats":{"Line":0}},{"line":938,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[6440907,6441883,6442859],"length":1,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[6440977,6442929,6441953],"length":1,"stats":{"Line":0}},{"line":963,"address":[6442958,6441982,6441006],"length":1,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[6443093,6441141,6442117],"length":1,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[4522287],"length":1,"stats":{"Line":0}},{"line":986,"address":[4522313],"length":1,"stats":{"Line":0}},{"line":987,"address":[4522339],"length":1,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[6442309,6443285,6441333],"length":1,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1031,"address":[4522593],"length":1,"stats":{"Line":0}},{"line":1032,"address":[6442456,6443432,6441480],"length":1,"stats":{"Line":0}},{"line":1033,"address":[4522639],"length":1,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[4522808],"length":1,"stats":{"Line":0}},{"line":1048,"address":[4522890],"length":1,"stats":{"Line":0}},{"line":1049,"address":[],"length":0,"stats":{"Line":0}},{"line":1050,"address":[],"length":0,"stats":{"Line":0}},{"line":1054,"address":[4523049],"length":1,"stats":{"Line":0}},{"line":1071,"address":[4523106],"length":1,"stats":{"Line":0}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[6447487,6445471,6446479],"length":1,"stats":{"Line":0}},{"line":1074,"address":[6445500,6446508,6447516],"length":1,"stats":{"Line":0}},{"line":1075,"address":[4523177],"length":1,"stats":{"Line":0}},{"line":1094,"address":[],"length":0,"stats":{"Line":0}},{"line":1095,"address":[],"length":0,"stats":{"Line":0}},{"line":1096,"address":[],"length":0,"stats":{"Line":0}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1098,"address":[6446702,6445694,6447710],"length":1,"stats":{"Line":0}},{"line":1117,"address":[4523436],"length":1,"stats":{"Line":0}},{"line":1118,"address":[],"length":0,"stats":{"Line":0}},{"line":1119,"address":[6447814,6445798,6446806],"length":1,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1121,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[6446943,6445935,6447951],"length":1,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":0}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1156,"address":[6640544,6640096,6640320],"length":1,"stats":{"Line":0}},{"line":1157,"address":[4573079],"length":1,"stats":{"Line":0}},{"line":1158,"address":[],"length":0,"stats":{"Line":0}},{"line":1159,"address":[6640387,6640611,6640163],"length":1,"stats":{"Line":0}},{"line":1162,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[4573152],"length":1,"stats":{"Line":0}},{"line":1165,"address":[4573161],"length":1,"stats":{"Line":0}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1174,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[4573237],"length":1,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[4572000],"length":1,"stats":{"Line":0}},{"line":1190,"address":[6639070,6636942,6637998],"length":1,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[6637469,6638541,6639597],"length":1,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[4572588],"length":1,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[4572696],"length":1,"stats":{"Line":0}},{"line":1206,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[6638720,6637642,6639770],"length":1,"stats":{"Line":0}},{"line":1211,"address":[6637682,6638273,6639337,6638760,6639810,6637209],"length":1,"stats":{"Line":0}},{"line":1212,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[6639907,6638857,6637779],"length":1,"stats":{"Line":0}},{"line":1220,"address":[4572907,4572412],"length":1,"stats":{"Line":0}},{"line":1221,"address":[4572969],"length":1,"stats":{"Line":0}},{"line":1224,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[6637915,6638993,6640043],"length":1,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1237,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1251,"address":[],"length":0,"stats":{"Line":0}},{"line":1252,"address":[4561665],"length":1,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1276,"address":[4903056],"length":1,"stats":{"Line":0}},{"line":1280,"address":[6451680,6452416,6452048,6452004,6452372,6452740],"length":1,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[4523846,4523769],"length":1,"stats":{"Line":0}},{"line":1290,"address":[4523856],"length":1,"stats":{"Line":0}},{"line":1291,"address":[4523920],"length":1,"stats":{"Line":0}},{"line":1292,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[3641498,3641492,3640960],"length":1,"stats":{"Line":0}},{"line":1297,"address":[2277971],"length":1,"stats":{"Line":0}},{"line":1298,"address":[3525219],"length":1,"stats":{"Line":0}},{"line":1299,"address":[6450972],"length":1,"stats":{"Line":0}},{"line":1300,"address":[2278101,2278436],"length":1,"stats":{"Line":0}},{"line":1302,"address":[2278125],"length":1,"stats":{"Line":0}},{"line":1303,"address":[3519897],"length":1,"stats":{"Line":0}},{"line":1304,"address":[6451388,6451083],"length":1,"stats":{"Line":0}},{"line":1306,"address":[3519975],"length":1,"stats":{"Line":0}},{"line":1307,"address":[4902451,4902778],"length":1,"stats":{"Line":0}},{"line":1309,"address":[7716977],"length":1,"stats":{"Line":0}},{"line":1310,"address":[2997936,2997629],"length":1,"stats":{"Line":0}},{"line":1315,"address":[6451552],"length":1,"stats":{"Line":0}},{"line":1316,"address":[3520473],"length":1,"stats":{"Line":0}},{"line":1318,"address":[7717442],"length":1,"stats":{"Line":0}},{"line":1321,"address":[4823471],"length":1,"stats":{"Line":0}},{"line":1324,"address":[4903020],"length":1,"stats":{"Line":0}},{"line":1327,"address":[3525993],"length":1,"stats":{"Line":0}},{"line":1343,"address":[],"length":0,"stats":{"Line":0}},{"line":1345,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1356,"address":[],"length":0,"stats":{"Line":0}},{"line":1357,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1366,"address":[],"length":0,"stats":{"Line":0}},{"line":1368,"address":[],"length":0,"stats":{"Line":0}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1370,"address":[],"length":0,"stats":{"Line":0}},{"line":1371,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":0}},{"line":1373,"address":[],"length":0,"stats":{"Line":0}},{"line":1374,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1378,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1380,"address":[],"length":0,"stats":{"Line":0}},{"line":1381,"address":[],"length":0,"stats":{"Line":0}},{"line":1382,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1410,"address":[],"length":0,"stats":{"Line":0}},{"line":1411,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[],"length":0,"stats":{"Line":0}},{"line":1413,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1415,"address":[],"length":0,"stats":{"Line":0}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1419,"address":[],"length":0,"stats":{"Line":0}},{"line":1420,"address":[],"length":0,"stats":{"Line":0}},{"line":1421,"address":[],"length":0,"stats":{"Line":0}},{"line":1422,"address":[],"length":0,"stats":{"Line":0}},{"line":1423,"address":[],"length":0,"stats":{"Line":0}},{"line":1424,"address":[],"length":0,"stats":{"Line":0}},{"line":1425,"address":[],"length":0,"stats":{"Line":0}},{"line":1426,"address":[],"length":0,"stats":{"Line":0}},{"line":1427,"address":[],"length":0,"stats":{"Line":0}},{"line":1435,"address":[],"length":0,"stats":{"Line":0}},{"line":1439,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1441,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1443,"address":[],"length":0,"stats":{"Line":0}},{"line":1444,"address":[],"length":0,"stats":{"Line":0}},{"line":1445,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1448,"address":[],"length":0,"stats":{"Line":0}},{"line":1450,"address":[],"length":0,"stats":{"Line":0}},{"line":1451,"address":[],"length":0,"stats":{"Line":0}},{"line":1452,"address":[],"length":0,"stats":{"Line":0}},{"line":1453,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1457,"address":[],"length":0,"stats":{"Line":0}},{"line":1458,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":0}},{"line":1462,"address":[],"length":0,"stats":{"Line":0}},{"line":1465,"address":[],"length":0,"stats":{"Line":0}},{"line":1466,"address":[],"length":0,"stats":{"Line":0}},{"line":1467,"address":[],"length":0,"stats":{"Line":0}},{"line":1468,"address":[],"length":0,"stats":{"Line":0}},{"line":1469,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1472,"address":[],"length":0,"stats":{"Line":0}},{"line":1473,"address":[],"length":0,"stats":{"Line":0}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1476,"address":[],"length":0,"stats":{"Line":0}},{"line":1477,"address":[],"length":0,"stats":{"Line":0}},{"line":1478,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1482,"address":[],"length":0,"stats":{"Line":0}},{"line":1483,"address":[],"length":0,"stats":{"Line":0}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1490,"address":[],"length":0,"stats":{"Line":0}},{"line":1491,"address":[],"length":0,"stats":{"Line":0}},{"line":1492,"address":[],"length":0,"stats":{"Line":0}},{"line":1493,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1495,"address":[],"length":0,"stats":{"Line":0}},{"line":1497,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1500,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1506,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[],"length":0,"stats":{"Line":0}},{"line":1512,"address":[],"length":0,"stats":{"Line":0}},{"line":1515,"address":[],"length":0,"stats":{"Line":0}},{"line":1516,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1519,"address":[],"length":0,"stats":{"Line":0}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1522,"address":[],"length":0,"stats":{"Line":0}},{"line":1523,"address":[],"length":0,"stats":{"Line":0}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1527,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1533,"address":[],"length":0,"stats":{"Line":0}},{"line":1534,"address":[],"length":0,"stats":{"Line":0}},{"line":1535,"address":[],"length":0,"stats":{"Line":0}},{"line":1537,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1567,"address":[],"length":0,"stats":{"Line":0}},{"line":1577,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1587,"address":[],"length":0,"stats":{"Line":0}},{"line":1588,"address":[],"length":0,"stats":{"Line":0}},{"line":1599,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1610,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1621,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":0}},{"line":1623,"address":[],"length":0,"stats":{"Line":0}},{"line":1624,"address":[],"length":0,"stats":{"Line":0}},{"line":1628,"address":[],"length":0,"stats":{"Line":0}},{"line":1631,"address":[],"length":0,"stats":{"Line":0}},{"line":1633,"address":[],"length":0,"stats":{"Line":0}},{"line":1634,"address":[],"length":0,"stats":{"Line":0}},{"line":1635,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1644,"address":[],"length":0,"stats":{"Line":0}},{"line":1645,"address":[],"length":0,"stats":{"Line":0}},{"line":1646,"address":[],"length":0,"stats":{"Line":0}},{"line":1650,"address":[],"length":0,"stats":{"Line":0}},{"line":1653,"address":[],"length":0,"stats":{"Line":0}},{"line":1655,"address":[],"length":0,"stats":{"Line":0}},{"line":1656,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":0}},{"line":1661,"address":[],"length":0,"stats":{"Line":0}},{"line":1664,"address":[],"length":0,"stats":{"Line":0}},{"line":1681,"address":[2279504],"length":1,"stats":{"Line":2}},{"line":1683,"address":[7718195],"length":1,"stats":{"Line":2}},{"line":1684,"address":[4824373,4824220],"length":1,"stats":{"Line":4}},{"line":1685,"address":[3642594],"length":1,"stats":{"Line":2}},{"line":1686,"address":[4903914,4903877],"length":1,"stats":{"Line":2}},{"line":1688,"address":[3642574],"length":1,"stats":{"Line":2}},{"line":1693,"address":[2279424],"length":1,"stats":{"Line":0}},{"line":1694,"address":[6585061,6585099],"length":1,"stats":{"Line":0}},{"line":1700,"address":[3637936],"length":1,"stats":{"Line":2}},{"line":1701,"address":[3516742,3516697],"length":1,"stats":{"Line":2}},{"line":1706,"address":[2992976],"length":1,"stats":{"Line":0}},{"line":1707,"address":[2273672],"length":1,"stats":{"Line":0}},{"line":1734,"address":[],"length":0,"stats":{"Line":0}},{"line":1735,"address":[],"length":0,"stats":{"Line":0}},{"line":1736,"address":[],"length":0,"stats":{"Line":0}},{"line":1737,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1739,"address":[],"length":0,"stats":{"Line":0}},{"line":1775,"address":[],"length":0,"stats":{"Line":6}},{"line":1776,"address":[5039870,5040126,5039102,5041374,5041614,5039358,5042110,5042366,5040622,5040382,5039614,5040862,5042622,5041870,5041118],"length":1,"stats":{"Line":7}},{"line":1777,"address":[2946670,2946158,2945902,2945646,2946414],"length":1,"stats":{"Line":7}},{"line":1778,"address":[],"length":0,"stats":{"Line":7}},{"line":1779,"address":[],"length":0,"stats":{"Line":7}},{"line":1780,"address":[],"length":0,"stats":{"Line":7}},{"line":1781,"address":[],"length":0,"stats":{"Line":7}},{"line":1782,"address":[5040319,5042055,5041807,5040567,5040807,5039551,5042559,5040063,5041311,5042807,5041055,5039295,5041559,5042303,5039807],"length":1,"stats":{"Line":0}},{"line":1786,"address":[2945312],"length":1,"stats":{"Line":6}},{"line":1787,"address":[2945335],"length":1,"stats":{"Line":6}},{"line":1788,"address":[],"length":0,"stats":{"Line":6}},{"line":1789,"address":[5038452,5038708,5038956,5037940,5038196],"length":1,"stats":{"Line":6}},{"line":1790,"address":[5038221,5038981,5038733,5037965,5038477],"length":1,"stats":{"Line":6}},{"line":1791,"address":[5039006,5037990,5038246,5038758,5038502],"length":1,"stats":{"Line":6}},{"line":1792,"address":[5039031,5038783,5038527,5038015,5038271],"length":1,"stats":{"Line":6}},{"line":1793,"address":[],"length":0,"stats":{"Line":0}},{"line":1803,"address":[5043088,5043328,5042848,5043808,5043568],"length":1,"stats":{"Line":7}},{"line":1804,"address":[5042871,5043831,5043591,5043111,5043351],"length":1,"stats":{"Line":7}},{"line":1805,"address":[2946939],"length":1,"stats":{"Line":7}},{"line":1806,"address":[5042964,5043684,5043924,5043196,5043444],"length":1,"stats":{"Line":7}},{"line":1807,"address":[5043221,5043469,5043709,5043949,5042989],"length":1,"stats":{"Line":7}},{"line":1808,"address":[5043494,5043246,5043974,5043014,5043734],"length":1,"stats":{"Line":7}},{"line":1809,"address":[5043271,5043039,5043519,5043759,5043999],"length":1,"stats":{"Line":7}},{"line":1810,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[5043544,5043064,5043784,5044024,5043296],"length":1,"stats":{"Line":0}},{"line":1822,"address":[],"length":0,"stats":{"Line":7}},{"line":1823,"address":[5033527,5033287,5033767,5033047,5034007],"length":1,"stats":{"Line":6}},{"line":1824,"address":[5033355,5034067,5033835,5033115,5033595],"length":1,"stats":{"Line":6}},{"line":1825,"address":[],"length":0,"stats":{"Line":6}},{"line":1826,"address":[2944013],"length":1,"stats":{"Line":6}},{"line":1827,"address":[2944038],"length":1,"stats":{"Line":6}},{"line":1828,"address":[],"length":0,"stats":{"Line":6}},{"line":1829,"address":[2944079],"length":1,"stats":{"Line":0}},{"line":1830,"address":[5033480,5033240,5033720,5033960,5034192],"length":1,"stats":{"Line":0}},{"line":1841,"address":[],"length":0,"stats":{"Line":6}},{"line":1842,"address":[5036647,5035207,5035687,5035927,5035447,5037127,5034967,5036887,5037367,5037607,5034487,5036167,5036407,5034727,5034247],"length":1,"stats":{"Line":6}},{"line":1843,"address":[2944203,2944443,2945163,2944923,2944683],"length":1,"stats":{"Line":6}},{"line":1844,"address":[5036492,5036732,5037700,5035540,5034820,5036260,5037212,5036020,5036980,5035300,5034340,5035052,5037460,5035772,5034580],"length":1,"stats":{"Line":6}},{"line":1845,"address":[2944493,2944253,2944973,2944733,2945213],"length":1,"stats":{"Line":6}},{"line":1846,"address":[5035350,5035590,5036542,5037750,5035822,5034390,5036310,5037510,5036782,5034630,5037262,5037030,5035102,5034870,5036070],"length":1,"stats":{"Line":6}},{"line":1847,"address":[2944543,2945023,2944303,2944783,2945263],"length":1,"stats":{"Line":6}},{"line":1848,"address":[],"length":0,"stats":{"Line":0}},{"line":1849,"address":[],"length":0,"stats":{"Line":0}},{"line":1860,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1862,"address":[],"length":0,"stats":{"Line":0}},{"line":1863,"address":[],"length":0,"stats":{"Line":0}},{"line":1865,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1868,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1872,"address":[],"length":0,"stats":{"Line":0}},{"line":1873,"address":[],"length":0,"stats":{"Line":0}},{"line":1875,"address":[],"length":0,"stats":{"Line":0}},{"line":1881,"address":[],"length":0,"stats":{"Line":1}},{"line":1882,"address":[],"length":0,"stats":{"Line":1}},{"line":1883,"address":[5044139],"length":1,"stats":{"Line":1}},{"line":1884,"address":[],"length":0,"stats":{"Line":1}},{"line":1885,"address":[5044189],"length":1,"stats":{"Line":1}},{"line":1886,"address":[5044214],"length":1,"stats":{"Line":1}},{"line":1887,"address":[5044239],"length":1,"stats":{"Line":1}},{"line":1888,"address":[5044255],"length":1,"stats":{"Line":0}},{"line":1889,"address":[5044264],"length":1,"stats":{"Line":0}},{"line":1900,"address":[4533728,4533963],"length":1,"stats":{"Line":4}},{"line":1903,"address":[4533764],"length":1,"stats":{"Line":4}},{"line":1904,"address":[6486976,6487488,6487232],"length":1,"stats":{"Line":4}},{"line":1909,"address":[4533664],"length":1,"stats":{"Line":1}},{"line":1910,"address":[],"length":0,"stats":{"Line":1}},{"line":1911,"address":[4533704],"length":1,"stats":{"Line":1}},{"line":1915,"address":[],"length":0,"stats":{"Line":0}},{"line":1916,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1922,"address":[],"length":0,"stats":{"Line":0}},{"line":1923,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1936,"address":[],"length":0,"stats":{"Line":0}},{"line":1937,"address":[],"length":0,"stats":{"Line":0}},{"line":1942,"address":[6481728,6483724,6480720,6482707,6482701,6481686,6484784,6484733,6482752,6484739,6483718,6485768,6481692,6485762,6483760],"length":1,"stats":{"Line":6}},{"line":1950,"address":[6482909,6481885,6485553,6480877,6482495,6481487,6483519,6483917,6484527,6484941],"length":1,"stats":{"Line":13}},{"line":1951,"address":[6484541,6485569,6482509,6481501,6483533],"length":1,"stats":{"Line":6}},{"line":1952,"address":[6483567,6481535],"length":1,"stats":{"Line":3}},{"line":1953,"address":[6485611],"length":1,"stats":{"Line":1}},{"line":1954,"address":[],"length":0,"stats":{"Line":1}},{"line":1955,"address":[],"length":0,"stats":{"Line":0}},{"line":1956,"address":[],"length":0,"stats":{"Line":1}},{"line":1957,"address":[],"length":0,"stats":{"Line":0}},{"line":1962,"address":[4533296],"length":1,"stats":{"Line":4}},{"line":1967,"address":[6486555,6485851,6486219],"length":1,"stats":{"Line":4}},{"line":1968,"address":[],"length":0,"stats":{"Line":3}},{"line":1969,"address":[],"length":0,"stats":{"Line":1}},{"line":1970,"address":[4533543],"length":1,"stats":{"Line":1}},{"line":1971,"address":[6486094,6486798,6486452],"length":1,"stats":{"Line":0}},{"line":1972,"address":[],"length":0,"stats":{"Line":1}},{"line":1973,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[6509520,6502384,6495024,6523973,6516656,6509480,6502341,6515329,6494981,6487648,6522851,6501219,6493820,6508193,6516616],"length":1,"stats":{"Line":6}},{"line":1993,"address":[6516772,6502485,6495140,6487766,6509621],"length":1,"stats":{"Line":6}},{"line":1994,"address":[6495306,6509787,6516938,6487932,6502651],"length":1,"stats":{"Line":6}},{"line":1995,"address":[6502712,6495367,6487993,6509848,6516999],"length":1,"stats":{"Line":6}},{"line":1996,"address":[6502776,6495431,6509912,6517063,6488057],"length":1,"stats":{"Line":6}},{"line":1999,"address":[6509984,6517135,6495503,6488129,6502848],"length":1,"stats":{"Line":6}},{"line":2000,"address":[6510023,6517174,6488168,6495542,6502887],"length":1,"stats":{"Line":6}},{"line":2001,"address":[6517275,6495643,6510068,6502932,6488213,6502988,6488269,6517219,6495587,6510124],"length":1,"stats":{"Line":12}},{"line":2002,"address":[],"length":0,"stats":{"Line":0}},{"line":2005,"address":[6517356,6495651,6517283,6495724,6488277,6502996,6488350,6510205,6510132,6503069],"length":1,"stats":{"Line":12}},{"line":2006,"address":[6495732,6517364,6488358,6503077,6510213],"length":1,"stats":{"Line":6}},{"line":2007,"address":[],"length":0,"stats":{"Line":7}},{"line":2008,"address":[4534823,4534755],"length":1,"stats":{"Line":14}},{"line":2009,"address":[],"length":0,"stats":{"Line":0}},{"line":2012,"address":[4534904,4534831],"length":1,"stats":{"Line":14}},{"line":2013,"address":[],"length":0,"stats":{"Line":7}},{"line":2014,"address":[],"length":0,"stats":{"Line":6}},{"line":2015,"address":[],"length":0,"stats":{"Line":12}},{"line":2016,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":12}},{"line":2020,"address":[6517821,6488815,6503534,6496189,6510670],"length":1,"stats":{"Line":6}},{"line":2021,"address":[4535200],"length":1,"stats":{"Line":7}},{"line":2022,"address":[4535302,4535231],"length":1,"stats":{"Line":14}},{"line":2023,"address":[],"length":0,"stats":{"Line":0}},{"line":2026,"address":[],"length":0,"stats":{"Line":14}},{"line":2027,"address":[6489071,6503790,6510926,6518077,6496445],"length":1,"stats":{"Line":6}},{"line":2028,"address":[],"length":0,"stats":{"Line":3}},{"line":2029,"address":[4535617,4535448],"length":1,"stats":{"Line":6}},{"line":2031,"address":[6489127,6518467,6489465,6496499,6496835,6518219,6518131,6489215,6496587],"length":1,"stats":{"Line":6}},{"line":2032,"address":[],"length":0,"stats":{"Line":3}},{"line":2034,"address":[6496813,6504064,6518545,6489443,6496913,6489543,6511200,6511092,6503956,6518445],"length":1,"stats":{"Line":12}},{"line":2035,"address":[],"length":0,"stats":{"Line":0}},{"line":2039,"address":[6489611,6496921,6511268,6504072,6518553,6518613,6511208,6489551,6496981,6504132],"length":1,"stats":{"Line":14}},{"line":2040,"address":[6489778,6497148,6501671,6504299,6508810,6511435,6494277,6518780,6515946,6523303],"length":1,"stats":{"Line":0}},{"line":2041,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[6524098,6524706,6524080,6494295,6523321,6524624,6524688,6501689,6515964,6524034,6524016,6524912,6508828,6524642,6524930],"length":1,"stats":{"Line":0}},{"line":2044,"address":[6516090,6494421,6523447,6501815,6508954],"length":1,"stats":{"Line":0}},{"line":2048,"address":[6511469,6518814,6497182,6504333,6489812],"length":1,"stats":{"Line":7}},{"line":2049,"address":[],"length":0,"stats":{"Line":7}},{"line":2050,"address":[6511717,6504581],"length":1,"stats":{"Line":3}},{"line":2051,"address":[6504589,6511725],"length":1,"stats":{"Line":3}},{"line":2052,"address":[4540259,4536369],"length":1,"stats":{"Line":0}},{"line":2053,"address":[4540412],"length":1,"stats":{"Line":0}},{"line":2056,"address":[],"length":0,"stats":{"Line":4}},{"line":2057,"address":[],"length":0,"stats":{"Line":0}},{"line":2058,"address":[6490062],"length":1,"stats":{"Line":1}},{"line":2059,"address":[],"length":0,"stats":{"Line":1}},{"line":2060,"address":[6490238],"length":1,"stats":{"Line":0}},{"line":2061,"address":[],"length":0,"stats":{"Line":0}},{"line":2064,"address":[6497199,6518831],"length":1,"stats":{"Line":3}},{"line":2065,"address":[],"length":0,"stats":{"Line":0}},{"line":2066,"address":[],"length":0,"stats":{"Line":1}},{"line":2067,"address":[],"length":0,"stats":{"Line":1}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2069,"address":[],"length":0,"stats":{"Line":0}},{"line":2072,"address":[6518833],"length":1,"stats":{"Line":1}},{"line":2073,"address":[],"length":0,"stats":{"Line":0}},{"line":2074,"address":[],"length":0,"stats":{"Line":0}},{"line":2075,"address":[],"length":0,"stats":{"Line":0}},{"line":2076,"address":[],"length":0,"stats":{"Line":0}},{"line":2077,"address":[],"length":0,"stats":{"Line":0}},{"line":2080,"address":[],"length":0,"stats":{"Line":1}},{"line":2081,"address":[],"length":0,"stats":{"Line":0}},{"line":2082,"address":[6519044],"length":1,"stats":{"Line":1}},{"line":2083,"address":[6519052],"length":1,"stats":{"Line":1}},{"line":2084,"address":[],"length":0,"stats":{"Line":0}},{"line":2085,"address":[6519458],"length":1,"stats":{"Line":0}},{"line":2092,"address":[4536443,4536118],"length":1,"stats":{"Line":12}},{"line":2093,"address":[],"length":0,"stats":{"Line":0}},{"line":2094,"address":[4536575,4536512],"length":1,"stats":{"Line":12}},{"line":2095,"address":[],"length":0,"stats":{"Line":0}},{"line":2096,"address":[],"length":0,"stats":{"Line":12}},{"line":2097,"address":[],"length":0,"stats":{"Line":0}},{"line":2098,"address":[6505255,6512319,6490898,6498198,6505183,6498270,6512391,6519830,6490826,6519902],"length":1,"stats":{"Line":12}},{"line":2099,"address":[],"length":0,"stats":{"Line":0}},{"line":2101,"address":[4536874],"length":1,"stats":{"Line":6}},{"line":2102,"address":[4537059],"length":1,"stats":{"Line":6}},{"line":2103,"address":[4537122],"length":1,"stats":{"Line":6}},{"line":2105,"address":[4537164],"length":1,"stats":{"Line":6}},{"line":2106,"address":[6498676,6520308,6491292,6512797,6505661],"length":1,"stats":{"Line":6}},{"line":2107,"address":[6520379,6491363,6498747,6505732,6512868],"length":1,"stats":{"Line":6}},{"line":2109,"address":[4537382],"length":1,"stats":{"Line":6}},{"line":2110,"address":[],"length":0,"stats":{"Line":6}},{"line":2111,"address":[4537558],"length":1,"stats":{"Line":6}},{"line":2113,"address":[4537600],"length":1,"stats":{"Line":6}},{"line":2114,"address":[4537745],"length":1,"stats":{"Line":6}},{"line":2115,"address":[],"length":0,"stats":{"Line":6}},{"line":2117,"address":[6491841,6513358,6520869,6506222,6499237],"length":1,"stats":{"Line":6}},{"line":2118,"address":[4538009],"length":1,"stats":{"Line":7}},{"line":2119,"address":[6499467,6513588,6506452,6521099,6492071],"length":1,"stats":{"Line":7}},{"line":2121,"address":[],"length":0,"stats":{"Line":14}},{"line":2122,"address":[],"length":0,"stats":{"Line":0}},{"line":2123,"address":[4538441],"length":1,"stats":{"Line":0}},{"line":2124,"address":[],"length":0,"stats":{"Line":0}},{"line":2125,"address":[4538521],"length":1,"stats":{"Line":0}},{"line":2126,"address":[6506929,6492545,6499944,6521576,6514065],"length":1,"stats":{"Line":0}},{"line":2127,"address":[4538601],"length":1,"stats":{"Line":0}},{"line":2128,"address":[],"length":0,"stats":{"Line":0}},{"line":2129,"address":[6500008,6506993,6514129,6521640,6492609],"length":1,"stats":{"Line":0}},{"line":2130,"address":[6515394,6501284,6522916,6508258,6493885],"length":1,"stats":{"Line":0}},{"line":2131,"address":[4539957],"length":1,"stats":{"Line":0}},{"line":2132,"address":[6501457,6508431,6494059,6523089,6515567],"length":1,"stats":{"Line":0}},{"line":2133,"address":[],"length":0,"stats":{"Line":0}},{"line":2134,"address":[],"length":0,"stats":{"Line":0}},{"line":2135,"address":[4540031],"length":1,"stats":{"Line":0}},{"line":2139,"address":[],"length":0,"stats":{"Line":7}},{"line":2141,"address":[4538768],"length":1,"stats":{"Line":7}},{"line":2142,"address":[4538831],"length":1,"stats":{"Line":7}},{"line":2143,"address":[4541224,4541216,4538918],"length":1,"stats":{"Line":21}},{"line":2144,"address":[],"length":0,"stats":{"Line":0}},{"line":2145,"address":[],"length":0,"stats":{"Line":0}},{"line":2146,"address":[],"length":0,"stats":{"Line":0}},{"line":2150,"address":[6492952,6500357,6507348,6521989,6514484],"length":1,"stats":{"Line":6}},{"line":2154,"address":[4539003,4539078],"length":1,"stats":{"Line":13}},{"line":2155,"address":[4539086],"length":1,"stats":{"Line":6}},{"line":2156,"address":[6493100,6522137,6500505,6507496,6514632],"length":1,"stats":{"Line":6}},{"line":2157,"address":[6500547,6514674,6522179,6507538,6493142],"length":1,"stats":{"Line":6}},{"line":2158,"address":[4539212],"length":1,"stats":{"Line":6}},{"line":2160,"address":[6493450,6507863,6514999,6522521,6500889],"length":1,"stats":{"Line":6}},{"line":2161,"address":[6522255,6493218,6514750,6500623,6507614],"length":1,"stats":{"Line":6}},{"line":2162,"address":[],"length":0,"stats":{"Line":0}},{"line":2163,"address":[4539309],"length":1,"stats":{"Line":6}},{"line":2164,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2167,"address":[],"length":0,"stats":{"Line":0}},{"line":2168,"address":[],"length":0,"stats":{"Line":0}},{"line":2170,"address":[],"length":0,"stats":{"Line":0}},{"line":2171,"address":[6507780,6493384,6522421,6514916,6500789],"length":1,"stats":{"Line":6}},{"line":2172,"address":[],"length":0,"stats":{"Line":6}},{"line":2181,"address":[4555198,4544924,4551872,4548508,4548254,4541376,4551618,4544960,4558782,4548544,4555452,4544670,4559036,4551904,4555488],"length":1,"stats":{"Line":6}},{"line":2188,"address":[],"length":0,"stats":{"Line":6}},{"line":2189,"address":[],"length":0,"stats":{"Line":6}},{"line":2190,"address":[],"length":0,"stats":{"Line":6}},{"line":2191,"address":[],"length":0,"stats":{"Line":6}},{"line":2193,"address":[4548977,4555936,4545408,4541824,4552352],"length":1,"stats":{"Line":7}},{"line":2194,"address":[],"length":0,"stats":{"Line":7}},{"line":2195,"address":[],"length":0,"stats":{"Line":0}},{"line":2197,"address":[6542774,6553414,6546306,6560482,6539238,6525719,6535906,6564038,6574642,6529047,6532390,6571110,6556950,6567574,6549858],"length":1,"stats":{"Line":7}},{"line":2198,"address":[6571023,6571099,6574631,6546219,6525708,6535895,6542763,6542687,6539151,6564027,6528960,6546295,6549847,6560395,6532379,6532303,6556863,6567563,6525632,6560471,6529036,6563951,6553327,6567487,6553403,6574555,6549771,6539227,6556939,6535819],"length":1,"stats":{"Line":14}},{"line":2200,"address":[],"length":0,"stats":{"Line":6}},{"line":2201,"address":[4542163,4545660,4556188,4552691,4552604,4545747,4549316,4542076,4549229,4556275],"length":1,"stats":{"Line":12}},{"line":2203,"address":[6536236,6557292,6560812,6526061,6564380,6553756,6550188,6529389,6543116,6532732,6574972,6567916,6539580,6546636,6571452],"length":1,"stats":{"Line":6}},{"line":2204,"address":[],"length":0,"stats":{"Line":12}},{"line":2205,"address":[],"length":0,"stats":{"Line":0}},{"line":2207,"address":[],"length":0,"stats":{"Line":3}},{"line":2208,"address":[4549738],"length":1,"stats":{"Line":3}},{"line":2209,"address":[],"length":0,"stats":{"Line":6}},{"line":2210,"address":[],"length":0,"stats":{"Line":0}},{"line":2213,"address":[],"length":0,"stats":{"Line":6}},{"line":2214,"address":[6547017,6539961,6550569,6533113,6554137,6564761,6568297,6571833,6575353,6543497,6557673,6561193],"length":1,"stats":{"Line":3}},{"line":2215,"address":[6543429,6554069,6557605,6561124,6533045,6564693,6550500,6539893,6568229,6575284,6571765,6546948],"length":1,"stats":{"Line":3}},{"line":2216,"address":[],"length":0,"stats":{"Line":0}},{"line":2217,"address":[],"length":0,"stats":{"Line":0}},{"line":2220,"address":[6554273,6568433,6550620,6557724,6543548,6561244,6571884,6575489,6526217,6554188,6564812,6571969,6529545,6575404,6557809,6543633,6533164,6547068,6561329,6540012,6568348,6547153,6529701,6564897,6526373,6550705,6536542,6533249,6536386,6540097],"length":1,"stats":{"Line":12}},{"line":2222,"address":[6558372,6540728,6558440,6565528,6537108,6551271,6576123,6554904,6526936,6547719,6561895,6530264,6533812,6565460,6576055,6551339,6569064,6572600,6554836,6544264,6568996,6547787,6533880,6540660,6572532,6561963,6537176,6530332,6527004,6544196],"length":1,"stats":{"Line":12}},{"line":2224,"address":[],"length":0,"stats":{"Line":12}},{"line":2225,"address":[4551052,4547611,4555227,4550658,4551136,4547772,4547688,4554555,4543710,4544104,4547294,4548283,4558300,4551647,4550975,4558139,4554238,4554632,4544699,4544188,4558216,4544027,4558811,4557822,4554716],"length":1,"stats":{"Line":0}},{"line":2226,"address":[],"length":0,"stats":{"Line":0}},{"line":2228,"address":[6584240,6566076,6581888,6581104,6569612,6579520,6580016,6579616,6548355,6581600,6558988,6584736,6562531,6581984,6579712,6534428,6576691,6555452,6527552,6541276,6551907,6580400,6578816,6537738,6573148,6530880,6544812,6580304,6582080,6583552],"length":1,"stats":{"Line":0}},{"line":2229,"address":[6582112,6583584,6580432,6579552,6582016,6581136,6579648,6578848,6579744,6584272,6581920,6580336,6581632,6580048,6584768],"length":1,"stats":{"Line":0}},{"line":2230,"address":[6579762,6584786,6579666,6581938,6579570,6582034,6581650,6580066,6580450,6581154,6578866,6584290,6580354,6583602,6582130],"length":1,"stats":{"Line":0}},{"line":2232,"address":[6541306,6562561,6573178,6577600,6581696,6583168,6580112,6548385,6578000,6555482,6534458,6551937,6566106,6582576,6580912,6579328,6544842,6582384,6583360,6584544,6530910,6559018,6581408,6576721,6584048,6582768,6583648,6527582,6569642,6537768],"length":1,"stats":{"Line":0}},{"line":2233,"address":[],"length":0,"stats":{"Line":0}},{"line":2234,"address":[],"length":0,"stats":{"Line":0}},{"line":2235,"address":[],"length":0,"stats":{"Line":0}},{"line":2238,"address":[],"length":0,"stats":{"Line":0}},{"line":2239,"address":[6537953,6527767,6569827,6555667,6562746,6576906,6531095,6566291,6573363,6552122,6548570,6545027,6559203,6541491,6534643],"length":1,"stats":{"Line":0}},{"line":2240,"address":[4558473,4544286,4551234,4547945,4558398,4551309,4544361,4554814,4547870,4554889],"length":1,"stats":{"Line":0}},{"line":2241,"address":[4544474,4548058,4555002,4558586,4551422],"length":1,"stats":{"Line":0}},{"line":2242,"address":[6570166,6548895,6566630,6559542,6534982,6573702,6531434,6541830,6577231,6545366,6563071,6528106,6556006,6538278,6552447],"length":1,"stats":{"Line":0}},{"line":2245,"address":[],"length":0,"stats":{"Line":6}},{"line":2246,"address":[],"length":0,"stats":{"Line":6}}],"covered":182,"coverable":780},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","common.rs"],"content":"use alloc::vec::Vec;\n\nuse p3_circuit::op::PrimitiveOpType;\nuse p3_circuit::{Circuit, CircuitError};\nuse p3_field::ExtensionField;\nuse p3_uni_stark::{StarkGenericConfig, Val};\nuse p3_util::log2_ceil_usize;\nuse strum::EnumCount;\n\nuse crate::air::{AddAir, ConstAir, MulAir, PublicAir, WitnessAir};\nuse crate::config::StarkField;\nuse crate::field_params::ExtractBinomialW;\nuse crate::{DynamicAirEntry, Poseidon2Config, Poseidon2Prover, TablePacking};\n\n/// Enum wrapper to allow heterogeneous table AIRs in a single batch STARK aggregation.\n///\n/// This enables different AIR types to be collected into a single vector for\n/// batch STARK proving/verification while maintaining type safety.\npub enum CircuitTableAir\u003cSC, const D: usize\u003e\nwhere\n    SC: StarkGenericConfig,\n{\n    Witness(WitnessAir\u003cVal\u003cSC\u003e, D\u003e),\n    Const(ConstAir\u003cVal\u003cSC\u003e, D\u003e),\n    Public(PublicAir\u003cVal\u003cSC\u003e, D\u003e),\n    Add(AddAir\u003cVal\u003cSC\u003e, D\u003e),\n    Mul(MulAir\u003cVal\u003cSC\u003e, D\u003e),\n    Dynamic(DynamicAirEntry\u003cSC\u003e),\n}\n\n/// Non-primitive operation configurations.\n///\n/// This enables the preprocessing of preprocessing data depending on the non-primitive configurations.\npub enum NonPrimitiveConfig {\n    Poseidon2(Poseidon2Config),\n}\n\npub fn get_airs_and_degrees_with_prep\u003c\n    SC: StarkGenericConfig + 'static + Send + Sync,\n    ExtF: ExtensionField\u003cVal\u003cSC\u003e\u003e + ExtractBinomialW\u003cVal\u003cSC\u003e\u003e,\n    const D: usize,\n\u003e(\n    circuit: \u0026Circuit\u003cExtF\u003e,\n    packing: TablePacking,\n    non_primitive_configs: Option\u003c\u0026[NonPrimitiveConfig]\u003e,\n) -\u003e Result\u003cVec\u003c(CircuitTableAir\u003cSC, D\u003e, usize)\u003e, CircuitError\u003e\nwhere\n    Val\u003cSC\u003e: StarkField,\n{\n    let preprocessed: Vec\u003cVec\u003cExtF\u003e\u003e = circuit.generate_preprocessed_columns()?;\n    let w_binomial = ExtF::extract_w();\n    // First, get base field elements for the preprocessed values.\n    let base_prep: Vec\u003cVec\u003cVal\u003cSC\u003e\u003e\u003e = preprocessed\n        .iter()\n        .map(|vals| {\n            vals.iter()\n                .map(|v| v.as_base().ok_or(CircuitError::InvalidPreprocessedValues))\n                .collect::\u003cResult\u003cVec\u003c_\u003e, CircuitError\u003e\u003e()\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e, CircuitError\u003e\u003e()?;\n\n    let default_air = WitnessAir::new(1, 1);\n    let mut table_preps = (0..base_prep.len())\n        .map(|_| (CircuitTableAir::Witness(default_air.clone()), 1))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n    base_prep\n        .iter()\n        .enumerate()\n        .try_for_each(|(idx, prep)| -\u003e Result\u003c(), CircuitError\u003e {\n            if idx \u003c PrimitiveOpType::COUNT {\n                let table = PrimitiveOpType::from(idx);\n                match table {\n                    PrimitiveOpType::Add =\u003e {\n                        // The `- 1` comes from the fact that the first preprocessing column is the multiplicity,\n                        // which we do not need to compute here for `Add`.\n                        let lane_without_multiplicities =\n                            AddAir::\u003cVal\u003cSC\u003e, D\u003e::preprocessed_lane_width() - 1;\n                        assert!(prep.len() % lane_without_multiplicities == 0);\n\n                        let num_ops = prep.len().div_ceil(lane_without_multiplicities);\n                        let add_air = AddAir::new_with_preprocessed(\n                            num_ops,\n                            packing.add_lanes(),\n                            prep.clone(),\n                        );\n                        table_preps[idx] = (\n                            CircuitTableAir::Add(add_air),\n                            log2_ceil_usize(num_ops.div_ceil(packing.add_lanes())),\n                        );\n                    }\n                    PrimitiveOpType::Mul =\u003e {\n                        // The `- 1` comes from the fact that the first preprocessing column is the multiplicity,\n                        // which we do not need to compute here for `Mul`.\n                        let lane_without_multiplicities =\n                            MulAir::\u003cVal\u003cSC\u003e, D\u003e::preprocessed_lane_width() - 1;\n                        assert!(prep.len() % lane_without_multiplicities == 0);\n                        let num_ops = prep.len().div_ceil(lane_without_multiplicities);\n                        let mul_air = if D == 1 {\n                            MulAir::new_with_preprocessed(\n                                num_ops,\n                                packing.mul_lanes(),\n                                prep.clone(),\n                            )\n                        } else {\n                            let w = w_binomial.unwrap();\n                            MulAir::new_binomial_with_preprocessed(\n                                num_ops,\n                                packing.mul_lanes(),\n                                w,\n                                prep.clone(),\n                            )\n                        };\n                        table_preps[idx] = (\n                            CircuitTableAir::Mul(mul_air),\n                            log2_ceil_usize(num_ops.div_ceil(packing.mul_lanes())),\n                        );\n                    }\n                    PrimitiveOpType::Public =\u003e {\n                        let height = prep.len();\n                        let public_air = PublicAir::new_with_preprocessed(height, prep.clone());\n                        table_preps[idx] =\n                            (CircuitTableAir::Public(public_air), log2_ceil_usize(height));\n                    }\n                    PrimitiveOpType::Const =\u003e {\n                        let height = prep.len();\n                        let const_air = ConstAir::new_with_preprocessed(height, prep.clone());\n                        table_preps[idx] =\n                            (CircuitTableAir::Const(const_air), log2_ceil_usize(height));\n                    }\n                    PrimitiveOpType::Witness =\u003e {\n                        let num_witnesses = prep.len();\n                        let witness_air = WitnessAir::new_with_preprocessed(\n                            num_witnesses,\n                            packing.witness_lanes(),\n                            prep.clone(),\n                        );\n                        table_preps[idx] = (\n                            CircuitTableAir::Witness(witness_air),\n                            log2_ceil_usize(num_witnesses.div_ceil(packing.witness_lanes())),\n                        );\n                    }\n                }\n\n                Ok(())\n            } else {\n                let primitive_idx = idx - PrimitiveOpType::COUNT;\n\n                match primitive_idx {\n                    0 =\u003e {\n                        debug_assert!(idx \u003c table_preps.len());\n                        let configs =\n                            non_primitive_configs.ok_or(CircuitError::InvalidPreprocessedValues)?;\n\n                        // Ensure that a Poseidon2 config is provided.\n                        // We only have one type of non-primitive op for now, but we might add more later. The find_map allows for that.\n                        #[allow(clippy::unnecessary_find_map)]\n                        let poseidon2_config = configs.iter().find_map(|config| match config {\n                            NonPrimitiveConfig::Poseidon2(cfg) =\u003e Some(cfg),\n                        });\n\n                        // Get the Poseidon2 permutation air based on the Poseidon2 configuration.\n                        let config =\n                            poseidon2_config.ok_or(CircuitError::InvalidPreprocessedValues)?;\n\n                        let poseidon2_prover = Poseidon2Prover::new(config.clone());\n                        let width = poseidon2_prover.preprocessed_width_from_config();\n                        let poseidon2_wrapper =\n                            poseidon2_prover.wrapper_from_config_with_preprocessed(prep.clone());\n\n                        let poseidon2_wrapper_air: CircuitTableAir\u003cSC, D\u003e =\n                            CircuitTableAir::Dynamic(poseidon2_wrapper);\n\n                        table_preps[idx] = (\n                            poseidon2_wrapper_air,\n                            log2_ceil_usize(prep.len().div_ceil(width)),\n                        );\n\n                        Ok(())\n                    }\n                    _ =\u003e panic!(\"Unknown primitive operation at index {}\", primitive_idx),\n                }\n            }\n        })?;\n\n    Ok(table_preps)\n}\n","traces":[{"line":38,"address":[5056560,5057884,5051120,5052452,5053840,5057892,5056524,5052444,5059244,5055200,5057920,5055164,5056532,5052480,5053816,5053808,5059252,5055172],"length":1,"stats":{"Line":7}},{"line":50,"address":[5051166,5056606,5057966,5055246,5053886,5052526],"length":1,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":14}},{"line":53,"address":[],"length":0,"stats":{"Line":14}},{"line":55,"address":[],"length":0,"stats":{"Line":14}},{"line":56,"address":[],"length":0,"stats":{"Line":7}},{"line":57,"address":[5059433,5059337,5074345,5089296,5089333,5089093,5089136,5064553,5089509,5088912,5089056,5089173,5089216,5064649,5088949,5089253,5089472,5064329],"length":1,"stats":{"Line":21}},{"line":58,"address":[5064662,5064342,5074358,5059350,5064566,5059446],"length":1,"stats":{"Line":7}},{"line":62,"address":[],"length":0,"stats":{"Line":7}},{"line":63,"address":[],"length":0,"stats":{"Line":7}},{"line":64,"address":[2949497,2950221,2950192],"length":1,"stats":{"Line":21}},{"line":66,"address":[],"length":0,"stats":{"Line":14}},{"line":69,"address":[5064759,5074455,5066254,5080622,5069552,5084195,5069623,5059543,5059472,5085692,5056113,5054753,5075950,5079127,5079056,5061044,5071124,5075956,5080628,5066260,5084112,5058833,5057473,5074384,5052033,5064688,5085698,5053397,5061038,5071118],"length":1,"stats":{"Line":21}},{"line":70,"address":[2952991,2950455],"length":1,"stats":{"Line":14}},{"line":71,"address":[],"length":0,"stats":{"Line":7}},{"line":72,"address":[],"length":0,"stats":{"Line":7}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[2952601,2953558,2953598],"length":1,"stats":{"Line":14}},{"line":78,"address":[5082311,5067888,5062672,5072813,5062727,5068275,5063050,5067949,5077584,5082634,5087722,5077962,5082256,5087332,5072752,5073139,5077639,5087394],"length":1,"stats":{"Line":14}},{"line":80,"address":[5062764,5067986,5072850,5087431,5082348,5077676],"length":1,"stats":{"Line":7}},{"line":81,"address":[],"length":0,"stats":{"Line":7}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[2953724],"length":1,"stats":{"Line":7}},{"line":84,"address":[2953785],"length":1,"stats":{"Line":7}},{"line":86,"address":[2954137,2954097],"length":1,"stats":{"Line":7}},{"line":87,"address":[],"length":0,"stats":{"Line":7}},{"line":88,"address":[2953922,2954041],"length":1,"stats":{"Line":14}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":14}},{"line":96,"address":[],"length":0,"stats":{"Line":14}},{"line":97,"address":[],"length":0,"stats":{"Line":7}},{"line":98,"address":[],"length":0,"stats":{"Line":7}},{"line":99,"address":[5078553,5063641,5083225],"length":1,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[5068782,5088231,5073646],"length":1,"stats":{"Line":3}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[2954917,2954880],"length":1,"stats":{"Line":7}},{"line":114,"address":[2954587],"length":1,"stats":{"Line":7}},{"line":115,"address":[5073944,5078718,5074041,5078815,5083390,5063806,5083487,5088634,5063903,5088537,5069177,5069080],"length":1,"stats":{"Line":14}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":7}},{"line":120,"address":[],"length":0,"stats":{"Line":7}},{"line":121,"address":[5062441,5087150,5082025,5087101,5067657,5077402,5067706,5072521,5062490,5072570,5077353,5082074],"length":1,"stats":{"Line":7}},{"line":122,"address":[],"length":0,"stats":{"Line":14}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[2952251],"length":1,"stats":{"Line":7}},{"line":126,"address":[],"length":0,"stats":{"Line":7}},{"line":127,"address":[],"length":0,"stats":{"Line":7}},{"line":128,"address":[2952342,2953268,2953014,2953247],"length":1,"stats":{"Line":14}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[2951932],"length":1,"stats":{"Line":7}},{"line":132,"address":[2952099],"length":1,"stats":{"Line":7}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":7}},{"line":135,"address":[2952042],"length":1,"stats":{"Line":7}},{"line":137,"address":[],"length":0,"stats":{"Line":7}},{"line":138,"address":[5071311,5076143,5061231,5080815,5066447,5085893],"length":1,"stats":{"Line":7}},{"line":139,"address":[],"length":0,"stats":{"Line":14}},{"line":144,"address":[],"length":0,"stats":{"Line":7}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[2950785],"length":1,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[2950967,2955152],"length":1,"stats":{"Line":0}},{"line":158,"address":[2955165],"length":1,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":7}}],"covered":56,"coverable":90},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","config.rs"],"content":"//! STARK proving configurations.\n//!\n//! This module provides STARK configurations for different prime fields.\n//!\n//! # Quick Start\n//!\n//! ```ignore\n//! use p3_circuit_prover::config;\n//!\n//! // Use a preconfigured setup\n//! let config = config::baby_bear()\n//!     .build();\n//! ```\n\nuse core::marker::PhantomData;\n\nuse p3_baby_bear::{BabyBear, Poseidon2BabyBear, default_babybear_poseidon2_16};\nuse p3_challenger::DuplexChallenger;\nuse p3_commit::ExtensionMmcs;\nuse p3_dft::Radix2DitParallel;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{Field, PrimeCharacteristicRing, PrimeField64, TwoAdicField};\nuse p3_fri::{TwoAdicFriPcs, create_benchmark_fri_params};\nuse p3_goldilocks::{Goldilocks, Poseidon2Goldilocks};\nuse p3_koala_bear::{KoalaBear, Poseidon2KoalaBear, default_koalabear_poseidon2_16};\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_symmetric::{\n    CryptographicPermutation, PaddingFreeSponge, PseudoCompressionFunction, TruncatedPermutation,\n};\nuse p3_uni_stark::StarkConfig;\n\n/// Compression function arity (number of inputs per compression).\nconst COMPRESS_ARITY: usize = 2;\n\n/// A STARK configuration with all cryptographic primitives specified.\n///\n/// ### Type Parameters\n/// - `F`: Base field.\n/// - `PermHash`: Permutation function used for sponge hashing (leaves, transcript absorption).\n/// - `PermCompress`: Permutation function used for Merkle tree compression.\n/// - `HASH_PERM_WIDTH`: Width of the hash permutation state.\n/// - `COMPRESS_PERM_WIDTH`: Width of the compression permutation state.\n/// - `RATE`: Number of field elements absorbed per permutation in sponge mode.\n/// - `OUT`: Number of output elements squeezed per permutation.\n/// - `COMPRESS_CHUNK`: Number of elements per compression chunk in Merkle commitments.\n/// - `CHALLENGE_DEGREE`: Extension field degree.\npub type Config\u003c\n    F,\n    PermHash,\n    PermCompress,\n    const HASH_PERM_WIDTH: usize,\n    const COMPRESS_PERM_WIDTH: usize,\n    const RATE: usize,\n    const OUT: usize,\n    const COMPRESS_CHUNK: usize,\n    const CHALLENGE_DEGREE: usize,\n\u003e = StarkConfig\u003c\n    TwoAdicFriPcs\u003c\n        F,\n        Radix2DitParallel\u003cF\u003e,\n        MerkleTreeMmcs\u003c\n            F,\n            F,\n            PaddingFreeSponge\u003cPermHash, HASH_PERM_WIDTH, RATE, OUT\u003e,\n            TruncatedPermutation\u003cPermCompress, COMPRESS_ARITY, COMPRESS_CHUNK, COMPRESS_PERM_WIDTH\u003e,\n            COMPRESS_CHUNK,\n        \u003e,\n        ExtensionMmcs\u003c\n            F,\n            BinomialExtensionField\u003cF, CHALLENGE_DEGREE\u003e,\n            MerkleTreeMmcs\u003c\n                F,\n                F,\n                PaddingFreeSponge\u003cPermHash, HASH_PERM_WIDTH, RATE, OUT\u003e,\n                TruncatedPermutation\u003c\n                    PermCompress,\n                    COMPRESS_ARITY,\n                    COMPRESS_CHUNK,\n                    COMPRESS_PERM_WIDTH,\n                \u003e,\n                COMPRESS_CHUNK,\n            \u003e,\n        \u003e,\n    \u003e,\n    BinomialExtensionField\u003cF, CHALLENGE_DEGREE\u003e,\n    DuplexChallenger\u003cF, PermHash, HASH_PERM_WIDTH, RATE\u003e,\n\u003e;\n\n/// Configuration builder for STARK provers.\npub struct ConfigBuilder\u003c\n    F,\n    PermHash,\n    PermCompress,\n    const HASH_PERM_WIDTH: usize,\n    const COMPRESS_PERM_WIDTH: usize,\n    const RATE: usize,\n    const OUT: usize,\n    const COMPRESS_CHUNK: usize,\n    const CHALLENGE_DEGREE: usize,\n\u003e {\n    perm_hash: PermHash,\n    perm_compress: PermCompress,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003c\n    F,\n    PermHash,\n    PermCompress,\n    const HASH_PERM_WIDTH: usize,\n    const COMPRESS_PERM_WIDTH: usize,\n    const RATE: usize,\n    const OUT: usize,\n    const COMPRESS_CHUNK: usize,\n    const CHALLENGE_DEGREE: usize,\n\u003e\n    ConfigBuilder\u003c\n        F,\n        PermHash,\n        PermCompress,\n        HASH_PERM_WIDTH,\n        COMPRESS_PERM_WIDTH,\n        RATE,\n        OUT,\n        COMPRESS_CHUNK,\n        CHALLENGE_DEGREE,\n    \u003e\nwhere\n    F: Field,\n    PermHash: Clone + CryptographicPermutation\u003c[F; HASH_PERM_WIDTH]\u003e,\n    PermCompress: Clone + CryptographicPermutation\u003c[F; COMPRESS_PERM_WIDTH]\u003e,\n{\n    const fn new(perm_hash: PermHash, perm_compress: PermCompress) -\u003e Self {\n        Self {\n            perm_hash,\n            perm_compress,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Builds the final STARK configuration.\n    pub fn build(\n        self,\n    ) -\u003e Config\u003c\n        F,\n        PermHash,\n        PermCompress,\n        HASH_PERM_WIDTH,\n        COMPRESS_PERM_WIDTH,\n        RATE,\n        OUT,\n        COMPRESS_CHUNK,\n        CHALLENGE_DEGREE,\n    \u003e {\n        type Hash\u003cPerm, const PERM_WIDTH: usize, const RATE: usize, const OUT: usize\u003e =\n            PaddingFreeSponge\u003cPerm, PERM_WIDTH, RATE, OUT\u003e;\n        type Compress\u003cPerm, const PERM_WIDTH: usize, const COMPRESS_CHUNK: usize\u003e =\n            TruncatedPermutation\u003cPerm, COMPRESS_ARITY, COMPRESS_CHUNK, PERM_WIDTH\u003e;\n\n        let hash = Hash::\u003cPermHash, HASH_PERM_WIDTH, RATE, OUT\u003e::new(self.perm_hash.clone());\n        let compress = Compress::\u003cPermCompress, COMPRESS_PERM_WIDTH, COMPRESS_CHUNK\u003e::new(\n            self.perm_compress.clone(),\n        );\n        let val_mmcs = MerkleTreeMmcs::new(hash, compress);\n        let challenge_mmcs = ExtensionMmcs::new(val_mmcs.clone());\n        let dft = Radix2DitParallel::default();\n        let fri_params = create_benchmark_fri_params(challenge_mmcs);\n        let pcs = TwoAdicFriPcs::new(dft, val_mmcs, fri_params);\n        let challenger = DuplexChallenger::new(self.perm_hash);\n\n        StarkConfig::new(pcs, challenger)\n    }\n\n    /// Creates the compression function for this configuration.\n    pub fn compression_function(\n        \u0026self,\n    ) -\u003e TruncatedPermutation\u003cPermCompress, COMPRESS_ARITY, COMPRESS_CHUNK, COMPRESS_PERM_WIDTH\u003e\n    {\n        TruncatedPermutation::new(self.perm_compress.clone())\n    }\n}\n\n/// Creates a standard BabyBear configuration.\n///\n/// BabyBear is a 31-bit prime field (2^31 - 2^27 + 1).\n///\n/// # Parameters\n/// - **Hash permutation width**: 16 (appropriate for 32-bit fields)\n/// - **Compression permutation width**: 16\n/// - **Rate**: 8 (256 bits / 32 bits per element)\n/// - **Output size**: 8 (256 bits / 32 bits per element)\n/// - **Challenge degree**: 4\n///\n/// # Examples\n///\n/// ```ignore\n/// let config = config::baby_bear().build();\n/// let prover = BatchStarkProver::new(config);\n/// ```\n#[inline]\npub fn baby_bear()\n-\u003e ConfigBuilder\u003cBabyBear, Poseidon2BabyBear\u003c16\u003e, Poseidon2BabyBear\u003c16\u003e, 16, 16, 8, 8, 8, 4\u003e {\n    let perm = default_babybear_poseidon2_16();\n    ConfigBuilder::new(perm.clone(), perm)\n}\n\n/// Creates the standard BabyBear compression function.\n///\n/// # Parameters\n/// - **Input arrays**: 2\n/// - **Elements per array**: 8 (256 bits / 32 bits per element)\n/// - **Output size**: 8 BabyBear elements (256 bits)\n#[inline]\npub fn baby_bear_compression() -\u003e impl PseudoCompressionFunction\u003c[BabyBear; 8], 2\u003e {\n    baby_bear().compression_function()\n}\n\n/// Creates a standard KoalaBear configuration.\n///\n/// KoalaBear is a 31-bit prime field (2^31 - 2^24 + 1).\n///\n/// # Parameters\n/// - **Hash permutation width**: 16 (appropriate for 32-bit fields)\n/// - **Compression permutation width**: 16\n/// - **Rate**: 8 (256 bits / 32 bits per element)\n/// - **Output size**: 8 (256 bits / 32 bits per element)\n/// - **Challenge degree**: 4\n///\n/// # Examples\n///\n/// ```ignore\n/// let config = config::koala_bear().build();\n/// let prover = BatchStarkProver::new(config);\n/// ```\n#[inline]\npub fn koala_bear()\n-\u003e ConfigBuilder\u003cKoalaBear, Poseidon2KoalaBear\u003c16\u003e, Poseidon2KoalaBear\u003c16\u003e, 16, 16, 8, 8, 8, 4\u003e {\n    let perm = default_koalabear_poseidon2_16();\n    ConfigBuilder::new(perm.clone(), perm)\n}\n\n/// Creates the standard KoalaBear compression function.\n///\n/// # Parameters\n/// - **Input arrays**: 2\n/// - **Elements per array**: 8 (256 bits / 32 bits per element)\n/// - **Output size**: 8 KoalaBear elements (256 bits)\n#[inline]\npub fn koala_bear_compression() -\u003e impl PseudoCompressionFunction\u003c[KoalaBear; 8], 2\u003e {\n    koala_bear().compression_function()\n}\n\n/// Creates a standard Goldilocks configuration.\n///\n/// Goldilocks is a 64-bit prime field (2^64 - 2^32 + 1).\n///\n/// # Parameters\n/// - **Hash permutation width**: 8 (appropriate for 64-bit fields)\n/// - **Compression permutation width**: 8\n/// - **Rate**: 4 (256 bits / 64 bits per element)\n/// - **Output size**: 4 (256 bits / 64 bits per element)\n/// - **Challenge degree**: 2\n///\n/// # Examples\n///\n/// ```ignore\n/// let config = config::goldilocks().build();\n/// let prover = BatchStarkProver::new(config);\n/// ```\n#[inline]\npub fn goldilocks()\n-\u003e ConfigBuilder\u003cGoldilocks, Poseidon2Goldilocks\u003c8\u003e, Poseidon2Goldilocks\u003c8\u003e, 8, 8, 4, 4, 4, 2\u003e {\n    use rand::SeedableRng;\n    let mut rng = rand::rngs::SmallRng::seed_from_u64(1);\n    let perm = p3_goldilocks::Poseidon2Goldilocks::\u003c8\u003e::new_from_rng_128(\u0026mut rng);\n    ConfigBuilder::new(perm.clone(), perm)\n}\n\n/// Creates the standard Goldilocks compression function.\n///\n/// # Parameters\n/// - **Input arrays**: 2\n/// - **Elements per array**: 4 (256 bits / 64 bits per element)\n/// - **Output size**: 4 Goldilocks elements (256 bits)\n#[inline]\npub fn goldilocks_compression() -\u003e impl PseudoCompressionFunction\u003c[Goldilocks; 4], 2\u003e {\n    goldilocks().compression_function()\n}\n\n/// Type alias for BabyBear STARK configuration.\npub type BabyBearConfig =\n    Config\u003cBabyBear, Poseidon2BabyBear\u003c16\u003e, Poseidon2BabyBear\u003c16\u003e, 16, 16, 8, 8, 8, 4\u003e;\n\n/// Type alias for KoalaBear STARK configuration.\npub type KoalaBearConfig =\n    Config\u003cKoalaBear, Poseidon2KoalaBear\u003c16\u003e, Poseidon2KoalaBear\u003c16\u003e, 16, 16, 8, 8, 8, 4\u003e;\n\n/// Type alias for Goldilocks STARK configuration.\npub type GoldilocksConfig =\n    Config\u003cGoldilocks, Poseidon2Goldilocks\u003c8\u003e, Poseidon2Goldilocks\u003c8\u003e, 8, 8, 4, 4, 4, 2\u003e;\n\n/// Trait bounds for STARK-compatible fields.\npub trait StarkField: Field + PrimeCharacteristicRing + TwoAdicField + PrimeField64 {}\n\nimpl\u003cF\u003e StarkField for F where F: Field + PrimeCharacteristicRing + TwoAdicField + PrimeField64 {}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn all_fields_configs_compile() {\n        let _bb: BabyBearConfig = baby_bear().build();\n        let _kb: KoalaBearConfig = koala_bear().build();\n        let _gl: GoldilocksConfig = goldilocks().build();\n    }\n\n    #[test]\n    fn compression_function_works() {\n        let _compress = baby_bear_compression();\n        let _compress = koala_bear_compression();\n        let _compress = goldilocks_compression();\n    }\n}\n","traces":[{"line":133,"address":[3528160,3528096,3528224],"length":1,"stats":{"Line":3}},{"line":142,"address":[6618080,6619232,6621408,6620256,6619104,6620359,6620384,6621511,6619207],"length":1,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":162,"address":[6618241,6619393,6620545],"length":1,"stats":{"Line":3}},{"line":164,"address":[6618321,6619473,6620625],"length":1,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":6}},{"line":166,"address":[6619688,6618536,6620840],"length":1,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[6620994,6619842,6618690],"length":1,"stats":{"Line":3}},{"line":169,"address":[6618822,6619974,6621126],"length":1,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[3643808,3643872,3643744],"length":1,"stats":{"Line":3}},{"line":179,"address":[6617779,6617843,6617715],"length":1,"stats":{"Line":3}},{"line":201,"address":[3522864,3523101,3523130],"length":1,"stats":{"Line":1}},{"line":203,"address":[2281121],"length":1,"stats":{"Line":1}},{"line":204,"address":[3528345,3528407],"length":1,"stats":{"Line":2}},{"line":214,"address":[3527585,3527472,3527591],"length":1,"stats":{"Line":1}},{"line":215,"address":[2280314],"length":1,"stats":{"Line":1}},{"line":236,"address":[7718688,7718925,7718954],"length":1,"stats":{"Line":1}},{"line":238,"address":[3527217],"length":1,"stats":{"Line":1}},{"line":239,"address":[6617155,6617102],"length":1,"stats":{"Line":2}},{"line":249,"address":[7719248,7719367,7719361],"length":1,"stats":{"Line":1}},{"line":250,"address":[4825290],"length":1,"stats":{"Line":1}},{"line":271,"address":[4904205,4904234,4903936],"length":1,"stats":{"Line":1}},{"line":274,"address":[3642752],"length":1,"stats":{"Line":1}},{"line":275,"address":[4903985],"length":1,"stats":{"Line":1}},{"line":276,"address":[7718465,7718529],"length":1,"stats":{"Line":2}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[4904682],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":33},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","field_params.rs"],"content":"//! Utilities for extracting extension field parameters.\n//!\n//! Glossary:\n//! - `F`: Base field (BabyBear/KoalaBear/Goldilocks) that extension fields are built over.\n//! - `EF`: Element field for circuit traces. If `EF = F`, there is no binomial parameter. If\n//!   `EF = BinomialExtensionField\u003cF, D\u003e`, then there is a binomial parameter `W` with `x^D = W`.\n//! - `D`: Element-field extension degree.\n//!\n//! Provides traits to dynamically determine binomial extension parameters\n//! from field types at runtime, supporting both base fields and extension fields.\n\nuse p3_field::Field;\nuse p3_field::extension::{BinomialExtensionField, BinomiallyExtendable};\n\n/// Extract binomial parameters from field types.\n///\n/// Enables runtime detection of extension field parameters without\n/// requiring compile-time knowledge of the field structure.\npub trait ExtractBinomialW\u003cF: Field\u003e {\n    /// Extract the binomial parameter W for the current extension degree (e.g., x^D = W).\n    /// Returns None for base fields, Some(W) for supported binomial extensions.\n    fn extract_w() -\u003e Option\u003cF\u003e;\n}\n\n/// When the element field is the same as the base field (no extension), there's no binomial parameter W.\nimpl\u003cF\u003e ExtractBinomialW\u003cF\u003e for F\nwhere\n    F: Field,\n{\n    fn extract_w() -\u003e Option\u003cF\u003e {\n        None\n    }\n}\n\n/// Binomial extension fields (for any supported degree D) provide their parameter W.\nimpl\u003cF, const D: usize\u003e ExtractBinomialW\u003cF\u003e for BinomialExtensionField\u003cF, D\u003e\nwhere\n    F: Field + BinomiallyExtendable\u003cD\u003e,\n{\n    fn extract_w() -\u003e Option\u003cF\u003e {\n        Some(F::W)\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":3}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":4},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","circuit-prover","src","lib.rs"],"content":"//! Plonky3 circuit prover (PoC): generic over base field and permutation.\n//!\n//! Generics glossary used across this crate:\n//! - `F`: Prover/verifier base field (BabyBear/KoalaBear/Goldilocks). PCS and FFTs operate over `F`.\n//! - `P`: Cryptographic permutation over `F` used by hash/compress and the challenger.\n//! - `EF`: Element field in circuit traces. Either `F` (base) or `BinomialExtensionField\u003cF, D\u003e`.\n//! - `D`: Element-field extension degree. Must equal `EF::DIMENSION`. AIRs are parameterized as `\u003cF, D\u003e`.\n//! - `CD`: FRI challenge field degree, independent of `D`.\n//!\n//! - Build a field-specific config via `config::{babybear_config, koalabear_config, goldilocks_config}`.\n//! - Create a `BatchStarkProver` from that config.\n//! - Generate traces from a `p3_circuit::Circuit` runner and prove/verify.\n//!\n//! Example (BabyBear):\n//!\n//! ```ignore\n//! use p3_baby_bear::BabyBear;\n//! use p3_circuit::builder::CircuitBuilder;\n//! use p3_circuit_prover::config::babybear_config::build_standard_config_babybear;\n//! use p3_circuit_prover::BatchStarkProver;\n//!\n//! let mut builder = CircuitBuilder::\u003cBabyBear\u003e::new();\n//! let x = builder.add_public_input();\n//! let y = builder.add_public_input();\n//! let z = builder.add(x, y);\n//! builder.assert_zero(builder.sub(z, builder.add_const(BabyBear::from_u64(3))));\n//! let circuit = builder.build();\n//! let mut runner = circuit.runner();\n//! runner.set_public_inputs(\u0026[BabyBear::from_u64(1), BabyBear::from_u64(2)]).unwrap();\n//! let traces = runner.run().unwrap();\n//! let cfg = build_standard_config_babybear();\n//! let prover = BatchStarkProver::new(cfg);\n//! let proof = prover.prove_all_tables(\u0026traces).unwrap();\n//! prover.verify_all_tables(\u0026proof).unwrap();\n//! ```\n#![no_std]\n\nextern crate alloc;\n\npub mod air;\npub mod batch_stark_prover;\npub mod common;\npub mod config;\npub mod field_params;\n\n// Re-export main API\npub use batch_stark_prover::{\n    BatchStarkProof, BatchStarkProver, BatchTableInstance, DynamicAirEntry, NonPrimitiveTableEntry,\n    Poseidon2Config, Poseidon2Prover, TablePacking, TableProver,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","field-air","src","main.rs"],"content":"pub fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":1,"address":[401760,401792],"length":1,"stats":{"Line":1}},{"line":2,"address":[401796],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","fri-air","src","main.rs"],"content":"pub fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":1,"address":[401792,401760],"length":1,"stats":{"Line":1}},{"line":2,"address":[401796],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","interpolation-air","src","main.rs"],"content":"pub fn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":1,"address":[401792,401760],"length":1,"stats":{"Line":1}},{"line":2,"address":[401796],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","poseidon2-circuit-air","src","air.rs"],"content":"use alloc::string::ToString;\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::borrow::Borrow;\nuse core::iter;\nuse core::mem::MaybeUninit;\n\nuse p3_air::{\n    Air, AirBuilder, AirBuilderWithPublicValues, BaseAir, PairBuilder, PermutationAirBuilder,\n};\nuse p3_circuit::tables::{Poseidon2CircuitRow, Poseidon2CircuitTrace};\nuse p3_field::{Field, PrimeCharacteristicRing, PrimeField};\nuse p3_lookup::lookup_traits::{AirLookupHandler, Direction, Kind, Lookup};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_maybe_rayon::prelude::*;\nuse p3_poseidon2::GenericPoseidon2LinearLayers;\nuse p3_poseidon2_air::{Poseidon2Air, Poseidon2Cols, RoundConstants, generate_trace_rows_for_perm};\nuse p3_symmetric::CryptographicPermutation;\nuse p3_uni_stark::{SubAirBuilder, SymbolicAirBuilder, SymbolicExpression, SymbolicVariable};\n\nuse crate::columns::{POSEIDON2_LIMBS, POSEIDON2_PUBLIC_OUTPUT_LIMBS};\nuse crate::{Poseidon2CircuitCols, num_cols};\n\n/// Extends the Poseidon2 AIR with recursion circuit-specific columns and constraints.\n///\n/// This implements the Poseidon2 Permutation Table specification.\n/// See: https://github.com/Plonky3/Plonky3-recursion/discussions/186\n///\n/// The AIR enforces:\n/// - Poseidon2 permutation constraint: out[0..3] = Poseidon2(in[0..3])\n/// - Chaining rules for normal sponge and Merkle-path modes\n/// - MMCS index accumulator updates\n///\n/// Assumes the field size is at least 16 bits.\n///\n/// SPECIFIC ASSUMPTIONS:\n/// - Memory elements from the witness table are extension elements of degree D.\n/// - RATE and CAPACITY are the number of extension elements in the rate/capacity.\n/// - WIDTH is the number of field elements in the state, i.e., (RATE + CAPACITY) * D.\n#[derive(Debug)]\npub struct Poseidon2CircuitAir\u003c\n    F: PrimeCharacteristicRing,\n    LinearLayers,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e {\n    p3_poseidon2: Poseidon2Air\u003c\n        F,\n        LinearLayers,\n        WIDTH,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e,\n    /// Current number of lookup columns registered.\n    pub num_lookup_cols: usize,\n    /// Preprocessed values for the AIR. These values are only needed by the prover. During verification, the `Vec` can be empty.\n    preprocessed: Vec\u003cF\u003e,\n}\n\npub const fn poseidon2_preprocessed_width() -\u003e usize {\n    // Witness index, `in_ctl`, `normal_chain_sel` and `merkle_chain_sel` for all input limbs, witness index and `out_ctl` for all output limbs, `mmcs_index_sum_ctl`, `new_start` and `merkle_path`.\n    4 * POSEIDON2_LIMBS + 2 * POSEIDON2_PUBLIC_OUTPUT_LIMBS + 3\n}\n\nimpl\u003c\n    F: PrimeField,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e\n    Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e\n{\n    pub const fn new(\n        constants: RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n    ) -\u003e Self {\n        const {\n            assert!(CAPACITY_EXT + RATE_EXT == WIDTH_EXT);\n            assert!(WIDTH_EXT * D == WIDTH);\n        }\n\n        Self {\n            p3_poseidon2: Poseidon2Air::new(constants),\n            num_lookup_cols: 0,\n            preprocessed: Vec::new(),\n        }\n    }\n\n    pub const fn new_with_preprocessed(\n        constants: RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n        preprocessed: Vec\u003cF\u003e,\n    ) -\u003e Self {\n        const {\n            assert!(CAPACITY_EXT + RATE_EXT == WIDTH_EXT);\n            assert!(WIDTH_EXT * D == WIDTH);\n        }\n\n        Self {\n            p3_poseidon2: Poseidon2Air::new(constants),\n            num_lookup_cols: 0,\n            preprocessed,\n        }\n    }\n\n    pub const fn preprocessed_width() -\u003e usize {\n        poseidon2_preprocessed_width()\n    }\n\n    pub fn generate_trace_rows\u003cP: CryptographicPermutation\u003c[F; WIDTH]\u003e\u003e(\n        \u0026self,\n        sponge_ops: \u0026Poseidon2CircuitTrace\u003cF\u003e,\n        constants: \u0026RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n        extra_capacity_bits: usize,\n        perm: \u0026P,\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\n        let n = sponge_ops.len();\n        assert!(\n            n.is_power_of_two(),\n            \"Callers expected to pad inputs to a power of two\"\n        );\n\n        let p2_ncols = p3_poseidon2_air::num_cols::\u003c\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e();\n        let ncols = self.width();\n        let circuit_ncols = ncols - p2_ncols;\n\n        // We allocate the final vector immediately with uninitialized memory.\n        //\n        // The extra capacity bits only enlarges the Poseidon2 columns, not the circuit columns.\n        let mut trace_vec: Vec\u003cF\u003e =\n            Vec::with_capacity(n * ((p2_ncols \u003c\u003c extra_capacity_bits) + circuit_ncols));\n        let trace_slice = trace_vec.spare_capacity_mut();\n\n        // We need a lightweight vector to store the state inputs for the parallel pass.\n        //\n        // This is much smaller than the full trace (WIDTH vs NUM_COLS).\n        let mut inputs = Vec::with_capacity(n);\n        let mut prev_output: Option\u003c[F; WIDTH]\u003e = None;\n        let mut prev_mmcs_index_sum = F::ZERO;\n\n        // Split slice into rows\n        let rows = trace_slice[..n * ncols].chunks_exact_mut(ncols);\n\n        for (op, row) in sponge_ops.iter().zip(rows) {\n            let Poseidon2CircuitRow {\n                new_start,\n                merkle_path,\n                mmcs_bit,\n                mmcs_index_sum,\n                input_values,\n                in_ctl,\n                ..\n            } = op;\n\n            let mut padded_inputs = [F::ZERO; WIDTH];\n            for (dst, src) in padded_inputs\n                .iter_mut()\n                .zip(\n                    input_values\n                        .iter()\n                        .copied()\n                        .chain(core::iter::repeat(F::ZERO)),\n                )\n                .take(WIDTH)\n            {\n                *dst = src;\n            }\n\n            // Apply chaining rules.\n            // NOTE: For rows with new_start = false:\n            // - Sponge mode (merkle_path = 0): all limbs come from the previous output unless\n            //   a limb is exposed via in_ctl, in which case the provided input overrides it.\n            // - Merkle mode (merkle_path = 1): the previous digest is always the previous output limbs 0-1.\n            //   If mmcs_bit = 0 (previous digest is left child), chain into input limbs 0-1; input limbs 2-3 come from inputs.\n            //   If mmcs_bit = 1 (previous digest is right child), chain into input limbs 2-3; input limbs 0-1 come from inputs.\n            // - If in_ctl[i] = 1, that limb is NOT chained and comes from CTL/witness instead.\n            //   The AIR constraints will enforce this (chaining is gated by 1 - in_ctl[i]).\n            let mut state = padded_inputs;\n            let i = inputs.len();\n            if i \u003e 0 \u0026\u0026 !*new_start {\n                if *merkle_path {\n                    // Merkle-path mode: the previous digest is always the previous row's out[0..1].\n                    // `mmcs_bit` selects whether that digest is the left (0) or right (1) child:\n                    // - bit=0: chain into input limbs 0..1\n                    // - bit=1: chain into input limbs 2..3\n                    if let Some(prev_out) = prev_output {\n                        if !*mmcs_bit {\n                            if !in_ctl[0] {\n                                state[0..D].copy_from_slice(\u0026prev_out[0..D]);\n                            }\n                            if !in_ctl[1] {\n                                state[D..2 * D].copy_from_slice(\u0026prev_out[D..2 * D]);\n                            }\n                        } else {\n                            if !in_ctl[2] {\n                                state[2 * D..3 * D].copy_from_slice(\u0026prev_out[0..D]);\n                            }\n                            if !in_ctl[3] {\n                                state[3 * D..4 * D].copy_from_slice(\u0026prev_out[D..2 * D]);\n                            }\n                        }\n                    }\n                } else {\n                    // Normal sponge mode: in_{r+1}[i] = out_r[i] for i = 0..3\n                    if let Some(prev_out) = prev_output {\n                        state\n                            .chunks_exact_mut(D)\n                            .zip(prev_out.chunks_exact(D))\n                            .zip(in_ctl.iter())\n                            .for_each(|((dst, src), ctl)| {\n                                if !*ctl {\n                                    dst.copy_from_slice(src);\n                                }\n                            });\n                    }\n                }\n            }\n            // If new_start = 1: no chaining, input determined solely by CTL\n\n            // Update MMCS index accumulator\n            let acc = if i \u003e 0 \u0026\u0026 *merkle_path \u0026\u0026 !*new_start {\n                // mmcs_index_sum_{r+1} = mmcs_index_sum_r * 2 + mmcs_bit_r\n                prev_mmcs_index_sum + prev_mmcs_index_sum + F::from_bool(*mmcs_bit)\n            } else {\n                // Reset / non-Merkle behavior.\n                // The AIR does not constrain mmcs_index_sum on these rows;\n                // we simply use the value stored in the op.\n                *mmcs_index_sum\n            };\n            prev_mmcs_index_sum = acc;\n\n            let (_p2_part, circuit_part) = row.split_at_mut(p2_ncols);\n\n            circuit_part[0].write(F::from_bool(*mmcs_bit));\n            circuit_part[1].write(acc);\n\n            // Save the state to be used as input for the heavy Poseidon2 trace generation\n            inputs.push(state);\n            prev_output = Some(perm.permute(state));\n        }\n\n        // Poseidon2 trace generation\n        //\n        // Now that we have the inputs, we can generate the expensive Poseidon2 columns in parallel.\n\n        trace_slice[..n * ncols]\n            .par_chunks_exact_mut(ncols)\n            .zip(inputs.into_par_iter())\n            .for_each(|(row, input)| {\n                let (p2_part, _circuit_part) = row.split_at_mut(p2_ncols);\n\n                // Align the raw field elements to the Poseidon2Cols struct\n                let (prefix, p2_cols, suffix) = unsafe {\n                    p2_part.align_to_mut::\u003cPoseidon2Cols\u003c\n                        MaybeUninit\u003cF\u003e,\n                        WIDTH,\n                        SBOX_DEGREE,\n                        SBOX_REGISTERS,\n                        HALF_FULL_ROUNDS,\n                        PARTIAL_ROUNDS,\n                    \u003e\u003e()\n                };\n\n                // Sanity checks to ensure memory layout is what we expect\n                debug_assert!(prefix.is_empty(), \"Alignment mismatch\");\n                debug_assert!(suffix.is_empty(), \"Alignment mismatch\");\n                debug_assert_eq!(p2_cols.len(), 1);\n\n                // Generate the heavy trace\n                generate_trace_rows_for_perm::\u003c\n                    F,\n                    LinearLayers,\n                    WIDTH,\n                    SBOX_DEGREE,\n                    SBOX_REGISTERS,\n                    HALF_FULL_ROUNDS,\n                    PARTIAL_ROUNDS,\n                \u003e(\u0026mut p2_cols[0], input, constants);\n            });\n\n        // SAFETY: We have written to all columns in the slice [0..n*ncols].\n        // 1. Circuit columns were written in the sequential loop.\n        // 2. Poseidon2 columns were written in the parallel loop.\n        unsafe {\n            trace_vec.set_len(n * ncols);\n        }\n\n        RowMajorMatrix::new(trace_vec, ncols)\n    }\n}\n\nimpl\u003c\n    F: PrimeField + Sync,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e + Sync,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e BaseAir\u003cF\u003e\n    for Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e\n{\n    fn width(\u0026self) -\u003e usize {\n        num_cols::\u003c\n            Poseidon2Cols\u003cu8, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\n        \u003e()\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\n        debug_assert!(\n            self.preprocessed\n                .len()\n                .is_multiple_of(Self::preprocessed_width()),\n            \"Preprocessed trace length is not a multiple of preprocessed width. Expected multiple of {}, got {}\",\n            Self::preprocessed_width(),\n            self.preprocessed.len(),\n        );\n\n        let padded_height = self\n            .preprocessed\n            .len()\n            .div_ceil(Self::preprocessed_width())\n            .next_power_of_two()\n            * Self::preprocessed_width();\n        let mut preprocessed = self.preprocessed.clone();\n        preprocessed.resize(padded_height, F::ZERO);\n\n        Some(RowMajorMatrix::new(\n            preprocessed,\n            Self::preprocessed_width(),\n        ))\n    }\n}\n\npub fn extract_preprocessed_from_operations\u003cF: Field, OF: Field\u003e(\n    operations: \u0026[Poseidon2CircuitRow\u003cOF\u003e],\n) -\u003e Vec\u003cF\u003e {\n    let mut preprocessed = Vec::with_capacity(operations.len() * poseidon2_preprocessed_width());\n\n    for operation in operations {\n        let Poseidon2CircuitRow {\n            in_ctl,\n            input_indices,\n            out_ctl,\n            output_indices,\n            mmcs_index_sum_idx,\n            new_start,\n            merkle_path,\n            ..\n        } = operation;\n\n        // One row of preprocessed values is of the form:\n        // [input_indices[0], in_ctl[0], normal_chain_sel[0], merkle_chain_sel[0], ..., output_indices[1], out_ctl[1], output_indices[2], out_ctl[2], mmcs_index_sum_idx, new_start, merkle_path]\n        in_ctl\n            .iter()\n            .zip(input_indices.iter())\n            .for_each(|(ctl, idx)| {\n                preprocessed.extend(\u0026[F::from_u32(*idx), F::from_bool(*ctl)]);\n                let normal_chain_sel = if !*new_start \u0026\u0026 !*merkle_path \u0026\u0026 !ctl {\n                    F::ONE\n                } else {\n                    F::ZERO\n                };\n\n                preprocessed.push(normal_chain_sel);\n\n                // In merkle mode:\n                // - When mmcs_bit = 0: limbs 0-1 are chained, limbs 2-3 are private (sibling)\n                // - When mmcs_bit = 1: limbs 2-3 are chained, limbs 0-1 are private (sibling)\n                let merkle_chain_sel = if !new_start \u0026\u0026 *merkle_path \u0026\u0026 !ctl {\n                    F::ONE\n                } else {\n                    F::ZERO\n                };\n                preprocessed.push(merkle_chain_sel);\n            });\n        out_ctl\n            .iter()\n            .zip(output_indices.iter())\n            .for_each(|(ctl, idx)| {\n                preprocessed.extend(\u0026[F::from_u32(*idx), F::from_bool(*ctl)]);\n            });\n        preprocessed.push(F::from_u64(*mmcs_index_sum_idx as u64));\n        preprocessed.push(F::from_bool(*new_start));\n        preprocessed.push(F::from_bool(*merkle_path));\n    }\n\n    preprocessed\n}\n\npub(crate) fn eval\u003c\n    AB: PairBuilder,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e(\n    air: \u0026Poseidon2CircuitAir\u003c\n        AB::F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e,\n    builder: \u0026mut AB,\n    local: \u0026Poseidon2CircuitCols\u003c\n        AB::Var,\n        Poseidon2Cols\u003c\n            AB::Var,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n    \u003e,\n    next: \u0026Poseidon2CircuitCols\u003c\n        AB::Var,\n        Poseidon2Cols\u003c\n            AB::Var,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n    \u003e,\n    next_preprocessed: \u0026[AB::Var],\n) {\n    // Control flags (new_start, merkle_path, in_ctl, out_ctl) are preprocessed columns,\n    // so they are known to the verifier and don't need bool assertions.\n    // Note: mmcs_bit is a value column (not transparent) because it's used in constraints\n    // with the value column mmcs_index_sum.\n\n    let next_bit = next.mmcs_bit.clone();\n    let local_out = \u0026local.poseidon2.ending_full_rounds[HALF_FULL_ROUNDS - 1].post;\n    let next_in = \u0026next.poseidon2.inputs;\n\n    // mmcs_bit should always be boolean.\n    builder.assert_bool(local.mmcs_bit.clone());\n\n    // Preprocessing layout:\n    // [in_idx[0], in_ctl[0], normal_chain_sel[0], merkle_chain_sel[0], ..., in_idx[3], in_ctl[3], normal_chain_sel[3], merkle_chain_sel[3],\n    //  out_idx[0], out_ctl[0], out_idx[1], out_ctl[1], mmcs_index_sum_ctl_idx, new_start, merkle_path]\n    // The following corresponds to the size of the data related to one input limb (in_idx[i], in_ctl[i], normal_chain_sel[i], merkle_chain_sel[i]).\n    let preprocessing_limb_data_size = 4;\n    let normal_chain_idx = 2;\n    let merkle_chain_idx = 3;\n    let new_start_idx = 4 * POSEIDON2_LIMBS + 2 * POSEIDON2_PUBLIC_OUTPUT_LIMBS + 1;\n    let merkle_path_idx = new_start_idx + 1;\n    // Normal chaining.\n    // If new_start_{r+1} = 0 and merkle_path_{r+1} = 0:\n    //   in_{r+1}[i] = out_r[i] for i = 0..3\n    // BUT: If in_ctl[i] = 1, CTL overrides chaining (limb is not chained).\n    // Chaining only applies when in_ctl[limb] = 0.\n    for limb in 0..POSEIDON2_LIMBS {\n        for d in 0..D {\n            let idx = limb * D + d;\n            let gate =\n                next_preprocessed[preprocessing_limb_data_size * limb + normal_chain_idx].clone();\n            builder\n                .when_transition()\n                .when(gate)\n                .assert_zero(next_in[idx].clone() - local_out[idx].clone());\n        }\n    }\n\n    // Merkle-path chaining.\n    // If new_start_{r+1} = 0 and merkle_path_{r+1} = 1:\n    //   - If mmcs_bit_{r+1} = 0 (left = previous hash): in_{r+1}[0] = out_r[0], in_{r+1}[1] = out_r[1].\n    //     Input limbs 2-3 are free/private.\n    //   - If mmcs_bit_{r+1} = 1 (right = previous hash): in_{r+1}[2] = out_r[0], in_{r+1}[3] = out_r[1].\n    //     Input limbs 0-1 are free/private.\n    // BUT: If in_ctl[i] = 1, CTL overrides chaining (limb is not chained).\n    // Chaining only applies when in_ctl[limb] = 0.\n    let is_left = AB::Expr::ONE - next_bit.clone();\n\n    // Limb 0: chain from out_r[0] when mmcs_bit = 0 (left), unless in_ctl[0] = 1.\n    // When mmcs_bit = 1 (right), limb 0 is private (sibling).\n    for d in 0..D {\n        let gate_left_0 = next_preprocessed[merkle_chain_idx].clone() * is_left.clone();\n        builder\n            .when_transition()\n            .when(gate_left_0)\n            .assert_zero(next_in[d].clone() - local_out[d].clone());\n    }\n\n    // Limb 1: chain from out_r[1] when mmcs_bit = 0 (left), unless in_ctl[1] = 1.\n    // When mmcs_bit = 1 (right), limb 1 is private (sibling).\n    for d in 0..D {\n        let gate_left_1 = next_preprocessed[preprocessing_limb_data_size + merkle_chain_idx]\n            .clone()\n            * is_left.clone();\n        builder\n            .when_transition()\n            .when(gate_left_1)\n            .assert_zero(next_in[D + d].clone() - local_out[D + d].clone());\n    }\n\n    // Limb 2: chain from out_r[0] when mmcs_bit = 1 (right), unless in_ctl[2] = 1.\n    // When mmcs_bit = 0 (left), limb 2 is private (sibling).\n    for d in 0..D {\n        let gate_right_2 = next_preprocessed[preprocessing_limb_data_size * 2 + merkle_chain_idx]\n            .clone()\n            * next_bit.clone();\n        builder\n            .when_transition()\n            .when(gate_right_2)\n            .assert_zero(next_in[2 * D + d].clone() - local_out[d].clone());\n    }\n\n    // Limb 3: chain from out_r[1] when mmcs_bit = 1 (right), unless in_ctl[3] = 1.\n    // When mmcs_bit = 0 (left), limb 3 is private (sibling).\n    for d in 0..D {\n        let gate_right_3 = next_preprocessed[preprocessing_limb_data_size * 3 + merkle_chain_idx]\n            .clone()\n            * next_bit.clone();\n        builder\n            .when_transition()\n            .when(gate_right_3)\n            .assert_zero(next_in[3 * D + d].clone() - local_out[D + d].clone());\n    }\n\n    // MMCS accumulator update.\n    // If merkle_path_{r+1} = 1 and new_start_{r+1} = 0:\n    //   mmcs_index_sum_{r+1} = mmcs_index_sum_r * 2 + mmcs_bit_{r+1}\n    let two = AB::Expr::ONE + AB::Expr::ONE;\n    let not_next_new_start = AB::Expr::ONE - next_preprocessed[new_start_idx].clone();\n    builder\n        .when_transition()\n        .when(not_next_new_start)\n        .when(next_preprocessed[merkle_path_idx].clone())\n        .assert_zero(\n            next.mmcs_index_sum.clone()\n                - (local.mmcs_index_sum.clone() * two + next.mmcs_bit.clone()),\n        );\n\n    let p3_poseidon2_num_cols = p3_poseidon2_air::num_cols::\u003c\n        WIDTH,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e();\n    let mut sub_builder = SubAirBuilder::\u003c\n        AB,\n        Poseidon2Air\u003c\n            AB::F,\n            LinearLayers,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n        AB::Var,\n    \u003e::new(builder, 0..p3_poseidon2_num_cols);\n\n    // Enforce Poseidon2 permutation constraint:\n    // out[0..3] = Poseidon2(in[0..3])\n    // This holds regardless of merkle_path, new_start, CTL flags, chaining, or MMCS accumulator.\n    air.p3_poseidon2.eval(\u0026mut sub_builder);\n}\n\n/// Unsafe version of `eval` that allows calling with a builder whose field type\n/// doesn't match the AIR's field type at compile time, but matches at runtime.\n///\n/// # Safety\n/// The caller must ensure that `F == AB::F` at runtime. Violating this will cause\n/// undefined behavior.\npub unsafe fn eval_unchecked\u003c\n    F: PrimeField,\n    AB: PairBuilder,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e(\n    air: \u0026Poseidon2CircuitAir\u003c\n        F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e,\n    builder: \u0026mut AB,\n    local: \u0026Poseidon2CircuitCols\u003c\n        AB::Var,\n        Poseidon2Cols\u003c\n            AB::Var,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n    \u003e,\n    next: \u0026Poseidon2CircuitCols\u003c\n        AB::Var,\n        Poseidon2Cols\u003c\n            AB::Var,\n            WIDTH,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e,\n    \u003e,\n    next_preprocessed: \u0026[AB::Var],\n) where\n    AB::F: PrimeField,\n{\n    // SAFETY: Transmute the AIR to match builder's field type\n    // Caller guarantees F == AB::F at runtime.\n    unsafe {\n        let air_transmuted: \u0026Poseidon2CircuitAir\u003c\n            AB::F,\n            LinearLayers,\n            D,\n            WIDTH,\n            WIDTH_EXT,\n            RATE_EXT,\n            CAPACITY_EXT,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e = core::mem::transmute(air);\n\n        eval::\u003c\n            AB,\n            LinearLayers,\n            D,\n            WIDTH,\n            WIDTH_EXT,\n            RATE_EXT,\n            CAPACITY_EXT,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e(air_transmuted, builder, local, next, next_preprocessed);\n    }\n}\n\nimpl\u003c\n    AB: PairBuilder,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e Air\u003cAB\u003e\n    for Poseidon2CircuitAir\u003c\n        AB::F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e\nwhere\n    AB::F: PrimeField,\n{\n    #[inline]\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let local = main.row_slice(0).expect(\"The matrix is empty?\");\n        let local = (*local).borrow();\n        let next = main.row_slice(1).expect(\"The matrix has only one row?\");\n        let next = (*next).borrow();\n\n        let preprocessed = builder.preprocessed();\n        let next_preprocessed = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n        let next_preprocessed = (*next_preprocessed).borrow();\n\n        eval::\u003c\n            _,\n            _,\n            D,\n            WIDTH,\n            WIDTH_EXT,\n            RATE_EXT,\n            CAPACITY_EXT,\n            SBOX_DEGREE,\n            SBOX_REGISTERS,\n            HALF_FULL_ROUNDS,\n            PARTIAL_ROUNDS,\n        \u003e(self, builder, local, next, next_preprocessed);\n    }\n}\n\nimpl\u003c\n    AB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues,\n    LinearLayers: GenericPoseidon2LinearLayers\u003cWIDTH\u003e,\n    const D: usize,\n    const WIDTH: usize,\n    const WIDTH_EXT: usize,\n    const RATE_EXT: usize,\n    const CAPACITY_EXT: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e AirLookupHandler\u003cAB\u003e\n    for Poseidon2CircuitAir\u003c\n        AB::F,\n        LinearLayers,\n        D,\n        WIDTH,\n        WIDTH_EXT,\n        RATE_EXT,\n        CAPACITY_EXT,\n        SBOX_DEGREE,\n        SBOX_REGISTERS,\n        HALF_FULL_ROUNDS,\n        PARTIAL_ROUNDS,\n    \u003e\nwhere\n    AB::F: PrimeField,\n{\n    fn add_lookup_columns(\u0026mut self) -\u003e Vec\u003cusize\u003e {\n        let lookup_column_idx = self.num_lookup_cols;\n        self.num_lookup_cols += 1;\n        vec![lookup_column_idx]\n    }\n\n    fn get_lookups(\u0026mut self) -\u003e Vec\u003cLookup\u003c\u003cAB\u003e::F\u003e\u003e {\n        let symbolic_air_builder = SymbolicAirBuilder::\u003cAB::F\u003e::new(\n            0, // TODO: update the permutation width when implemented.\n            BaseAir::\u003cAB::F\u003e::width(self),\n            0,\n            0, // Here, we do not need the permutation trace\n            0,\n        );\n        let symbolic_main = symbolic_air_builder.main();\n        let symbolic_main_local = symbolic_main.row_slice(0).expect(\"The matrix is empty?\");\n        let symbolic_main_next = symbolic_main\n            .row_slice(1)\n            .expect(\"The matrix has only one row?\");\n\n        let local: \u0026Poseidon2CircuitCols\u003c\n            SymbolicVariable\u003cAB::F\u003e,\n            Poseidon2Cols\u003c\n                SymbolicVariable\u003cAB::F\u003e,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = (*symbolic_main_local).borrow();\n\n        let next: \u0026Poseidon2CircuitCols\u003c\n            SymbolicVariable\u003cAB::F\u003e,\n            Poseidon2Cols\u003c\n                SymbolicVariable\u003cAB::F\u003e,\n                WIDTH,\n                SBOX_DEGREE,\n                SBOX_REGISTERS,\n                HALF_FULL_ROUNDS,\n                PARTIAL_ROUNDS,\n            \u003e,\n        \u003e = (*symbolic_main_next).borrow();\n\n        // Preprocessing layout:\n        // [in_idx[0], in_ctl[0], normal_chain_sel[0], merkle_chain_sel[0], ..., in_idx[3], in_ctl[3], normal_chain_sel[3], merkle_chain_sel[3],\n        //  out_idx[0], out_ctl[0], out_idx[1], out_ctl[1], mmcs_index_sum_ctl_idx, new_start, merkle_path]\n        // The following corresponds to the size of the data related to one input limb (in_idx[i], in_ctl[i], normal_chain_sel[i], merkle_chain_sel[i]).\n        let preprocessing_limb_input_data_size = 4;\n        let preprocessing_limb_output_data_size = 4;\n        let in_ctl_idx = 1;\n        let start_output_idx = preprocessing_limb_input_data_size * POSEIDON2_LIMBS;\n        let mmcs_index_sum_ctl_idx =\n            start_output_idx + preprocessing_limb_output_data_size * POSEIDON2_PUBLIC_OUTPUT_LIMBS;\n        let new_start_idx = mmcs_index_sum_ctl_idx + 1;\n        let merkle_path_idx = new_start_idx + 1;\n\n        let preprocessed = symbolic_air_builder.preprocessed();\n        let local_preprocessed = preprocessed\n            .row_slice(0)\n            .expect(\"The preprocessed matrix has only one row?\");\n        let local_preprocessed: \u0026[SymbolicVariable\u003cAB::F\u003e] = (*local_preprocessed).borrow();\n        let next_preprocessed = preprocessed\n            .row_slice(1)\n            .expect(\"The preprocessed matrix has only one row?\");\n        let next_preprocessed: \u0026[SymbolicVariable\u003cAB::F\u003e] = (*next_preprocessed).borrow();\n        // There are POSEIDON2_LIMBS input limbs and POSEIDON2_PUBLIC_OUTPUT_LIMBS output limbs to be lookup up in the `Witness` table.\n        let mut lookups = Vec::with_capacity(POSEIDON2_LIMBS + POSEIDON2_PUBLIC_OUTPUT_LIMBS);\n        // Each input/output limb is sent with multiplicity `in_ctl/out_ctl`.\n        for limb_idx in 0..POSEIDON2_LIMBS {\n            let in_ctl =\n                local_preprocessed[limb_idx * preprocessing_limb_input_data_size + in_ctl_idx];\n            let input_idx_limb =\n                iter::once(next_preprocessed[limb_idx * preprocessing_limb_input_data_size]) // input witness index\n                    .chain(\n                        next.poseidon2.inputs[limb_idx * D..(limb_idx + 1) * D]\n                            .iter()\n                            .cloned(),\n                    )\n                    .map(SymbolicExpression::from)\n                    .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let lookup_input = vec![(\n                input_idx_limb,\n                SymbolicExpression::from(in_ctl),\n                Direction::Send,\n            )];\n\n            lookups.push(AirLookupHandler::\u003cAB\u003e::register_lookup(\n                self,\n                Kind::Global(\"WitnessChecks\".to_string()),\n                \u0026lookup_input,\n            ));\n        }\n\n        for limb_idx in 0..POSEIDON2_PUBLIC_OUTPUT_LIMBS {\n            let out_ctl = local_preprocessed[start_output_idx + limb_idx * 2 + 1];\n\n            let output_idx_limb = iter::once(local_preprocessed[start_output_idx + limb_idx * 2]) // output witness index\n                .chain(\n                    local.poseidon2.ending_full_rounds[HALF_FULL_ROUNDS - 1].post\n                        [limb_idx * D..(limb_idx + 1) * D]\n                        .iter()\n                        .cloned(),\n                )\n                .map(SymbolicExpression::from)\n                .collect::\u003cVec\u003c_\u003e\u003e();\n\n            let lookup_output = vec![(\n                output_idx_limb,\n                SymbolicExpression::from(out_ctl),\n                Direction::Send,\n            )];\n\n            lookups.push(AirLookupHandler::\u003cAB\u003e::register_lookup(\n                self,\n                Kind::Global(\"WitnessChecks\".to_string()),\n                \u0026lookup_output,\n            ));\n        }\n\n        // If next.new_start = 1 and local.merkle_path = 1, then mmcs_index_sum is exposed via CTL.\n        let next_new_start = next_preprocessed[new_start_idx];\n        let local_merkle_path = local_preprocessed[merkle_path_idx];\n        let multiplicity = next_new_start * local_merkle_path;\n\n        let local_mmcs_index_sum_idx = local_preprocessed[mmcs_index_sum_ctl_idx];\n        let mut mmcs_index_sum_lookup = vec![\n            SymbolicExpression::from(local_mmcs_index_sum_idx),\n            SymbolicExpression::from(local.mmcs_index_sum),\n        ];\n        // Extend `mmcs_index_sum` to D elements with zeros.\n        mmcs_index_sum_lookup.extend(iter::repeat_n(\n            SymbolicExpression::Constant(AB::F::ZERO),\n            D - 1,\n        ));\n\n        let lookup_mmcs = (\n            mmcs_index_sum_lookup.to_vec(),\n            multiplicity,\n            Direction::Send,\n        );\n        lookups.push(AirLookupHandler::\u003cAB\u003e::register_lookup(\n            self,\n            Kind::Global(\"WitnessChecks\".to_string()),\n            \u0026[lookup_mmcs],\n        ));\n\n        lookups\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use alloc::vec;\n\n    use p3_baby_bear::{BabyBear, Poseidon2BabyBear};\n    use p3_challenger::{HashChallenger, SerializingChallenger32};\n    use p3_commit::ExtensionMmcs;\n    use p3_field::extension::BinomialExtensionField;\n    use p3_fri::{TwoAdicFriPcs, create_benchmark_fri_params};\n    use p3_keccak::{Keccak256Hash, KeccakF};\n    use p3_merkle_tree::MerkleTreeHidingMmcs;\n    use p3_poseidon2::ExternalLayerConstants;\n    use p3_poseidon2_air::RoundConstants;\n    use p3_symmetric::{CompressionFunctionFromHasher, PaddingFreeSponge, SerializingHasher};\n    use p3_uni_stark::{\n        StarkConfig, prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed,\n    };\n    use rand::rngs::SmallRng;\n    use rand::{Rng, SeedableRng};\n\n    use super::*;\n    use crate::Poseidon2CircuitAirBabyBearD4Width16;\n    use crate::columns::{POSEIDON2_LIMBS, POSEIDON2_PUBLIC_OUTPUT_LIMBS};\n\n    const WIDTH: usize = 16;\n\n    #[test]\n    fn prove_poseidon2_sponge() -\u003e Result\u003c\n        (),\n        p3_uni_stark::VerificationError\u003c\n            p3_fri::verifier::FriError\u003c\n                p3_merkle_tree::MerkleTreeError,\n                p3_merkle_tree::MerkleTreeError,\n            \u003e,\n        \u003e,\n    \u003e {\n        type Val = BabyBear;\n        type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\n\n        type ByteHash = Keccak256Hash;\n        let byte_hash = ByteHash {};\n\n        type U64Hash = PaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e;\n        let u64_hash = U64Hash::new(KeccakF {});\n\n        type FieldHash = SerializingHasher\u003cU64Hash\u003e;\n        let field_hash = FieldHash::new(u64_hash);\n\n        type MyCompress = CompressionFunctionFromHasher\u003cU64Hash, 2, 4\u003e;\n        let compress = MyCompress::new(u64_hash);\n\n        // WARNING: DO NOT USE SmallRng in proper applications! Use a real PRNG instead!\n        type ValMmcs = MerkleTreeHidingMmcs\u003c\n            [Val; p3_keccak::VECTOR_LEN],\n            [u64; p3_keccak::VECTOR_LEN],\n            FieldHash,\n            MyCompress,\n            SmallRng,\n            4,\n            4,\n        \u003e;\n        let mut rng = SmallRng::seed_from_u64(1);\n        let val_mmcs = ValMmcs::new(field_hash, compress, rng.clone());\n\n        type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\n        let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n\n        type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\n        let challenger = Challenger::from_hasher(vec![], byte_hash);\n\n        let mut fri_params = create_benchmark_fri_params(challenge_mmcs);\n        fri_params.log_blowup = 4;\n\n        let beginning_full_constants = rng.random();\n        let partial_constants = rng.random();\n        let ending_full_constants = rng.random();\n\n        let constants = RoundConstants::new(\n            beginning_full_constants,\n            partial_constants,\n            ending_full_constants,\n        );\n\n        let perm = Poseidon2BabyBear::\u003cWIDTH\u003e::new(\n            ExternalLayerConstants::new(\n                beginning_full_constants.to_vec(),\n                ending_full_constants.to_vec(),\n            ),\n            partial_constants.to_vec(),\n        );\n\n        // Generate random inputs.\n        let mut rng = SmallRng::seed_from_u64(1);\n\n        let first_state: Vec\u003cVal\u003e = (0..WIDTH).map(|_| rng.random()).collect();\n        let zero_state = vec![Val::ZERO; WIDTH];\n\n        let sponge_a: Poseidon2CircuitRow\u003cVal\u003e = Poseidon2CircuitRow {\n            new_start: true,\n            merkle_path: false,\n            mmcs_bit: false,\n            mmcs_index_sum: Val::ZERO,\n            input_values: first_state,\n            in_ctl: [false; POSEIDON2_LIMBS],\n            input_indices: [0; POSEIDON2_LIMBS],\n            out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            mmcs_index_sum_idx: 0,\n        };\n\n        let sponge_b: Poseidon2CircuitRow\u003cVal\u003e = Poseidon2CircuitRow {\n            new_start: false,\n            merkle_path: false,\n            mmcs_bit: true,\n            mmcs_index_sum: Val::ZERO,\n            input_values: zero_state.clone(),\n            in_ctl: [false; POSEIDON2_LIMBS],\n            input_indices: [0; POSEIDON2_LIMBS],\n            out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            mmcs_index_sum_idx: 0,\n        };\n\n        let sponge_c: Poseidon2CircuitRow\u003cVal\u003e = Poseidon2CircuitRow {\n            new_start: false,\n            merkle_path: true,\n            mmcs_bit: false,\n            mmcs_index_sum: Val::ZERO,\n            input_values: zero_state.clone(),\n            in_ctl: [false; POSEIDON2_LIMBS],\n            input_indices: [0; POSEIDON2_LIMBS],\n            out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            mmcs_index_sum_idx: 0,\n        };\n\n        let sponge_d: Poseidon2CircuitRow\u003cVal\u003e = Poseidon2CircuitRow {\n            new_start: false,\n            merkle_path: false,\n            mmcs_bit: false,\n            mmcs_index_sum: Val::ZERO,\n            input_values: zero_state,\n            in_ctl: [false; POSEIDON2_LIMBS],\n            input_indices: [0; POSEIDON2_LIMBS],\n            out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n            mmcs_index_sum_idx: 0,\n        };\n\n        let mut rows = vec![sponge_a, sponge_b, sponge_c, sponge_d];\n        let degree_bits = 5;\n        let target_rows = 1 \u003c\u003c degree_bits;\n        if rows.len() \u003c target_rows {\n            let filler = rows.last().cloned().unwrap_or_else(|| Poseidon2CircuitRow {\n                new_start: true,\n                merkle_path: false,\n                mmcs_bit: false,\n                mmcs_index_sum: Val::ZERO,\n                input_values: vec![Val::ZERO; WIDTH],\n                in_ctl: [false; POSEIDON2_LIMBS],\n                input_indices: [0; POSEIDON2_LIMBS],\n                out_ctl: [false; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n                output_indices: [0; POSEIDON2_PUBLIC_OUTPUT_LIMBS],\n                mmcs_index_sum_idx: 0,\n            });\n            rows.resize(target_rows, filler);\n        }\n\n        let preprocessed = extract_preprocessed_from_operations::\u003cVal, Val\u003e(\u0026rows);\n        let air = Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(\n            constants.clone(),\n            preprocessed,\n        );\n\n        let trace = air.generate_trace_rows(\u0026rows, \u0026constants, fri_params.log_blowup, \u0026perm);\n\n        type Dft = p3_dft::Radix2Bowers;\n        let dft = Dft::default();\n\n        type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\n        let pcs = Pcs::new(dft, val_mmcs, fri_params);\n\n        type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\n        let config = MyConfig::new(pcs, challenger);\n\n        let (preprocessed_prover, preprocessed_verifier) =\n            setup_preprocessed(\u0026config, \u0026air, degree_bits).unzip();\n        let proof =\n            prove_with_preprocessed(\u0026config, \u0026air, trace, \u0026[], preprocessed_prover.as_ref());\n\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026[], preprocessed_verifier.as_ref())\n    }\n}\n","traces":[{"line":70,"address":[5048624],"length":1,"stats":{"Line":3}},{"line":72,"address":[3751124,3751269],"length":1,"stats":{"Line":3}},{"line":102,"address":[3528784,3528656,3528912,3529040],"length":1,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[7720416,7720161,7720289,7720544],"length":1,"stats":{"Line":0}},{"line":113,"address":[7720427,7720172,7720300,7720555],"length":1,"stats":{"Line":0}},{"line":117,"address":[4267033,4266832],"length":1,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[4266853],"length":1,"stats":{"Line":3}},{"line":133,"address":[2281408,2281440,2281424,2281456],"length":1,"stats":{"Line":3}},{"line":134,"address":[7720113,7720081,7720129,7720097],"length":1,"stats":{"Line":3}},{"line":137,"address":[4266012,4261536,4266018],"length":1,"stats":{"Line":2}},{"line":144,"address":[2192514],"length":1,"stats":{"Line":2}},{"line":145,"address":[2192554],"length":1,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[2192605],"length":1,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[4261784,4261843],"length":1,"stats":{"Line":2}},{"line":163,"address":[2192698,2192735,2192902],"length":1,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[4262016,4262117],"length":1,"stats":{"Line":4}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":175,"address":[4262371,4262216],"length":1,"stats":{"Line":4}},{"line":177,"address":[4262401,4265985],"length":1,"stats":{"Line":4}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[2193544],"length":1,"stats":{"Line":2}},{"line":180,"address":[2193567],"length":1,"stats":{"Line":2}},{"line":181,"address":[4262727],"length":1,"stats":{"Line":2}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[2193636],"length":1,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[2193664],"length":1,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[2194447],"length":1,"stats":{"Line":2}},{"line":192,"address":[4263365],"length":1,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":194,"address":[4263443],"length":1,"stats":{"Line":2}},{"line":195,"address":[2194363],"length":1,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":2}},{"line":199,"address":[4263789],"length":1,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[2194763,2194800],"length":1,"stats":{"Line":4}},{"line":214,"address":[2194813],"length":1,"stats":{"Line":1}},{"line":219,"address":[2195126,2194835],"length":1,"stats":{"Line":2}},{"line":220,"address":[2195164],"length":1,"stats":{"Line":1}},{"line":221,"address":[4264310,4264325],"length":1,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[4264377,4264520],"length":1,"stats":{"Line":2}},{"line":225,"address":[4264530],"length":1,"stats":{"Line":1}},{"line":228,"address":[4264785,4264312],"length":1,"stats":{"Line":0}},{"line":229,"address":[4264824,4264791],"length":1,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[2195937],"length":1,"stats":{"Line":0}},{"line":238,"address":[4263993,4263955],"length":1,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[2194920],"length":1,"stats":{"Line":1}},{"line":241,"address":[2194960],"length":1,"stats":{"Line":1}},{"line":242,"address":[2195044],"length":1,"stats":{"Line":1}},{"line":243,"address":[4264255,4266073,4266064],"length":1,"stats":{"Line":3}},{"line":244,"address":[4266137],"length":1,"stats":{"Line":1}},{"line":245,"address":[2197650],"length":1,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":256,"address":[4265378],"length":1,"stats":{"Line":1}},{"line":261,"address":[4265341],"length":1,"stats":{"Line":2}},{"line":263,"address":[2196325],"length":1,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[4265584],"length":1,"stats":{"Line":2}},{"line":268,"address":[4265672],"length":1,"stats":{"Line":2}},{"line":271,"address":[4265736],"length":1,"stats":{"Line":2}},{"line":272,"address":[4265831],"length":1,"stats":{"Line":2}},{"line":279,"address":[4262891],"length":1,"stats":{"Line":2}},{"line":280,"address":[4263014],"length":1,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":282,"address":[2196932,2196912,2194002],"length":1,"stats":{"Line":6}},{"line":283,"address":[4266279],"length":1,"stats":{"Line":2}},{"line":286,"address":[2197102],"length":1,"stats":{"Line":2}},{"line":287,"address":[2197089],"length":1,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":299,"address":[2197279],"length":1,"stats":{"Line":2}},{"line":300,"address":[4266615],"length":1,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":2}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[4266734,4266812],"length":1,"stats":{"Line":2}},{"line":318,"address":[4263162],"length":1,"stats":{"Line":2}},{"line":321,"address":[4263238],"length":1,"stats":{"Line":2}},{"line":352,"address":[3522336,3522320,3522288,3522304],"length":1,"stats":{"Line":3}},{"line":353,"address":[3823077,3823061,3823093,3823045],"length":1,"stats":{"Line":3}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[2148336,2149063,2149069],"length":1,"stats":{"Line":2}},{"line":359,"address":[2148390],"length":1,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[2148637],"length":1,"stats":{"Line":2}},{"line":371,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[2148675],"length":1,"stats":{"Line":2}},{"line":373,"address":[2148685],"length":1,"stats":{"Line":2}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[2148767],"length":1,"stats":{"Line":2}},{"line":377,"address":[4226749,4226798],"length":1,"stats":{"Line":4}},{"line":378,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[4226692],"length":1,"stats":{"Line":2}},{"line":384,"address":[2162089,2161104,2162083],"length":1,"stats":{"Line":2}},{"line":387,"address":[4230100,4230007],"length":1,"stats":{"Line":2}},{"line":389,"address":[],"length":0,"stats":{"Line":4}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[4230284],"length":1,"stats":{"Line":2}},{"line":392,"address":[4230299],"length":1,"stats":{"Line":2}},{"line":393,"address":[2161470],"length":1,"stats":{"Line":2}},{"line":394,"address":[2161490],"length":1,"stats":{"Line":2}},{"line":395,"address":[4230359],"length":1,"stats":{"Line":2}},{"line":396,"address":[4230382],"length":1,"stats":{"Line":2}},{"line":397,"address":[2161548],"length":1,"stats":{"Line":2}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[4230539],"length":1,"stats":{"Line":2}},{"line":406,"address":[4231072,4231100,4230616],"length":1,"stats":{"Line":6}},{"line":407,"address":[4231110],"length":1,"stats":{"Line":2}},{"line":408,"address":[2162363,2162329],"length":1,"stats":{"Line":4}},{"line":409,"address":[4231228],"length":1,"stats":{"Line":1}},{"line":411,"address":[2162355],"length":1,"stats":{"Line":2}},{"line":414,"address":[],"length":0,"stats":{"Line":2}},{"line":419,"address":[],"length":0,"stats":{"Line":4}},{"line":420,"address":[2162465],"length":1,"stats":{"Line":1}},{"line":422,"address":[4231274],"length":1,"stats":{"Line":2}},{"line":424,"address":[],"length":0,"stats":{"Line":2}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[4230727],"length":1,"stats":{"Line":2}},{"line":429,"address":[4230804,4230960,4230983],"length":1,"stats":{"Line":6}},{"line":430,"address":[4230993],"length":1,"stats":{"Line":2}},{"line":432,"address":[4230819],"length":1,"stats":{"Line":2}},{"line":433,"address":[],"length":0,"stats":{"Line":2}},{"line":434,"address":[4230902],"length":1,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":440,"address":[1689680,1682208,1690078,1685051,1681808],"length":1,"stats":{"Line":10}},{"line":496,"address":[],"length":0,"stats":{"Line":10}},{"line":497,"address":[3063337,3055466,3012042,3130250,3033449,3019178,3026314,3070777,3085354,3048025,2996730,3092490,3040890,3115242,2989289,3122378,3107801,3004601,3100361,3078218],"length":1,"stats":{"Line":10}},{"line":498,"address":[4239142,4254453,4247013,4231701],"length":1,"stats":{"Line":10}},{"line":501,"address":[4247104,4254544,4231792,4231721,4247033,4254473,4239162,4239235],"length":1,"stats":{"Line":20}},{"line":507,"address":[3070919,2989431,3078362,3085498,3092634,3100503,3012186,3033591,3019322,3048167,3055610,3063479,3115386,3122522,3130394,3004743,3041034,2996874,3107943,3026458],"length":1,"stats":{"Line":10}},{"line":508,"address":[2989098,3092298,3004410,3011850,3078026,3107610,3122186,3100170,3115050,3018986,3130058,3063146,2996538,3033258,3047834,3040698,3055274,3070586,3026122,3085162],"length":1,"stats":{"Line":10}},{"line":509,"address":[],"length":0,"stats":{"Line":10}},{"line":510,"address":[3033615,3055845,3004978,3078597,3063714,3041269,2989666,2996898,3048191,3100527,3019557,3100738,3107967,3130629,3063503,3108178,3092658,3115621,3048402,3085522,3070943,3122546,3019346,3055634,3012421,3004767,3115410,3130418,3026693,3085733,3122757,2989455,3033826,3071154,2997109,3092869,3026482,3078386,3012210,3041058],"length":1,"stats":{"Line":10}},{"line":511,"address":[3005007,3026671,2989739,3130702,3085711,3100716,2997182,3100767,3026766,3071183,2997138,3115599,3063692,3041342,3063787,3130607,3026722,3078575,3055823,2997087,3005051,3122830,3012399,3033804,2989695,3012494,3012450,3085806,3115650,3019535,3092847,3019586,3130658,3115694,3092942,3055918,3100811,3122786,3108156,3019630,3122735,3033899,3041298,3071227,3048475,3085762,3041247,3108251,3033855,3092898,3063743,3048380,3055874,3048431,3108207,2989644,3004956,3078626,3078670,3071132],"length":1,"stats":{"Line":20}},{"line":517,"address":[],"length":0,"stats":{"Line":20}},{"line":518,"address":[],"length":0,"stats":{"Line":30}},{"line":519,"address":[],"length":0,"stats":{"Line":10}},{"line":520,"address":[4080454,3874758,4036073,4095334,4154247,3955913,3881911,3940888,3867261,3903910,3992765,4095288,3933448,4073003,4132535,4147048,4161337,4161383,4080408,3992811,4043209,3918848,4057814,3896487,4021337,4154201,4175609,3948736,3963049,3911017,3978103,4139625,4175655,4057768,4182791,3985239,3911063,3955959,4110328,4007111,4021383,4125312,4168473,4205243,3889334,4219847,4132489,4234813,4234859,4242264,4102877,4197608,4219801,4117527,3896441,4190168,4227224,3881865,4065357,3918802,4197654,4212694,4065403,4168519,3889288,4139671,3874712,4028909,4117481,4087848,4182745,3940934,4205197,4190214,4242310,3926025,4014201,4007065,4110374,4125266,4147094,4102923,3926071,3903864,4014247,4227270,4036119,4050345,4028955,4212648,4050391,3963095,4043255,3985193,3970880,3933494,3867307,3999929,3999975,4087894,4072957,3948690,3970834,3978057],"length":1,"stats":{"Line":20}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[4261142,4261227,4253787,4238475,4253702,4238390],"length":1,"stats":{"Line":12}},{"line":524,"address":[3978321,3963313,3926289,3911281,4007329,4043473,4073265,4139889,4197909,4205505,3889589,4132753,4175873,4235121,4117745,4014465,3904165,4036337,4147349,4161601,4021601,4058069,4190469,3875013,4110629,3985457,3882129,3919071,4000193,4050609,4065665,4088149,4095589,3933749,4103185,4125535,3993073,4168737,4212949,4220065,4227525,3941189,3948959,3896705,4029217,4242565,3867569,3971103,4154465,4080709,4183009,3956177],"length":1,"stats":{"Line":10}},{"line":525,"address":[1696891,1689665,1696993,1696826,1689511,1689278,1697098,1696773,1689312],"length":1,"stats":{"Line":10}},{"line":537,"address":[4050118,3874485,3925798,3868942,3994465,3933221,4170099,4161110,3972593,3898064,3905553,3984966,4119168,4102650,3992538,4051998,3950403,4199251,4044881,4228867,4197381,3910790,4067042,4006838,3986819,4111971,3935088,3861346,3883488,4030609,3999702,3896214,4191838,4163009,4096931,4206878,4234586,4236464,3957539,4037699,4242037,4206848,3927678,4059411,4228898,4127025,3962822,4037745,4191808,3948458,4221454,4219574,4126979,4153974,3920561,3972547,3986850,4104528,4030563,4189941,3868912,3955686,4042982,3979729,4177235,4104558,3889061,3883518,3903637,4119107,4059442,3920515,4214291,4155827,4015827,3964675,3977830,4170145,4204970,4074638,4125034,3890931,4057541,4214337,4141278,4028682,4051968,3927648,4082048,4155873,4087621,3890977,4146821,4177281,4074608,4015873,3861315,4065130,4095061,3876355,4001555,4001601,4008737,4022994,4148737,4168246,4199282,3940661,4089488,4013974,4175382,3867034,4236494,3898094,3942531,3950449,4021110,3935118,3942592,4089518,4132262,3876401,4022963,3912704,4096962,4044835,4110101,4112017,4141248,4182518,3957585,4117254,3918570,4184398,4148691,3912643,3970602,4139398,4162963,3881638,3964736,3994419,4080181,4072730,3905507,4082078,4226997,3979683,4221424,4184368,4008691,4134161,4212421,4035846,4134115,4067011],"length":1,"stats":{"Line":10}},{"line":541,"address":[],"length":0,"stats":{"Line":30}},{"line":542,"address":[1690975,1695599,1688685,1687934,1688018,1696208,1683141,1695517],"length":1,"stats":{"Line":20}},{"line":543,"address":[],"length":0,"stats":{"Line":12}},{"line":545,"address":[3866605,3947938,4234157,4131840,3962400,3970082,4013552,4102221,4226598,3977408,4124514,4219152,3918050,3881216,4064701,3888662,4020688,4072301,4028253,3925376,4116832,3895792,3984544,4138976,4146422,4006416,4153552,4174960,4160688,3874086,4094662,3999280,3932822,4079782,4241638,4189542,3992109,3903238,4035424,4196982,3940262,4109702,4182096,4167824,3910368,4212022,4049696,4204541,4042560,4087222,3955264,4057142],"length":1,"stats":{"Line":10}},{"line":546,"address":[1688508,1695849,1688662,1688294,1688257,1695979,1696093,1696198,1695908],"length":1,"stats":{"Line":10}},{"line":551,"address":[3098261,2997768,3020188,3038945,3041900,3017280,3128149,3123416,3108802,3131260,3010097,3113297,3024416,3013052,3135488,3120480,3034450,3079228,3083456,3053521,3071778,3064338,3031552,3101362,3105857,2994785,3027324,3046128,3061237,3068833,3090592,3005602,3002501,3076273,3086364,3093528,3116252,3056504,3049026,2990290],"length":1,"stats":{"Line":20}},{"line":552,"address":[2167640,2171433,2174791,2182488,2174746,2182390,2167485,2186431,2182342,2190088,2163983,2189977,2189933,2178597,2167529,2174889],"length":1,"stats":{"Line":30}},{"line":553,"address":[4244087,4259155,4244128,4251667,4236403,4236355,4251715,4259107],"length":1,"stats":{"Line":20}},{"line":554,"address":[3127527,3112577,2994065,3001791,3009476,3038960,3060527,3082816,3068099,3097544,3090607,3105872,3031567,3031000,3068212,3105236,3120495,3127439,3135503,3089952,3075553,3024431,3076288,3090040,3052900,3082904,3023769,3134848,3038225,3052801,3016640,3017295,3046143,3112563,3009363,3060520,2994164,3016728,3083471,3068848,3075539,3113312,3082809,3001784,3105137,2994051,3009377,3023864,3045576,3119928,3002529,3023776,3030905,3112676,3128177,3134841,3097639,3134936,3016633,3060615,3119833,3045481,3097551,3038324,3098289,3089945,3001879,3010112,3061265,3068113,3119840,3053536,3105123,3045488,2994800,3052787,3038211,3075652,3030912,3127432],"length":1,"stats":{"Line":20}},{"line":555,"address":[2190333,2190233,2167885,2167785],"length":1,"stats":{"Line":12}},{"line":557,"address":[1687343,1694984],"length":1,"stats":{"Line":10}},{"line":558,"address":[3024421,3061021,3031159,3017091,3053116,2994598,3076278,3083031,3090199,3105390,3031208,3127678,3105507,3127933,3002506,3002285,3046133,3128154,3017285,3060766,3090403,3113110,3135095,3061242,3135493,3120087,3068366,3016887,3112947,3127715,3098266,3120055,3053526,3135299,3002030,3009692,3083461,3105452,3090248,3135063,3135144,3083267,3038950,3009630,3045703,3009910,3112830,3024227,3120291,3045784,2994435,3016855,3105862,3045939,3023991,3053171,2994380,2994790,3068838,3038478,3090167,3024072,3105670,3113302,3031557,3068428,3120485,3120136,3097790,3024023,3038540,3112892,3083063,3098045,3060803,3075923,3083112,3090597,3016936,3031127,3038595,3010102,3068646,3075806,3009747,2994318,3075868,3038758,3045735,3076086,3097827,3068483,3031363,3002067,3053334,3053054],"length":1,"stats":{"Line":10}},{"line":563,"address":[3913210,4023500,4038238,3909326,4112510,4123373,3928180,4105060,3983502,4137934,3865401,3973086,4199788,3884020,3998238,4177774,3950942,4063497,4101017,4203337,4012510,4221956,3939089,3987356,3935620,4027049,4031102,3943098,4034382,3924334,3931649,4078609,4236996,3990905,4188369,3968941,4127518,3861852,3876894,3965242,4086049,4108529,4119674,3961358,4045374,4082580,4192340,3898596,4071097,3921054,4210849,3906046,3869444,4090020,3887489,4002094,4097468,4152510,4041518,4173918,4156366,4184900,4052500,4067548,4005374,4055969,3980222,3902065,4019646,4141780,4145249,4166782,3891470,4170638,4195809,4130798,4214830,4225425,4229404,4240465,3994958,4218110,3958078,4075140,4115790,4093489,3894750,4163502,4181054,4232953,3954222,4059948,4134654,3880174,3916909,4016366,4149230,4159646,4048654,3946797,4207380,3976366,3872913,4009230],"length":1,"stats":{"Line":20}},{"line":564,"address":[4232017,4047822,4232264,4107856,4202401,4187590,4165950,4239549,4158814,4224646,3923724,4070299,4222129,4239792,4055190,4119847,3869617,4026251,4141953,3908623,3898769,4023673,4144470,4195136,4210176,3921227,4180351,3872134,4217407,3894047,3990107,3901392,4016539,3995131,4070161,4092710,4114958,4192513,4224509,4151807,3973259,3871997,4209933,4040815,4217500,4107613,4100219,3982799,3968257,4122596,4122466,4130095,4173086,3916225,3930976,4122689,4163675,3879564,4097641,4055296,4237169,4115180,4194893,4100328,4062808,4112683,4033772,4004764,4180222,4011900,4158943,3886816,4173215,4033679,4075313,3990216,4026360,3913383,3935793,3872240,4055053,3908716,4085376,4092573,4092816,3930733,3891643,4062699,4129966,4151678,4187453,4229577,4077830,4144576,4232155,3864712,3916132,3982670,4130188,4202648,4137231,3946020,4004671,4170811,4202539,3960655,3989969,4052673,4082753,4090193,4067721,3864465,3864603,3975534,3894140,3901149,3938416,4045547,4105233,3879342,3953612,3987529,4115087,4026113,4151900,3923502,3968164,4177947,4070408,4019036,4207553,4210070,3893918,3997406,4002267,3938310,4011807,4048044,4038411,3886573,3975663,3953390,4195030,4224752,3946113,3923631,4040908,4077693,4134827,3930870,3975756,3945890,3884193,3958251,4011678,3916002,4018814,4018943,4033550,4077936,4085133,4127691,3951115,4137324,3862025,4185073,4047951,4009403,4004542,4040686,3928353,4137102,4149403,3906219,4239686,4166172,3877067,4100081,4062561,3938173,4144333,3901286,3943271,3953519,3908494,3960748,3886710,3965415,3982892,4031275,4159036,4060121,4085270,4166079,3968034,3960526,3879471,4173308,3997628,4180444,4187696,4199961,4215003,3980395,4107750,4156539,4217278,3997535],"length":1,"stats":{"Line":30}},{"line":565,"address":[4232124,4137252,4130075,4166100,4232176,3997515,4151828,3997556,4166059,3923611,4224616,4018923,4033700,4040836,4217428,4055160,3901256,3901307,4115108,3894068,3982779,4122617,3930840,3872104,3960676,3953499,4092680,3968144,4210040,4085240,4173236,3938331,4100188,3872155,3960635,3990076,3908603,3930891,4026220,4033659,4047931,4077800,4040795,4062720,4144491,4158964,4202560,4239656,4239707,3968185,4004692,4107720,4122576,3908644,3886731,3894027,3864572,4100240,4011787,4070320,4115067,4180372,4180331,4210091,3982820,3975643,4011828,4130116,4151787,3879492,3938280,3946000,4085291,4026272,4004651,4062668,4144440,4158923,4173195,3916112,4137211,4070268,3946041,4107771,4187560,4187611,4224667,3990128,3864624,4055211,4077851,4195051,4195000,4202508,4092731,3923652,3975684,4018964,3916153,3953540,4217387,3886680,4047972,3879451],"length":1,"stats":{"Line":20}},{"line":566,"address":[],"length":0,"stats":{"Line":20}},{"line":567,"address":[2993409,3104481,3104573,3074989,3037661,3111921,3037569,3008721,3052237,2993501,3008813,3067457,3074897,3067549,3112013,3052145],"length":1,"stats":{"Line":12}},{"line":569,"address":[],"length":0,"stats":{"Line":10}},{"line":570,"address":[3096919,3119373,3038102,2993516,3082274,3089485,3037622,3075430,3052198,3067564,3134723,3009254,3030346,3074950,3037760,3082349,3104894,2993822,3127144,3097256,3016098,3082691,3097410,3030445,3104672,3127298,3016515,2993600,3075088,3067648,3126807,3016391,3096948,3134599,3023651,3045021,3119298,3023309,3112334,3008828,3030663,3075310,2993462,3082250,3075004,3052678,3001159,3059924,3060232,3112028,3134282,3089703,3104588,3059895,3134306,3030787,3023527,3060386,3023210,3037676,3001650,3016074,3089827,3105014,3111974,3045363,3089410,3112112,3082567,3119591,3023234,3030370,3052558,3067870,3067990,3067510,3008774,3089386,3112454,3008912,3001496,3045239,3009134,2993942,3044922,3001188,3016173,3052252,3052336,3104534,3119274,3119715,3126836,3134381,3044946,3037982],"length":1,"stats":{"Line":10}},{"line":575,"address":[],"length":0,"stats":{"Line":20}},{"line":576,"address":[3007336,3057063,3029178,3021913,3029049,2998327,3095643,3094087,3029271,3101921,3064897,3086923,3117977,3118199,3073649,3110673,3125531,3081175,3020747,3118106,3131819,3088218,3133207,3050897,3133114,2999741,3007579,2992024,3051003,3043625,2992267,3043847,3116811,3123975,3125624,3073755,3014906,3013611,3006161,3125389,3050760,3022042,2999976,3036184,3058477,3058619,3027883,3072337,3035009,3088089,3095736,3109361,3110536,2992161,3073512,3079787,3103233,3080953,3058712,3066072,3022135,3036427,3007473,3081082,3103339,3014999,3095501,3132985,3066315,3014777,3036321,3042459,3066209,3103096,3049585,3088311,3110779,3043754,2999883,2990849],"length":1,"stats":{"Line":30}},{"line":577,"address":[2173094,2165702,2173135,2180516,2180560,2188150,2165651,2188099],"length":1,"stats":{"Line":20}},{"line":578,"address":[1693015,1692902,1685320,1685415,1692916,1685327,1693712,1686117],"length":1,"stats":{"Line":20}},{"line":579,"address":[3863846,4077084,4092056,4143724,4201782,4209324,4231398,4201877,4091964,3937656,4186844,3989445,4069637,3886056,3900632,3930124,4107096,4194284,4223992,4223900,4143816,4238940,4062037,3863941,3871388,3871480,4077176,4054536,3885964,4025589,3900540,4061942,4084524,4107004,4209416,3989350,4099557,3937564,4084616,4025494,4099462,4186936,4069542,4194376,4231493,3930216,4054444,4239032],"length":1,"stats":{"Line":12}},{"line":581,"address":[4257547,4250107,4234795,4242463],"length":1,"stats":{"Line":10}},{"line":582,"address":[4234833,4234971,4242542,4257926,4257639,4235366,4242571,4250145,4250283,4257585,4250199,4243070,4242849,4257723,4258118,4250486,4250678,4235174,4234887],"length":1,"stats":{"Line":10}},{"line":588,"address":[],"length":0,"stats":{"Line":10}},{"line":589,"address":[4242076,4240994,4234377,4233395,4248707,4256063,4233311,4240845,4248623,4249689,4256147,4257129],"length":1,"stats":{"Line":10}},{"line":590,"address":[3870309,4208245,4222821,4185657,3870487,3885063,3936377,4075897,4098237,4222999,4090885,4098348,4083623,4222713,3988419,4076183,3988236,3899461,4142823,4185765,3929223,4238039,3862621,3862732,4053543,3929045,3928937,4237861,4193205,4200557,4060717,4061011,4068317,3988125,4237753,4090777,3870201,4230173,4091063,4185943,3899639,4230467,3936485,3936663,4083445,3899353,3862915,4024380,4083337,4230284,4105925,4200668,4200851,4098531,4053365,4024563,4053257,4076005,3884777,3884885,4068611,4106103,4060828,4142537,4208137,4193383,4142645,4068428,4208423,4105817,4193097,4024269],"length":1,"stats":{"Line":18}},{"line":592,"address":[4233608,4241154,4248920,4256360],"length":1,"stats":{"Line":10}},{"line":593,"address":[4233834,4249028,4256468,4256586,4233716,4241423,4241278,4249146],"length":1,"stats":{"Line":20}},{"line":595,"address":[3929527,3988741,4171958,4068684,3922071,3959095,3907366,4193398,4017437,3974103,4200867,3862988,4230540,3936678,4121130,3929291,3966433,4179094,3885131,4135974,4157383,4178791,4046391,3914334,3892487,4238107,3907117,4083691,3995975,3899654,4193451,4010247,4238343,3988492,4106118,3870791,4032173,4164519,4098547,3936731,4083927,4068933,4017383,3959398,4193687,3944554,4061333,3878214,3981293,4091078,4157686,4178845,3907063,4091131,4216150,3862931,3877911,4076487,4113527,4010301,3870502,3914401,4230789,4200924,4201173,4150550,3959149,4053611,3996029,3922374,3885367,4185958,4142838,4024636,3952013,3899707,4186011,4068627,4128838,3899943,3981542,4017686,4053847,4098853,4106171,4076198,4113830,4091367,4024579,4113581,4186247,4003165,4024885,4120798,4164573,3944222,4215901,4150301,4039558,4120865,3936967,4135725,4150247,4208491,3988435,4076251,4128535,4223303,4032119,4061084,4046694,4223014,4003111,4039255,4098604,3922125,3929238,4164822,4157437,3966698,4142891,4003414,4046445,4061027,4143127,3944289,3966366,3974157,3974406,4171709,4128589,3914666,4208438,4106407,3892790,3863237,4230483,3885078,4083638,3951959,3981239,4208727,3877965,4010550,4032422,4223067,4215847,4171655,4238054,4135671,3870555,3892541,3952262,4053558,3996278,4039309],"length":1,"stats":{"Line":30}},{"line":596,"address":[4046475,4223332,3922155,3944593,3929299,4068829,4164734,4164603,3966961,4150309,4230958,3863018,3936760,4046879,4039470,4053876,4061502,4113589,4135755,4046733,4179133,4024781,4025054,3959583,3870958,4135733,4178853,4142920,4017725,3929320,3974591,4003195,4106574,4142899,4186040,4172143,4201204,4201342,4046606,4106179,4091160,3944466,4238372,3959179,3907551,3988910,4179279,4091396,3892702,3996190,4208631,3952174,3870563,4068964,4113611,3922413,4120873,4003326,3892975,4150331,4091139,3952043,4084094,4171739,4223207,3892829,4076280,3899736,3914929,4032607,3966737,3988500,4083720,3914431,4098749,4017467,4076516,4200932,4215909,4017598,4053751,4032334,3862996,3878399,3914409,4143294,3885534,3988772,3907278,4136013,4017445,3988637,3892549,3936871,4010462,4010331,3914578,4106436,4135886,4083831,4193459,4150589,4193591,3878253,3988522,4061364,4171997,4024666,4068692,4208499,4061092,4200954,4157871,4098634,4164581,3996317,4010735,4128877,3877973,4068714,4216189,3899972,3863268,3863133,4054014,3870695,3885396,4069102,4164861,3929556,4143156,4230685,3974445,4171870,3937134,4179006,4053640,4128619,4238115,3885139,3966945,4157725,3900110,4106311,4076654,3914913,3974318,3981581,3952021,4157598,3952301,3885271,4061114,4076391,3936739,3944297,3922559,3966463,4114015,4238510,4083699,3981454,3996059,4032461,3959310,3996037,3981323,3996463,4003173,4003599,3907405,3885160,4024644,4186151,4208520,3981301,4157445,4230570,3899847,3899715,4024916,3981727,3878126,4098884,4193716,3922133,4113742,4010589,3877995,4032203,4046453,4091534,4039339,4201069,4216335,3944319,4053619,4113869,4193854,3863406,3870820,3944817,4083956,3907147,4223096,4157467,4128750,3974187,4186276,4193480,3952447,3966441,4017871,4003453,4039317,3922286,4121377,3959437,3929431,4010309,3966610,4223075,4129023,4186019,3907125,4143031,4171717,4238136,4165007,4150462,4238247,4091271,4032181,4121042,4208894,3870584,3936996,4039597,4061229,4230548,4216062,3929694,4099022,4121169,4230820,4098612,4178875,4076259,4106200,3944801,4223470,4215931,3959157,3974165,4120895,4186414,4136159,4150735,3892571,4208756,4128597,4039743,3914705,4121393],"length":1,"stats":{"Line":20}},{"line":599,"address":[],"length":0,"stats":{"Line":10}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[3125231,3028964,2999583,3021828,2991939,3043540,3014692,3050675,3103011,3117892,3132900,3073427,3088004,3080868,3110451,3065987,3036099,3095343,3007251,3058319],"length":1,"stats":{"Line":10}},{"line":632,"address":[2988448,2988640,2988352,2988736,2988304,2988544,2988688,2988928,2988496,2988832,2988784,2988400,2988208,2988256,2988880,2988592],"length":1,"stats":{"Line":0}},{"line":689,"address":[3858177,3860289,3859233,3858609,3858897,3859473,3858465,3860001,3858081,3858369,3858753,3859137,3859329,3858321,3859761,3859377,3860097,3860241,3858129,3858273,3858993,3858417,3858849,3858705,3859425,3858657,3859521,3859569,3859953,3859041,3858513,3859665,3859617,3859089,3859713,3859857,3858225,3860145,3860193,3858801,3859185,3859809,3858561,3860337,3858945,3860049,3859281,3859905],"length":1,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[4229928,4228416,4229934,4229072,4228488,4227600,4227695,4226944,4227016],"length":1,"stats":{"Line":10}},{"line":750,"address":[],"length":0,"stats":{"Line":10}},{"line":751,"address":[2955335,2957896,2955256,2956136,2956215,2957016,2957095,2957975],"length":1,"stats":{"Line":20}},{"line":752,"address":[3826235,3827995,3827115,3826169,3827929,3827049,3825289,3825355],"length":1,"stats":{"Line":20}},{"line":753,"address":[3828033,3827153,3826273,3825393],"length":1,"stats":{"Line":10}},{"line":754,"address":[3825544,3827250,3826424,3825490,3828184,3828130,3826370,3827304],"length":1,"stats":{"Line":20}},{"line":756,"address":[4228816,4228124,4227344,4229601],"length":1,"stats":{"Line":10}},{"line":757,"address":[2955846,2958486,2957606,2956726],"length":1,"stats":{"Line":5}},{"line":760,"address":[2955924,2956804,2957684,2957630,2958564,2956750,2958510,2955870],"length":1,"stats":{"Line":20}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[2987536,2987984,2987312,2987760],"length":1,"stats":{"Line":0}},{"line":808,"address":[2987784,2988008,2987336,2987560],"length":1,"stats":{"Line":0}},{"line":809,"address":[2988087,2987798,2987863,2987574,2987353,2987424,2988022,2987639],"length":1,"stats":{"Line":0}},{"line":810,"address":[3857906,3858032,3857673,3857575,3857954,3857721,3857497,3857799,3857273,3857225,3857351,3857449],"length":1,"stats":{"Line":0}},{"line":813,"address":[2965835,2980132,2962453,2987291,2980160,2958704,2972980,2976757,2983909,2965856,2969605,2973008],"length":1,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[3850197,3835909,3828773,3843061],"length":1,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[3829092,3850516,3843380,3836228],"length":1,"stats":{"Line":0}},{"line":827,"address":[3843404,3829116,3836252,3850540],"length":1,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":837,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[2959326,2973630,2966478,2980782],"length":1,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[3850062,3828638,3842926,3835774],"length":1,"stats":{"Line":0}},{"line":858,"address":[3836412,3843632,3829276,3836480,3843564,3829344,3850768,3850700],"length":1,"stats":{"Line":0}},{"line":859,"address":[2973816,2973752,2966600,2959512,2973893,2966741,2966664,2980904,2980968,2981045,2959589,2959448],"length":1,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[2966797,2959645,2973871,2973919,2966767,2973949,2981023,2981071,2959567,2966719,2981101,2959615],"length":1,"stats":{"Line":0}},{"line":862,"address":[3850966,3836709,3843779,3829491,3829573,3843830,3829542,3836627,3836678,3843861,3850915,3850997],"length":1,"stats":{"Line":0}},{"line":864,"address":[3829566,3843854,3836702,3850990],"length":1,"stats":{"Line":0}},{"line":865,"address":[3836879,3829743,3844031,3851167],"length":1,"stats":{"Line":0}},{"line":868,"address":[3829767,3836903,3851191,3844055],"length":1,"stats":{"Line":0}},{"line":869,"address":[2981581,2960125,2967277,2974429],"length":1,"stats":{"Line":0}},{"line":872,"address":[3830017,3837153,3851441,3844305],"length":1,"stats":{"Line":0}},{"line":874,"address":[3837260,3844412,3830124,3851548],"length":1,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[3848633,3841299,3844641,3851777,3855587,3855776,3848444,3830353,3841488,3834156,3834345,3837489],"length":1,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[2964852,2971997,2979149,2986308],"length":1,"stats":{"Line":0}},{"line":884,"address":[2979176,2972024,2964879,2986335],"length":1,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[2965059,2986515,2972204,2979356],"length":1,"stats":{"Line":0}},{"line":891,"address":[3849248,3856391,3834960,3842103],"length":1,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[3856959,3835528,3849871,3857014,3842671,3842726,3835583,3849816],"length":1,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[2987002,2965546,2972620,2965475,2979843,2972691,2986931,2979772],"length":1,"stats":{"Line":0}},{"line":898,"address":[2979891,2965594,2987050,2972739],"length":1,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[2977117,2962737,2962813,2969889,2969965,2977041,2984269,2984193],"length":1,"stats":{"Line":0}},{"line":907,"address":[3840008,3832872,3854296,3847160],"length":1,"stats":{"Line":0}},{"line":908,"address":[2977350,2970198,2963053,2984509],"length":1,"stats":{"Line":0}},{"line":909,"address":[3854560,3833129,3847417,3840272],"length":1,"stats":{"Line":0}},{"line":910,"address":[2977604,2963307,2984763,2970452],"length":1,"stats":{"Line":0}},{"line":912,"address":[3854677,3840389,3847534,3833246],"length":1,"stats":{"Line":0}},{"line":915,"address":[2977794,2984953,2970785,2963640,2977937,2984889,2964257,2978554,2970578,2971402,2985096,2970642,2963433,2985713,2977730,2963497],"length":1,"stats":{"Line":0}},{"line":916,"address":[3840509,3833366,3847654,3854797],"length":1,"stats":{"Line":0}},{"line":917,"address":[2970690,2963545,2977842,2985001],"length":1,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[3833998,3855429,3848341,3848286,3841141,3855484,3841196,3834053],"length":1,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[2985389,2978230,2971149,2964004,2978301,2985460,2971078,2963933],"length":1,"stats":{"Line":0}},{"line":924,"address":[3855344,3833913,3841056,3848201],"length":1,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[3830681,3845032,3845172,3852308,3852168,3830884,3852105,3837880,3838020,3837817,3830744,3844969],"length":1,"stats":{"Line":0}},{"line":931,"address":[2968057,2975357,2982361,2960905,2968205,2975209,2982509,2961053],"length":1,"stats":{"Line":0}},{"line":933,"address":[3852353,3852444,3838065,3845217,3831020,3830929,3838156,3845308],"length":1,"stats":{"Line":0}},{"line":934,"address":[3838297,3845277,3846651,3832363,3845449,3852715,3853787,3830989,3831161,3831262,3838427,3839499,3845550,3852514,3845378,3838398,3852686,3831090,3838226,3838125,3845579,3831291,3852413,3852585],"length":1,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[2961333,2968485,2975637,2982789],"length":1,"stats":{"Line":0}},{"line":939,"address":[2975930,2961724,2976028,2983082,2968778,2961626,2968876,2983180],"length":1,"stats":{"Line":0}},{"line":940,"address":[2961596,2968748,2975900,2983052],"length":1,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[2976177,2961873,2983329,2969025],"length":1,"stats":{"Line":0}},{"line":945,"address":[3845935,3838783,3831647,3853071],"length":1,"stats":{"Line":0}},{"line":946,"address":[2983289,2961833,2976137,2968985],"length":1,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":0}},{"line":949,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[3831821,3846109,3853325,3839037,3853245,3831901,3846189,3838957],"length":1,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":955,"address":[],"length":0,"stats":{"Line":0}}],"covered":180,"coverable":353},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","poseidon2-circuit-air","src","columns.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\nuse core::mem::size_of;\n\nuse p3_poseidon2_air::Poseidon2Cols;\n\npub const POSEIDON2_LIMBS: usize = 4;\npub const POSEIDON2_PUBLIC_OUTPUT_LIMBS: usize = 2;\n\n/// Columns for a Poseidon2 AIR which computes one permutation per row.\n///\n/// This implements the Poseidon2 Permutation Table specification.\n/// See: https://github.com/Plonky3/Plonky3-recursion/discussions/186\n///\n/// The table implements a 4-limb Poseidon2 permutation supporting:\n/// - Standard chaining (Challenger-style sponge use)\n/// - Merkle-path chaining (MMCS directional hashing)\n/// - Selective limb exposure to the witness via CTL\n/// - Optional MMCS index accumulator\n///\n/// Column layout (per spec section 2):\n/// - Value columns: `poseidon2` (contains in[0..3] and out[0..3]), `mmcs_index_sum`, `mmcs_bit`\n/// - Transparent columns: `new_start`, `merkle_path`, CTL flags and indices\n/// - Selector columns (not in spec): `normal_chain_sel`, `merkle_chain_sel`\n///   These are precomputed to reduce constraint degree to 3.\n#[repr(C)]\npub struct Poseidon2CircuitCols\u003cT, P: PermutationColumns\u003cT\u003e\u003e {\n    /// The p3 Poseidon2 columns containing the permutation state.\n    /// Contains in[0..3] (4 extension limbs input) and out[0..3] (4 extension limbs output).\n    pub poseidon2: P,\n    /// Value: Direction bit for Merkle left/right hashing (only meaningful when merkle_path = 1).\n    /// This is a value column (not transparent) because it's used in constraints with mmcs_index_sum.\n    pub mmcs_bit: T,\n    /// Value column: Optional MMCS accumulator (base field, encodes a u32-like integer).\n    pub mmcs_index_sum: T,\n}\n\npub trait PermutationColumns\u003cT\u003e {}\n\nimpl\u003c\n    T,\n    const WIDTH: usize,\n    const SBOX_DEGREE: u64,\n    const SBOX_REGISTERS: usize,\n    const HALF_FULL_ROUNDS: usize,\n    const PARTIAL_ROUNDS: usize,\n\u003e PermutationColumns\u003cT\u003e\n    for Poseidon2Cols\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e\n{\n}\n\npub const fn num_cols\u003cP: PermutationColumns\u003cu8\u003e\u003e() -\u003e usize {\n    size_of::\u003cPoseidon2CircuitCols\u003cu8, P\u003e\u003e()\n}\n\nimpl\u003cT, P: PermutationColumns\u003cT\u003e\u003e Borrow\u003cPoseidon2CircuitCols\u003cT, P\u003e\u003e for [T] {\n    fn borrow(\u0026self) -\u003e \u0026Poseidon2CircuitCols\u003cT, P\u003e {\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cPoseidon2CircuitCols\u003cT, P\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026shorts[0]\n    }\n}\n\nimpl\u003cT, P: PermutationColumns\u003cT\u003e\u003e BorrowMut\u003cPoseidon2CircuitCols\u003cT, P\u003e\u003e for [T] {\n    fn borrow_mut(\u0026mut self) -\u003e \u0026mut Poseidon2CircuitCols\u003cT, P\u003e {\n        let (prefix, shorts, suffix) = unsafe { self.align_to_mut::\u003cPoseidon2CircuitCols\u003cT, P\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026mut shorts[0]\n    }\n}\n","traces":[{"line":51,"address":[4932672,4932624,4932640,4932656],"length":1,"stats":{"Line":3}},{"line":52,"address":[4932625,4932657,4932673,4932641],"length":1,"stats":{"Line":3}},{"line":56,"address":[1968816],"length":1,"stats":{"Line":7}},{"line":57,"address":[4140029],"length":1,"stats":{"Line":7}},{"line":58,"address":[],"length":0,"stats":{"Line":7}},{"line":59,"address":[4140192],"length":1,"stats":{"Line":7}},{"line":60,"address":[],"length":0,"stats":{"Line":7}},{"line":61,"address":[2073871,2073896],"length":1,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":14},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","poseidon2-circuit-air","src","lib.rs"],"content":"//! An AIR for the Poseidon2 table for recursion. Handles sponge operations and compressions.\n\n#![no_std]\n\nextern crate alloc;\n\nmod air;\nmod columns;\nmod public_types;\n\npub use air::*;\npub use columns::*;\npub use public_types::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","poseidon2-circuit-air","src","public_types.rs"],"content":"//! Public types for the Poseidon2 circuit AIR.\n//!\n//! Defines abstracted field-specific parameters for\n//! the Poseidon2 circuit AIR for commonly used configurations.\n\nuse p3_baby_bear::{BabyBear, GenericPoseidon2LinearLayersBabyBear};\nuse p3_circuit::tables::Poseidon2Params;\nuse p3_koala_bear::{GenericPoseidon2LinearLayersKoalaBear, KoalaBear};\n\nuse crate::Poseidon2CircuitAir;\n\n/// Poseidon2 configuration for BabyBear with D=4, WIDTH=16.\npub struct BabyBearD4Width16;\n\nimpl Poseidon2Params for BabyBearD4Width16 {\n    type BaseField = BabyBear;\n    const D: usize = 4;\n    const WIDTH: usize = 16;\n    const RATE_EXT: usize = 2;\n    const CAPACITY_EXT: usize = 2;\n    const SBOX_DEGREE: u64 = 7;\n    const SBOX_REGISTERS: usize = 1;\n    const HALF_FULL_ROUNDS: usize = 4;\n    const PARTIAL_ROUNDS: usize = 13;\n}\n\n/// Poseidon2 configuration for BabyBear with D=4, WIDTH=24.\npub struct BabyBearD4Width24;\n\nimpl Poseidon2Params for BabyBearD4Width24 {\n    type BaseField = BabyBear;\n    const D: usize = 4;\n    const WIDTH: usize = 24;\n    const RATE_EXT: usize = 4;\n    const CAPACITY_EXT: usize = 2;\n    const SBOX_DEGREE: u64 = 7;\n    const SBOX_REGISTERS: usize = 1;\n    const HALF_FULL_ROUNDS: usize = 4;\n    const PARTIAL_ROUNDS: usize = 21;\n}\n\n/// Poseidon2 configuration for KoalaBear with D=4, WIDTH=16.\npub struct KoalaBearD4Width16;\n\nimpl Poseidon2Params for KoalaBearD4Width16 {\n    type BaseField = KoalaBear;\n    const D: usize = 4;\n    const WIDTH: usize = 16;\n    const RATE_EXT: usize = 2;\n    const CAPACITY_EXT: usize = 2;\n    const SBOX_DEGREE: u64 = 3;\n    const SBOX_REGISTERS: usize = 0;\n    const HALF_FULL_ROUNDS: usize = 4;\n    const PARTIAL_ROUNDS: usize = 20;\n}\n\n/// Poseidon2 configuration for KoalaBear with D=4, WIDTH=24.\npub struct KoalaBearD4Width24;\n\nimpl Poseidon2Params for KoalaBearD4Width24 {\n    type BaseField = KoalaBear;\n    const D: usize = 4;\n    const WIDTH: usize = 24;\n    const RATE_EXT: usize = 4;\n    const CAPACITY_EXT: usize = 2;\n    const SBOX_DEGREE: u64 = 3;\n    const SBOX_REGISTERS: usize = 0;\n    const HALF_FULL_ROUNDS: usize = 4;\n    const PARTIAL_ROUNDS: usize = 23;\n}\n\n/// BabyBear Poseidon2 circuit AIR with D=4, WIDTH=16.\n/// Uses constants from `BabyBearD4Width16` configuration.\npub type Poseidon2CircuitAirBabyBearD4Width16 = Poseidon2CircuitAir\u003c\n    BabyBear,\n    GenericPoseidon2LinearLayersBabyBear,\n    { BabyBearD4Width16::D },\n    { BabyBearD4Width16::WIDTH },\n    { BabyBearD4Width16::WIDTH_EXT },\n    { BabyBearD4Width16::RATE_EXT },\n    { BabyBearD4Width16::CAPACITY_EXT },\n    { BabyBearD4Width16::SBOX_DEGREE },\n    { BabyBearD4Width16::SBOX_REGISTERS },\n    { BabyBearD4Width16::HALF_FULL_ROUNDS },\n    { BabyBearD4Width16::PARTIAL_ROUNDS },\n\u003e;\n\n/// BabyBear Poseidon2 circuit AIR with D=4, WIDTH=24.\n/// Uses constants from `BabyBearD4Width24` configuration.\npub type Poseidon2CircuitAirBabyBearD4Width24 = Poseidon2CircuitAir\u003c\n    BabyBear,\n    GenericPoseidon2LinearLayersBabyBear,\n    { BabyBearD4Width24::D },\n    { BabyBearD4Width24::WIDTH },\n    { BabyBearD4Width24::WIDTH_EXT },\n    { BabyBearD4Width24::RATE_EXT },\n    { BabyBearD4Width24::CAPACITY_EXT },\n    { BabyBearD4Width24::SBOX_DEGREE },\n    { BabyBearD4Width24::SBOX_REGISTERS },\n    { BabyBearD4Width24::HALF_FULL_ROUNDS },\n    { BabyBearD4Width24::PARTIAL_ROUNDS },\n\u003e;\n\n/// KoalaBear Poseidon2 circuit AIR with D=4, WIDTH=16.\n/// Uses constants from `KoalaBearD4Width16` configuration.\npub type Poseidon2CircuitAirKoalaBearD4Width16 = Poseidon2CircuitAir\u003c\n    KoalaBear,\n    GenericPoseidon2LinearLayersKoalaBear,\n    { KoalaBearD4Width16::D },\n    { KoalaBearD4Width16::WIDTH },\n    { KoalaBearD4Width16::WIDTH_EXT },\n    { KoalaBearD4Width16::RATE_EXT },\n    { KoalaBearD4Width16::CAPACITY_EXT },\n    { KoalaBearD4Width16::SBOX_DEGREE },\n    { KoalaBearD4Width16::SBOX_REGISTERS },\n    { KoalaBearD4Width16::HALF_FULL_ROUNDS },\n    { KoalaBearD4Width16::PARTIAL_ROUNDS },\n\u003e;\n\n/// KoalaBear Poseidon2 circuit AIR with D=4, WIDTH=24.\n/// Uses constants from `KoalaBearD4Width24` configuration.\npub type Poseidon2CircuitAirKoalaBearD4Width24 = Poseidon2CircuitAir\u003c\n    KoalaBear,\n    GenericPoseidon2LinearLayersKoalaBear,\n    { KoalaBearD4Width24::D },\n    { KoalaBearD4Width24::WIDTH },\n    { KoalaBearD4Width24::WIDTH_EXT },\n    { KoalaBearD4Width24::RATE_EXT },\n    { KoalaBearD4Width24::CAPACITY_EXT },\n    { KoalaBearD4Width24::SBOX_DEGREE },\n    { KoalaBearD4Width24::SBOX_REGISTERS },\n    { KoalaBearD4Width24::HALF_FULL_ROUNDS },\n    { KoalaBearD4Width24::PARTIAL_ROUNDS },\n\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","challenger","circuit.rs"],"content":"//! Circuit-based challenger implementation.\n\nuse alloc::vec::Vec;\n\nuse p3_circuit::CircuitBuilder;\n// TODO: Replace with Poseidon2 perm once integrated.\nuse p3_field::Field;\n\nuse crate::Target;\nuse crate::traits::RecursiveChallenger;\n\n/// Concrete challenger implementation for Fiat-Shamir operations in circuits.\npub struct CircuitChallenger\u003cconst RATE: usize\u003e {\n    /// Buffer of field elements waiting to be absorbed\n    absorb_buffer: Vec\u003cTarget\u003e,\n    /// Whether the buffer has been flushed (absorbed) since the last observation\n    buffer_flushed: bool,\n}\n\nimpl\u003cconst RATE: usize\u003e CircuitChallenger\u003cRATE\u003e {\n    /// Create a new circuit challenger with empty state.\n    pub const fn new() -\u003e Self {\n        Self {\n            absorb_buffer: Vec::new(),\n            buffer_flushed: true,\n        }\n    }\n\n    /// Flush the absorb buffer, performing the actual hash absorb operation.\n    fn flush_absorb\u003cF: Field\u003e(\u0026mut self, _circuit: \u0026mut CircuitBuilder\u003cF\u003e) {\n        if self.buffer_flushed || self.absorb_buffer.is_empty() {\n            return;\n        }\n\n        // Hash absorb removed; placeholder until Poseidon2 perm is wired.\n        self.absorb_buffer.clear();\n        self.buffer_flushed = true;\n    }\n}\n\nimpl\u003cconst RATE: usize\u003e Default for CircuitChallenger\u003cRATE\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cF: Field, const RATE: usize\u003e RecursiveChallenger\u003cF\u003e for CircuitChallenger\u003cRATE\u003e {\n    fn observe(\u0026mut self, _circuit: \u0026mut CircuitBuilder\u003cF\u003e, value: Target) {\n        self.absorb_buffer.push(value);\n        self.buffer_flushed = false;\n    }\n\n    fn sample(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cF\u003e) -\u003e Target {\n        // Flush any pending observations\n        self.flush_absorb(circuit);\n\n        // TODO: replace with Poseidon2 perm squeeze; for now, sample as public input.\n        circuit.alloc_public_input(\"sampled challenge\")\n    }\n\n    fn clear(\u0026mut self) {\n        self.absorb_buffer.clear();\n        self.buffer_flushed = true;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n\n    use super::*;\n\n    const DEFAULT_CHALLENGER_RATE: usize = 8;\n\n    #[test]\n    fn test_circuit_challenger_observe_sample() {\n        let mut circuit = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let mut challenger = CircuitChallenger::\u003cDEFAULT_CHALLENGER_RATE\u003e::new();\n\n        let val1 = circuit.add_const(BabyBear::ONE);\n        let val2 = circuit.add_const(BabyBear::TWO);\n        challenger.observe(\u0026mut circuit, val1);\n        challenger.observe(\u0026mut circuit, val2);\n\n        let challenge = challenger.sample(\u0026mut circuit);\n        assert!(challenge.0 \u003e 0);\n    }\n\n    #[test]\n    fn test_circuit_challenger_sample_vec() {\n        let mut circuit = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let mut challenger = CircuitChallenger::\u003cDEFAULT_CHALLENGER_RATE\u003e::new();\n\n        let challenges = challenger.sample_vec(\u0026mut circuit, 3);\n        assert_eq!(challenges.len(), 3);\n    }\n\n    #[test]\n    fn test_circuit_challenger_clear() {\n        let mut circuit = CircuitBuilder::\u003cBabyBear\u003e::new();\n        let mut challenger = CircuitChallenger::\u003cDEFAULT_CHALLENGER_RATE\u003e::new();\n\n        let val = circuit.add_const(BabyBear::ONE);\n        RecursiveChallenger::\u003cBabyBear\u003e::observe(\u0026mut challenger, \u0026mut circuit, val);\n\n        assert!(!challenger.buffer_flushed);\n        assert_eq!(challenger.absorb_buffer.len(), 1);\n\n        RecursiveChallenger::\u003cBabyBear\u003e::clear(\u0026mut challenger);\n\n        assert!(challenger.buffer_flushed);\n        assert!(challenger.absorb_buffer.is_empty());\n    }\n}\n","traces":[{"line":22,"address":[2045376],"length":1,"stats":{"Line":6}},{"line":24,"address":[2756925],"length":1,"stats":{"Line":7}},{"line":30,"address":[4535648],"length":1,"stats":{"Line":6}},{"line":31,"address":[3154866],"length":1,"stats":{"Line":6}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[3154896],"length":1,"stats":{"Line":6}},{"line":37,"address":[3154905],"length":1,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[4503184],"length":1,"stats":{"Line":6}},{"line":49,"address":[2064882],"length":1,"stats":{"Line":6}},{"line":50,"address":[4537868],"length":1,"stats":{"Line":6}},{"line":53,"address":[4503120],"length":1,"stats":{"Line":6}},{"line":55,"address":[2064802],"length":1,"stats":{"Line":6}},{"line":58,"address":[2758331],"length":1,"stats":{"Line":6}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}}],"covered":15,"coverable":18},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","challenger","mod.rs"],"content":"//! Challenger implementations for recursive Fiat-Shamir transformations.\n\nmod circuit;\n\npub use circuit::CircuitChallenger;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","generation.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\n\nuse itertools::zip_eq;\nuse p3_air::Air;\nuse p3_batch_stark::config::observe_instance_binding;\nuse p3_batch_stark::{BatchProof, CommonData};\nuse p3_challenger::{CanObserve, CanSample, CanSampleBits, FieldChallenger, GrindingChallenger};\nuse p3_commit::{BatchOpening, Mmcs, Pcs, PolynomialSpace};\nuse p3_field::{BasedVectorSpace, PrimeCharacteristicRing, PrimeField, TwoAdicField};\nuse p3_fri::{FriProof, TwoAdicFriPcs};\nuse p3_uni_stark::{\n    Domain, Proof, StarkGenericConfig, SymbolicAirBuilder, Val, VerifierConstraintFolder,\n    get_log_num_quotient_chunks,\n};\nuse thiserror::Error;\nuse tracing::debug_span;\n\n#[derive(Debug, Error)]\npub enum GenerationError {\n    #[error(\"Missing parameter for challenge generation\")]\n    MissingParameterError,\n\n    #[error(\n        \"Invalid number of parameters provided for challenge generation: got {0}, expected {1}\"\n    )]\n    InvalidParameterCount(usize, usize),\n\n    #[error(\"The FRI batch randomization does not correspond to the ZK setting.\")]\n    RandomizationError,\n\n    #[error(\"Witness check failed during challenge generation.\")]\n    InvalidPowWitness,\n\n    #[error(\"Invalid proof shape: {0}\")]\n    InvalidProofShape(\u0026'static str),\n}\n\n/// A type alias for a single opening point and its values.\ntype PointOpening\u003cSC\u003e = (\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    Vec\u003c\u003cSC as StarkGenericConfig\u003e::Challenge\u003e,\n);\n\n/// A type alias for all openings within a specific domain.\ntype DomainOpenings\u003cSC\u003e = Vec\u003c(Domain\u003cSC\u003e, Vec\u003cPointOpening\u003cSC\u003e\u003e)\u003e;\n\n/// A type alias for a commitment and its associated domain openings.\ntype CommitmentWithOpenings\u003cSC\u003e = (\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n        \u003cSC as StarkGenericConfig\u003e::Challenge,\n        \u003cSC as StarkGenericConfig\u003e::Challenger,\n    \u003e\u003e::Commitment,\n    DomainOpenings\u003cSC\u003e,\n);\n\n/// The final type alias for a slice of commitments with their openings.\ntype ComsWithOpenings\u003cSC\u003e = [CommitmentWithOpenings\u003cSC\u003e];\n\n/// Trait which defines the methods necessary\n/// for a Pcs to generate challenge values.\npub trait PcsGeneration\u003cSC: StarkGenericConfig, OpeningProof\u003e {\n    fn generate_challenges(\n        \u0026self,\n        config: \u0026SC,\n        challenger: \u0026mut SC::Challenger,\n        coms_to_verify: \u0026ComsWithOpenings\u003cSC\u003e,\n        opening_proof: \u0026OpeningProof,\n        // Depending on the `OpeningProof`, we might need additional parameters. For example, for a `FriProof`, we need the `log_max_height` to sample query indices.\n        extra_params: Option\u003c\u0026[usize]\u003e,\n    ) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, GenerationError\u003e;\n\n    fn num_challenges(\n        opening_proof: \u0026OpeningProof,\n        extra_params: Option\u003c\u0026[usize]\u003e,\n    ) -\u003e Result\u003cusize, GenerationError\u003e;\n}\n\n// TODO: This could be used on the Plonky3 side as well.\n/// Generates the challenges used in the verification of a STARK proof.\npub fn generate_challenges\u003cSC: StarkGenericConfig, A\u003e(\n    air: \u0026A,\n    config: \u0026SC,\n    proof: \u0026Proof\u003cSC\u003e,\n    public_values: \u0026[Val\u003cSC\u003e],\n    extra_params: Option\u003c\u0026[usize]\u003e,\n) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, GenerationError\u003e\nwhere\n    A: Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e + for\u003c'a\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e,\n    SC::Pcs: PcsGeneration\u003cSC, \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    let Proof {\n        commitments,\n        opened_values,\n        opening_proof,\n        degree_bits,\n    } = proof;\n\n    let preprocessed = air.preprocessed_trace();\n    let preprocessed_width = preprocessed.as_ref().map(|m| m.width).unwrap_or(0);\n\n    let degree = 1 \u003c\u003c degree_bits;\n    let pcs = config.pcs();\n    let log_quotient_degree = get_log_num_quotient_chunks::\u003cVal\u003cSC\u003e, A\u003e(\n        air,\n        preprocessed_width,\n        public_values.len(),\n        config.is_zk(),\n    );\n    let quotient_degree = 1 \u003c\u003c (log_quotient_degree + config.is_zk());\n\n    let trace_domain = pcs.natural_domain_for_degree(degree);\n    let init_trace_domain = pcs.natural_domain_for_degree(degree \u003e\u003e (config.is_zk()));\n    let quotient_domain =\n        trace_domain.create_disjoint_domain(1 \u003c\u003c (degree_bits + log_quotient_degree));\n    let quotient_chunks_domains = quotient_domain.split_domains(quotient_degree);\n\n    let randomized_quotient_chunks_domains = quotient_chunks_domains\n        .iter()\n        .map(|domain| pcs.natural_domain_for_degree(domain.size() \u003c\u003c (config.is_zk())))\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let preprocessed_commit = if preprocessed_width \u003e 0 {\n        assert_eq!(config.is_zk(), 0); // TODO: preprocessed columns not supported in zk mode\n\n        let prep = preprocessed.expect(\"If the width is \u003e 0, then the commit exists.\");\n        let height = prep.values.len() / preprocessed_width;\n\n        if height != trace_domain.size() {\n            return Err(GenerationError::InvalidProofShape(\n                \"Verifier's preprocessed trace height must be equal to trace domain size\",\n            ));\n        }\n\n        let (preprocessed_commit, _) = debug_span!(\"process preprocessed trace\")\n            .in_scope(|| pcs.commit([(trace_domain, prep)]));\n        Some(preprocessed_commit)\n    } else {\n        None\n    };\n\n    let num_challenges = 3 // alpha, zeta and zeta_next\n     + SC::Pcs::num_challenges(opening_proof, extra_params)?;\n\n    let mut challenges = Vec::with_capacity(num_challenges);\n\n    let mut challenger = config.initialise_challenger();\n\n    challenger.observe(Val::\u003cSC\u003e::from_usize(*degree_bits));\n    challenger.observe(Val::\u003cSC\u003e::from_usize(*degree_bits - config.is_zk()));\n\n    challenger.observe(Val::\u003cSC\u003e::from_usize(preprocessed_width));\n    challenger.observe(commitments.trace.clone());\n    if preprocessed_width \u003e 0 {\n        challenger.observe(\n            preprocessed_commit\n                .as_ref()\n                .expect(\"If the width is \u003e 0, then the commit exists.\")\n                .clone(),\n        );\n    }\n    challenger.observe_slice(public_values);\n\n    // Get the first Fiat-Shamir challenge which will be used to combine all constraint polynomials into a single polynomial.\n    challenges.push(challenger.sample_algebra_element());\n    challenger.observe(commitments.quotient_chunks.clone());\n\n    if let Some(r_commit) = commitments.random.clone() {\n        challenger.observe(r_commit);\n    }\n\n    // Get an out-of-domain point to open our values at.\n    let zeta = challenger.sample_algebra_element();\n    challenges.push(zeta);\n    let zeta_next = init_trace_domain.next_point(zeta).unwrap();\n    challenges.push(zeta_next);\n\n    let mut coms_to_verify = if let Some(r_commit) = \u0026commitments.random {\n        let random_values = opened_values\n            .random\n            .as_ref()\n            .ok_or(GenerationError::RandomizationError)?;\n        vec![(\n            r_commit.clone(),\n            vec![(trace_domain, vec![(zeta, random_values.clone())])],\n        )]\n    } else {\n        vec![]\n    };\n    coms_to_verify.extend(vec![\n        (\n            commitments.trace.clone(),\n            vec![(\n                trace_domain,\n                vec![\n                    (zeta, opened_values.trace_local.clone()),\n                    (zeta_next, opened_values.trace_next.clone()),\n                ],\n            )],\n        ),\n        (\n            commitments.quotient_chunks.clone(),\n            // Check the commitment on the randomized domains.\n            zip_eq(\n                randomized_quotient_chunks_domains.iter(),\n                opened_values.quotient_chunks.clone(),\n            )\n            .map(|(domain, values)| (*domain, vec![(zeta, values)]))\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        ),\n    ]);\n\n    // Add preprocessed commitment verification if present\n    if preprocessed_width \u003e 0 {\n        // If preprocessed_width \u003e 0, then preprocessed opened values must be present.\n        let opened_prep_local =\n            \u0026opened_values\n                .preprocessed_local\n                .clone()\n                .ok_or(GenerationError::InvalidProofShape(\n                    \"Missing preprocessed local opened values\",\n                ))?;\n\n        let opened_prep_next =\n            \u0026opened_values\n                .preprocessed_next\n                .clone()\n                .ok_or(GenerationError::InvalidProofShape(\n                    \"Missing preprocessed next opened values\",\n                ))?;\n\n        coms_to_verify.push((\n            preprocessed_commit.unwrap(),\n            vec![(\n                trace_domain,\n                vec![\n                    (zeta, opened_prep_local.clone()),\n                    (zeta_next, opened_prep_next.clone()),\n                ],\n            )],\n        ));\n    }\n\n    let pcs_challenges = pcs.generate_challenges(\n        config,\n        \u0026mut challenger,\n        \u0026coms_to_verify,\n        opening_proof,\n        extra_params,\n    )?;\n\n    challenges.extend(pcs_challenges);\n\n    Ok(challenges)\n}\n\n/// Generates the challenges used in the verification of a batch-STARK proof.\npub fn generate_batch_challenges\u003cSC: StarkGenericConfig, A\u003e(\n    airs: \u0026[A],\n    config: \u0026SC,\n    proof: \u0026BatchProof\u003cSC\u003e,\n    public_values: \u0026[Vec\u003cVal\u003cSC\u003e\u003e],\n    extra_params: Option\u003c\u0026[usize]\u003e,\n    common_data: \u0026CommonData\u003cSC\u003e,\n) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, GenerationError\u003e\nwhere\n    A: Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e + for\u003c'a\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e,\n    SC::Pcs: PcsGeneration\u003cSC, \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    debug_assert_eq!(config.is_zk(), 0, \"batch recursion assumes non-ZK\");\n    if SC::Pcs::ZK {\n        return Err(GenerationError::InvalidProofShape(\n            \"batch-STARK challenge generation does not support ZK mode\",\n        ));\n    }\n\n    let BatchProof {\n        commitments,\n        opened_values,\n        opening_proof,\n        degree_bits,\n    } = proof;\n\n    let n_instances = airs.len();\n    if n_instances == 0\n        || opened_values.instances.len() != n_instances\n        || public_values.len() != n_instances\n        || degree_bits.len() != n_instances\n    {\n        return Err(GenerationError::InvalidProofShape(\n            \"instance metadata length mismatch\",\n        ));\n    }\n\n    let pcs = config.pcs();\n    let mut challenger = config.initialise_challenger();\n\n    challenger.observe_base_as_algebra_element::\u003cSC::Challenge\u003e(Val::\u003cSC\u003e::from_usize(n_instances));\n\n    for inst in \u0026opened_values.instances {\n        if inst\n            .quotient_chunks\n            .iter()\n            .any(|c| c.len() != SC::Challenge::DIMENSION)\n        {\n            return Err(GenerationError::InvalidProofShape(\n                \"invalid quotient chunk length\",\n            ));\n        }\n    }\n\n    let mut preprocessed_widths = Vec::with_capacity(airs.len());\n    let mut log_quotient_degrees = Vec::with_capacity(n_instances);\n    let mut quotient_degrees = Vec::with_capacity(n_instances);\n    for (i, (air, pv)) in airs.iter().zip(public_values.iter()).enumerate() {\n        let pre_w = common_data\n            .preprocessed\n            .as_ref()\n            .and_then(|g| g.instances[i].as_ref().map(|m| m.width))\n            .unwrap_or(0);\n        preprocessed_widths.push(pre_w);\n\n        let log_qd =\n            get_log_num_quotient_chunks::\u003cVal\u003cSC\u003e, A\u003e(air, pre_w, pv.len(), config.is_zk());\n        let quotient_degree = 1 \u003c\u003c (log_qd + config.is_zk());\n        log_quotient_degrees.push(log_qd);\n        quotient_degrees.push(quotient_degree);\n    }\n\n    for i in 0..n_instances {\n        let ext_db = degree_bits[i];\n        let base_db =\n            ext_db\n                .checked_sub(config.is_zk())\n                .ok_or(GenerationError::InvalidProofShape(\n                    \"extended degree smaller than zk adjustment\",\n                ))?;\n\n        observe_instance_binding::\u003cSC\u003e(\n            \u0026mut challenger,\n            ext_db,\n            base_db,\n            A::width(\u0026airs[i]),\n            quotient_degrees[i],\n        );\n    }\n\n    challenger.observe(commitments.main.clone());\n    for pv in public_values {\n        challenger.observe_slice(pv);\n    }\n    for pre_w in \u0026preprocessed_widths {\n        challenger.observe_base_as_algebra_element::\u003cSC::Challenge\u003e(Val::\u003cSC\u003e::from_usize(*pre_w));\n    }\n    if let Some(global) = \u0026common_data.preprocessed {\n        challenger.observe(global.commitment.clone());\n    }\n\n    let alpha = challenger.sample_algebra_element();\n\n    challenger.observe(commitments.quotient_chunks.clone());\n    let zeta = challenger.sample_algebra_element();\n\n    let ext_trace_domains: Vec\u003c_\u003e = degree_bits\n        .iter()\n        .map(|\u0026ext_db| pcs.natural_domain_for_degree(1 \u003c\u003c ext_db))\n        .collect();\n\n    let mut coms_to_verify = Vec::new();\n\n    let trace_round = ext_trace_domains\n        .iter()\n        .zip(opened_values.instances.iter())\n        .map(|(ext_dom, inst)| {\n            let zeta_next = ext_dom\n                .next_point(zeta)\n                .ok_or(GenerationError::InvalidProofShape(\n                    \"trace domain lacks next point\",\n                ))?;\n            Ok((\n                *ext_dom,\n                vec![\n                    (zeta, inst.trace_local.clone()),\n                    (zeta_next, inst.trace_next.clone()),\n                ],\n            ))\n        })\n        .collect::\u003cResult\u003cVec\u003c_\u003e, GenerationError\u003e\u003e()?;\n    coms_to_verify.push((commitments.main.clone(), trace_round));\n\n    let quotient_domains: Vec\u003cVec\u003c_\u003e\u003e = degree_bits\n        .iter()\n        .zip(ext_trace_domains.iter())\n        .zip(log_quotient_degrees.iter())\n        .map(|((\u0026ext_db, ext_dom), \u0026log_qd)| {\n            let base_db = ext_db - config.is_zk();\n            let q_domain = ext_dom.create_disjoint_domain(1 \u003c\u003c (base_db + log_qd + config.is_zk()));\n            q_domain.split_domains(1 \u003c\u003c (log_qd + config.is_zk()))\n        })\n        .collect();\n\n    let mut quotient_round = Vec::new();\n    for (domains, inst) in quotient_domains.iter().zip(opened_values.instances.iter()) {\n        if inst.quotient_chunks.len() != domains.len() {\n            return Err(GenerationError::InvalidProofShape(\n                \"quotient chunk count mismatch\",\n            ));\n        }\n        for (domain, values) in domains.iter().zip(inst.quotient_chunks.iter()) {\n            quotient_round.push((*domain, vec![(zeta, values.clone())]));\n        }\n    }\n    coms_to_verify.push((commitments.quotient_chunks.clone(), quotient_round));\n\n    if let Some(global) = \u0026common_data.preprocessed {\n        let mut pre_round = Vec::with_capacity(global.matrix_to_instance.len());\n\n        for (matrix_index, \u0026inst_idx) in global.matrix_to_instance.iter().enumerate() {\n            let pre_w = preprocessed_widths[inst_idx];\n            if pre_w == 0 {\n                return Err(GenerationError::InvalidProofShape(\n                    \"preprocessed width is zero but commitment exists\",\n                ));\n            }\n\n            let inst = \u0026opened_values.instances[inst_idx];\n            let local =\n                inst.preprocessed_local\n                    .as_ref()\n                    .ok_or(GenerationError::InvalidProofShape(\n                        \"preprocessed local values should exist\",\n                    ))?;\n            let next =\n                inst.preprocessed_next\n                    .as_ref()\n                    .ok_or(GenerationError::InvalidProofShape(\n                        \"preprocessed next values should exist\",\n                    ))?;\n\n            // Validate that the preprocessed data's base degree matches what we expect.\n            let ext_db = degree_bits[inst_idx];\n            let expected_base_db = ext_db - config.is_zk();\n\n            let meta =\n                global.instances[inst_idx]\n                    .as_ref()\n                    .ok_or(GenerationError::InvalidProofShape(\n                        \"Missing preprocessed instance metadata\",\n                    ))?;\n            if meta.matrix_index != matrix_index || meta.degree_bits != expected_base_db {\n                return Err(GenerationError::InvalidProofShape(\n                    \"Preprocessed instance metadata mismatch\",\n                ));\n            }\n\n            let base_db = meta.degree_bits;\n            let pre_domain = pcs.natural_domain_for_degree(1 \u003c\u003c base_db);\n            let zeta_next_i = ext_trace_domains[inst_idx].next_point(zeta).ok_or(\n                GenerationError::InvalidProofShape(\"Preprocessed domain lacks next point\"),\n            )?;\n\n            pre_round.push((\n                pre_domain,\n                vec![(zeta, local.clone()), (zeta_next_i, next.clone())],\n            ));\n        }\n\n        coms_to_verify.push((global.commitment.clone(), pre_round));\n    }\n\n    let pcs_challenges = pcs.generate_challenges(\n        config,\n        \u0026mut challenger,\n        \u0026coms_to_verify,\n        opening_proof,\n        extra_params,\n    )?;\n\n    let mut challenges = Vec::with_capacity(2 + pcs_challenges.len());\n    challenges.push(alpha);\n    challenges.push(zeta);\n    challenges.extend(pcs_challenges);\n\n    Ok(challenges)\n}\n\ntype InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e = FriProof\u003c\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    FriMmcs,\n    Val\u003cSC\u003e,\n    Vec\u003cBatchOpening\u003cVal\u003cSC\u003e, InputMmcs\u003e\u003e,\n\u003e;\n\nimpl\u003cSC: StarkGenericConfig, Dft, InputMmcs: Mmcs\u003cVal\u003cSC\u003e\u003e, FriMmcs: Mmcs\u003cSC::Challenge\u003e\u003e\n    PcsGeneration\u003cSC, InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e\u003e\n    for TwoAdicFriPcs\u003cVal\u003cSC\u003e, Dft, InputMmcs, FriMmcs\u003e\nwhere\n    Val\u003cSC\u003e: TwoAdicField + PrimeField,\n    SC::Challenger: FieldChallenger\u003cVal\u003cSC\u003e\u003e\n        + GrindingChallenger\u003cWitness = Val\u003cSC\u003e\u003e\n        + CanObserve\u003cFriMmcs::Commitment\u003e,\n{\n    fn generate_challenges(\n        \u0026self,\n        _config: \u0026SC,\n        challenger: \u0026mut SC::Challenger,\n        coms_to_verify: \u0026ComsWithOpenings\u003cSC\u003e,\n        opening_proof: \u0026InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e,\n        extra_params: Option\u003c\u0026[usize]\u003e,\n    ) -\u003e Result\u003cVec\u003cSC::Challenge\u003e, GenerationError\u003e {\n        let num_challenges =\n            \u003cSelf as PcsGeneration\u003cSC, InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e\u003e\u003e::num_challenges(\n                opening_proof,\n                None,\n            )?;\n        let mut challenges = Vec::with_capacity(num_challenges);\n\n        // Observe all openings.\n        for (_, round) in coms_to_verify {\n            for (_, mat) in round {\n                for (_, point) in mat {\n                    point\n                        .iter()\n                        .for_each(|\u0026opening| challenger.observe_algebra_element(opening));\n                }\n            }\n        }\n\n        challenges.push(challenger.sample_algebra_element());\n\n        // Get `beta` challenges for the FRI rounds.\n        opening_proof.commit_phase_commits.iter().for_each(|comm| {\n            // To match with the prover (and for security purposes),\n            // we observe the commitment before sampling the challenge.\n            challenger.observe(comm.clone());\n            challenges.push(challenger.sample_algebra_element());\n        });\n\n        // Observe all coefficients of the final polynomial.\n        opening_proof\n            .final_poly\n            .iter()\n            .for_each(|x| challenger.observe_algebra_element(*x));\n\n        let params = extra_params.ok_or(GenerationError::MissingParameterError)?;\n\n        if params.len() != 2 {\n            return Err(GenerationError::InvalidParameterCount(params.len(), 2));\n        }\n\n        // Check PoW witness.\n        challenger.observe(opening_proof.pow_witness);\n\n        // Sample a challenge as H(transcript || pow_witness). The circuit later\n        // verifies that the challenge begins with the required number of leading zeros.\n        let rand_f: Val\u003cSC\u003e = challenger.sample();\n        let rand_usize = rand_f.as_canonical_biguint().to_u64_digits()[0] as usize;\n        challenges.push(SC::Challenge::from_usize(rand_usize));\n\n        let log_height_max = params[1];\n        let log_global_max_height = opening_proof.commit_phase_commits.len() + log_height_max;\n        for _ in \u0026opening_proof.query_proofs {\n            // For each query proof, we start by generating the random index.\n            challenges.push(SC::Challenge::from_usize(\n                challenger.sample_bits(log_global_max_height),\n            ));\n        }\n\n        Ok(challenges)\n    }\n\n    fn num_challenges(\n        opening_proof: \u0026InnerFriProof\u003cSC, InputMmcs, FriMmcs\u003e,\n        _extra_params: Option\u003c\u0026[usize]\u003e,\n    ) -\u003e Result\u003cusize, GenerationError\u003e {\n        let num_challenges =\n            1 + opening_proof.commit_phase_commits.len() + opening_proof.query_proofs.len();\n\n        Ok(num_challenges)\n    }\n}\n","traces":[{"line":81,"address":[2555408,2565108,2560819],"length":1,"stats":{"Line":3}},{"line":92,"address":[2555585],"length":1,"stats":{"Line":3}},{"line":93,"address":[2958153],"length":1,"stats":{"Line":3}},{"line":94,"address":[2958178],"length":1,"stats":{"Line":3}},{"line":95,"address":[2555658],"length":1,"stats":{"Line":3}},{"line":96,"address":[2555683],"length":1,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[4059984,4059920,4069264,4069269],"length":1,"stats":{"Line":10}},{"line":102,"address":[4060070],"length":1,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[2958511],"length":1,"stats":{"Line":3}},{"line":110,"address":[2556220,2556069],"length":1,"stats":{"Line":3}},{"line":112,"address":[2556213],"length":1,"stats":{"Line":3}},{"line":113,"address":[2556246],"length":1,"stats":{"Line":3}},{"line":114,"address":[2958884],"length":1,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[4060655],"length":1,"stats":{"Line":3}},{"line":118,"address":[2959021],"length":1,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":9}},{"line":123,"address":[2959226,2960764,2959201],"length":1,"stats":{"Line":6}},{"line":124,"address":[2959236,2959341],"length":1,"stats":{"Line":4}},{"line":126,"address":[2959463],"length":1,"stats":{"Line":2}},{"line":127,"address":[2959625,2959561,2959694],"length":1,"stats":{"Line":4}},{"line":129,"address":[2959679,2959731],"length":1,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[2557947,2557325,2557806,2557208],"length":1,"stats":{"Line":8}},{"line":136,"address":[4061914,4062117,4062193,4069888,4069904],"length":1,"stats":{"Line":8}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[2959207],"length":1,"stats":{"Line":1}},{"line":142,"address":[2558414,2558463],"length":1,"stats":{"Line":3}},{"line":143,"address":[2556755,2558298,2564995],"length":1,"stats":{"Line":6}},{"line":145,"address":[2960984,2961020],"length":1,"stats":{"Line":6}},{"line":147,"address":[2961036],"length":1,"stats":{"Line":3}},{"line":149,"address":[2558633,2558564],"length":1,"stats":{"Line":6}},{"line":150,"address":[2961184],"length":1,"stats":{"Line":3}},{"line":152,"address":[2961318],"length":1,"stats":{"Line":3}},{"line":153,"address":[4063048],"length":1,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[4063239],"length":1,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[2961457],"length":1,"stats":{"Line":2}},{"line":158,"address":[2961480],"length":1,"stats":{"Line":2}},{"line":159,"address":[4063216],"length":1,"stats":{"Line":2}},{"line":162,"address":[2961442],"length":1,"stats":{"Line":3}},{"line":165,"address":[2559053],"length":1,"stats":{"Line":3}},{"line":166,"address":[2961619],"length":1,"stats":{"Line":3}},{"line":168,"address":[4063361],"length":1,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[4063446,4063469],"length":1,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[4063498],"length":1,"stats":{"Line":3}},{"line":176,"address":[4063591],"length":1,"stats":{"Line":3}},{"line":178,"address":[4063606],"length":1,"stats":{"Line":3}},{"line":179,"address":[2963368,2962159,2961988,2962084],"length":1,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[4063986,4064033,4064989],"length":1,"stats":{"Line":0}},{"line":188,"address":[2963388,2962015],"length":1,"stats":{"Line":6}},{"line":190,"address":[2560918,2564972,2560804,2562315,2560953,2561961],"length":1,"stats":{"Line":9}},{"line":192,"address":[2560926],"length":1,"stats":{"Line":3}},{"line":193,"address":[4065206,4069080,4065159,4065744,4065263],"length":1,"stats":{"Line":9}},{"line":194,"address":[2561050],"length":1,"stats":{"Line":3}},{"line":195,"address":[2561309,2564962,2561147,2561194,2561076,2561421],"length":1,"stats":{"Line":9}},{"line":196,"address":[4065319,4065407],"length":1,"stats":{"Line":6}},{"line":197,"address":[4065446,4065516],"length":1,"stats":{"Line":6}},{"line":202,"address":[2964462],"length":1,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":3}},{"line":205,"address":[],"length":0,"stats":{"Line":6}},{"line":206,"address":[4066226],"length":1,"stats":{"Line":3}},{"line":208,"address":[4069280,4069309,4066302],"length":1,"stats":{"Line":9}},{"line":209,"address":[2562196],"length":1,"stats":{"Line":3}},{"line":214,"address":[2965086],"length":1,"stats":{"Line":3}},{"line":216,"address":[4066729,4066895,4069034,4066834],"length":1,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[2562612],"length":1,"stats":{"Line":2}},{"line":220,"address":[2965147],"length":1,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[4067218,4067008,4067157],"length":1,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[2965419],"length":1,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[4068238],"length":1,"stats":{"Line":2}},{"line":233,"address":[2563190],"length":1,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":6}},{"line":235,"address":[2965901],"length":1,"stats":{"Line":2}},{"line":236,"address":[2967428,2965927,2965984,2966039,2966150,2966259],"length":1,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":4}},{"line":238,"address":[4067722,4067793],"length":1,"stats":{"Line":4}},{"line":244,"address":[4068416,4068530],"length":1,"stats":{"Line":3}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[4066701],"length":1,"stats":{"Line":3}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[4068627],"length":1,"stats":{"Line":3}},{"line":254,"address":[4068739],"length":1,"stats":{"Line":3}},{"line":258,"address":[2220944,2231392,2228173],"length":1,"stats":{"Line":2}},{"line":270,"address":[2221172],"length":1,"stats":{"Line":2}},{"line":271,"address":[2221358],"length":1,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[2351440],"length":1,"stats":{"Line":2}},{"line":279,"address":[2351466],"length":1,"stats":{"Line":2}},{"line":280,"address":[2351474],"length":1,"stats":{"Line":2}},{"line":281,"address":[2351497],"length":1,"stats":{"Line":2}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[2351525],"length":1,"stats":{"Line":2}},{"line":286,"address":[],"length":0,"stats":{"Line":2}},{"line":287,"address":[2221604],"length":1,"stats":{"Line":2}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[2221651],"length":1,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":2}},{"line":298,"address":[],"length":0,"stats":{"Line":4}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[2231249,2231288,2221929],"length":1,"stats":{"Line":6}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[2361872,2361336,2361897],"length":1,"stats":{"Line":6}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[2221998],"length":1,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[2352305,2352193],"length":1,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[2360920,2363061,2361945,2363056,2361920],"length":1,"stats":{"Line":10}},{"line":321,"address":[2360980],"length":1,"stats":{"Line":2}},{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":326,"address":[2361200],"length":1,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[2360843,2360611,2360536],"length":1,"stats":{"Line":2}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":2}},{"line":335,"address":[2360458],"length":1,"stats":{"Line":2}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[2230612],"length":1,"stats":{"Line":2}},{"line":344,"address":[2230701],"length":1,"stats":{"Line":2}},{"line":348,"address":[2222752],"length":1,"stats":{"Line":2}},{"line":349,"address":[2352862],"length":1,"stats":{"Line":2}},{"line":350,"address":[2222939,2230277],"length":1,"stats":{"Line":4}},{"line":352,"address":[2222973],"length":1,"stats":{"Line":2}},{"line":353,"address":[2230241,2223118],"length":1,"stats":{"Line":4}},{"line":355,"address":[2223146],"length":1,"stats":{"Line":2}},{"line":356,"address":[2353316,2353258],"length":1,"stats":{"Line":4}},{"line":359,"address":[2223229],"length":1,"stats":{"Line":2}},{"line":361,"address":[2353333],"length":1,"stats":{"Line":2}},{"line":362,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":6}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":371,"address":[],"length":0,"stats":{"Line":4}},{"line":373,"address":[2223672],"length":1,"stats":{"Line":2}},{"line":374,"address":[2232374,2231520,2232368,2223805,2231456],"length":1,"stats":{"Line":6}},{"line":375,"address":[2362382,2362298],"length":1,"stats":{"Line":2}},{"line":376,"address":[2231536],"length":1,"stats":{"Line":2}},{"line":377,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":381,"address":[2231769],"length":1,"stats":{"Line":2}},{"line":382,"address":[2362446,2362730,2362998,2362509,2362621],"length":1,"stats":{"Line":4}},{"line":383,"address":[2231816,2231890],"length":1,"stats":{"Line":4}},{"line":384,"address":[2362594,2362650],"length":1,"stats":{"Line":4}},{"line":389,"address":[],"length":0,"stats":{"Line":4}},{"line":391,"address":[2354272],"length":1,"stats":{"Line":2}},{"line":393,"address":[2354378],"length":1,"stats":{"Line":2}},{"line":394,"address":[2354495],"length":1,"stats":{"Line":2}},{"line":395,"address":[2354624,2361472,2361499],"length":1,"stats":{"Line":6}},{"line":396,"address":[],"length":0,"stats":{"Line":2}},{"line":397,"address":[2232524,2232560,2232703],"length":1,"stats":{"Line":4}},{"line":398,"address":[],"length":0,"stats":{"Line":4}},{"line":402,"address":[2354662],"length":1,"stats":{"Line":2}},{"line":403,"address":[2224738,2224645],"length":1,"stats":{"Line":4}},{"line":404,"address":[2359160,2355165],"length":1,"stats":{"Line":4}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":4}},{"line":410,"address":[2359701],"length":1,"stats":{"Line":2}},{"line":413,"address":[2355195],"length":1,"stats":{"Line":2}},{"line":415,"address":[2356046,2355349],"length":1,"stats":{"Line":4}},{"line":416,"address":[],"length":0,"stats":{"Line":4}},{"line":418,"address":[2225425,2225509],"length":1,"stats":{"Line":4}},{"line":419,"address":[2225787,2225995],"length":1,"stats":{"Line":4}},{"line":420,"address":[2356070],"length":1,"stats":{"Line":2}},{"line":421,"address":[2226020],"length":1,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[2226120,2226168],"length":1,"stats":{"Line":4}},{"line":427,"address":[2358263,2356240,2356345,2356420],"length":1,"stats":{"Line":4}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[2356267],"length":1,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":4}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[2226658],"length":1,"stats":{"Line":2}},{"line":442,"address":[2226715,2226823],"length":1,"stats":{"Line":2}},{"line":444,"address":[2357091,2356861,2357016,2358253],"length":1,"stats":{"Line":4}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":2}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[2357148],"length":1,"stats":{"Line":2}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[2357278],"length":1,"stats":{"Line":2}},{"line":457,"address":[2357298],"length":1,"stats":{"Line":2}},{"line":458,"address":[2357374,2357514,2358248,2357612],"length":1,"stats":{"Line":4}},{"line":459,"address":[],"length":0,"stats":{"Line":2}},{"line":462,"address":[2358161],"length":1,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[2358243,2357663],"length":1,"stats":{"Line":2}},{"line":468,"address":[2225828],"length":1,"stats":{"Line":2}},{"line":471,"address":[],"length":0,"stats":{"Line":2}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":4}},{"line":480,"address":[],"length":0,"stats":{"Line":2}},{"line":481,"address":[2358793],"length":1,"stats":{"Line":2}},{"line":482,"address":[2358832],"length":1,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":2}},{"line":503,"address":[4203756,4201808,4204105],"length":1,"stats":{"Line":5}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[2973715],"length":1,"stats":{"Line":5}},{"line":519,"address":[],"length":0,"stats":{"Line":10}},{"line":520,"address":[],"length":0,"stats":{"Line":10}},{"line":521,"address":[2928967],"length":1,"stats":{"Line":5}},{"line":522,"address":[2929165,2929098],"length":1,"stats":{"Line":10}},{"line":524,"address":[2929158],"length":1,"stats":{"Line":15}},{"line":529,"address":[2973963],"length":1,"stats":{"Line":5}},{"line":532,"address":[2391840],"length":1,"stats":{"Line":10}},{"line":535,"address":[],"length":0,"stats":{"Line":5}},{"line":536,"address":[4088039],"length":1,"stats":{"Line":5}},{"line":540,"address":[2299470],"length":1,"stats":{"Line":5}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[2239520,2238056,2239534],"length":1,"stats":{"Line":15}},{"line":545,"address":[2238079,2239181],"length":1,"stats":{"Line":5}},{"line":547,"address":[4202872],"length":1,"stats":{"Line":5}},{"line":548,"address":[2299830],"length":1,"stats":{"Line":0}},{"line":552,"address":[2238300],"length":1,"stats":{"Line":5}},{"line":556,"address":[2928078],"length":1,"stats":{"Line":5}},{"line":557,"address":[],"length":0,"stats":{"Line":5}},{"line":558,"address":[2300190],"length":1,"stats":{"Line":5}},{"line":560,"address":[2928451,2928388],"length":1,"stats":{"Line":5}},{"line":561,"address":[2238880,2238767,2238822],"length":1,"stats":{"Line":10}},{"line":562,"address":[2928572,2928523],"length":1,"stats":{"Line":10}},{"line":564,"address":[],"length":0,"stats":{"Line":5}},{"line":565,"address":[4203589],"length":1,"stats":{"Line":5}},{"line":569,"address":[2239005],"length":1,"stats":{"Line":5}},{"line":572,"address":[2237040],"length":1,"stats":{"Line":5}},{"line":576,"address":[2237189,2237082],"length":1,"stats":{"Line":5}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":5}}],"covered":212,"coverable":277},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","lib.rs"],"content":"//! Recursive proof verification for Plonky3 STARKs.\n\n#![no_std]\n\nextern crate alloc;\n\npub mod challenger;\npub mod generation;\npub mod pcs;\npub mod prelude;\npub mod public_inputs;\npub mod traits;\npub mod types;\npub mod verifier;\n\npub use challenger::CircuitChallenger;\npub use generation::{\n    GenerationError, PcsGeneration, generate_batch_challenges, generate_challenges,\n};\npub use pcs::fri::{FriVerifierParams, MAX_QUERY_INDEX_BITS};\npub use public_inputs::{\n    BatchStarkVerifierInputsBuilder, CommitmentOpening, FriVerifierInputs, PublicInputBuilder,\n    StarkVerifierInputs, StarkVerifierInputsBuilder, construct_batch_stark_verifier_inputs,\n};\npub use traits::{\n    Recursive, RecursiveAir, RecursiveChallenger, RecursiveExtensionMmcs, RecursiveMmcs,\n    RecursivePcs,\n};\npub use types::{\n    CommitmentTargets, OpenedValuesTargets, PreprocessedVerifierDataTargets, ProofTargets,\n    RecursiveLagrangeSelectors, StarkChallenges, Target,\n};\npub use verifier::{\n    BatchProofTargets, ObservableCommitment, VerificationError, verify_batch_circuit,\n    verify_circuit,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","fri","mod.rs"],"content":"//! FRI for recursive verification.\n\nmod params;\nmod targets;\nmod verifier;\n\npub use params::{FriVerifierParams, MAX_QUERY_INDEX_BITS};\npub use targets::{\n    BatchOpeningTargets, CommitPhaseProofStepTargets, FriProofTargets, HashProofTargets,\n    HashTargets, InputProofTargets, QueryProofTargets, RecExtensionValMmcs, RecValMmcs,\n    TwoAdicFriProofTargets, Witness,\n};\npub use verifier::verify_fri_circuit;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","fri","params.rs"],"content":"use p3_fri::FriParameters;\n\n/// FRI verifier parameters (subset needed for verification).\n///\n/// These parameters are extracted from the full `FriParameters` and contain\n/// only the information needed during verification (not proving).\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct FriVerifierParams {\n    /// Log₂ of the blowup factor (rate = 1/blowup)\n    pub log_blowup: usize,\n    /// Log₂ of the final polynomial length (after all folding rounds)\n    pub log_final_poly_len: usize,\n    /// Number of proof-of-work bits required\n    pub pow_bits: usize,\n}\n\nimpl\u003cM\u003e From\u003c\u0026FriParameters\u003cM\u003e\u003e for FriVerifierParams {\n    fn from(params: \u0026FriParameters\u003cM\u003e) -\u003e Self {\n        Self {\n            log_blowup: params.log_blowup,\n            log_final_poly_len: params.log_final_poly_len,\n            pow_bits: params.proof_of_work_bits,\n        }\n    }\n}\n\n/// Maximum number of bits used for query index decomposition in FRI verification circuits.\n///\n/// This is a fixed size to avoid const generic complexity. The circuit decomposes each\n/// query index into this many bits, but only uses the first `log_max_height` bits that\n/// are actually needed.\n///\n/// This value is set to 31 bits because:\n/// - Query indices are sampled as field elements in the base field (BabyBear/KoalaBear)\n/// - BabyBear: p = 2^31 - 2^27 + 1 (31-bit prime)\n/// - KoalaBear: p = 2^31 - 2^24 + 1 (31-bit prime)\n/// - Field elements fit in 31 bits, so 31 bits is sufficient\n///\n/// For Goldilocks (64-bit field), this would need to be increased, but that's not\n/// currently supported in the recursion circuit.\npub const MAX_QUERY_INDEX_BITS: usize = 31;\n","traces":[{"line":18,"address":[3810880],"length":1,"stats":{"Line":5}},{"line":20,"address":[3810891],"length":1,"stats":{"Line":5}},{"line":21,"address":[],"length":0,"stats":{"Line":5}},{"line":22,"address":[],"length":0,"stats":{"Line":5}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","fri","targets.rs"],"content":"use alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::marker::PhantomData;\n\nuse p3_challenger::{CanObserve, GrindingChallenger};\nuse p3_circuit::utils::RowSelectorsTargets;\nuse p3_circuit::{CircuitBuilder, CircuitError};\nuse p3_commit::{BatchOpening, ExtensionMmcs, Mmcs, PolynomialSpace};\nuse p3_field::coset::TwoAdicMultiplicativeCoset;\nuse p3_field::{\n    ExtensionField, Field, PackedValue, PrimeCharacteristicRing, PrimeField64, TwoAdicField,\n};\nuse p3_fri::{CommitPhaseProofStep, FriProof, QueryProof, TwoAdicFriPcs};\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_symmetric::{CryptographicHasher, Hash, PseudoCompressionFunction};\nuse p3_uni_stark::{StarkGenericConfig, Val};\nuse serde::{Deserialize, Serialize};\n\nuse super::{FriVerifierParams, MAX_QUERY_INDEX_BITS, verify_fri_circuit};\nuse crate::Target;\nuse crate::challenger::CircuitChallenger;\nuse crate::traits::{\n    ComsWithOpeningsTargets, Recursive, RecursiveChallenger, RecursiveExtensionMmcs, RecursiveMmcs,\n    RecursivePcs,\n};\nuse crate::types::{OpenedValuesTargets, ProofTargets, RecursiveLagrangeSelectors};\nuse crate::verifier::{ObservableCommitment, VerificationError};\n\n/// `Recursive` version of `FriProof`.\npub struct FriProofTargets\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n    InputProof: Recursive\u003cEF\u003e,\n    Witness: Recursive\u003cEF\u003e,\n\u003e {\n    pub commit_phase_commits: Vec\u003cRecMmcs::Commitment\u003e,\n    pub query_proofs: Vec\u003cQueryProofTargets\u003cF, EF, InputProof, RecMmcs\u003e\u003e,\n    pub final_poly: Vec\u003cTarget\u003e,\n    pub pow_witness: Witness,\n}\n\nimpl\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n    InputProof: Recursive\u003cEF\u003e,\n    Witness: Recursive\u003cEF\u003e,\n\u003e Recursive\u003cEF\u003e for FriProofTargets\u003cF, EF, RecMmcs, InputProof, Witness\u003e\n{\n    type Input = FriProof\u003cEF, RecMmcs::Input, Witness::Input, InputProof::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let commit_phase_commits = input\n            .commit_phase_commits\n            .iter()\n            .map(|commitment| RecMmcs::Commitment::new(circuit, commitment))\n            .collect();\n\n        let query_proofs = input\n            .query_proofs\n            .iter()\n            .map(|query| QueryProofTargets::new(circuit, query))\n            .collect();\n\n        let final_poly = circuit\n            .alloc_public_inputs(input.final_poly.len(), \"FRI final polynomial coefficients\");\n\n        Self {\n            commit_phase_commits,\n            query_proofs,\n            final_poly,\n            pow_witness: Witness::new(circuit, \u0026input.pow_witness),\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        let FriProof {\n            commit_phase_commits,\n            query_proofs,\n            final_poly,\n            pow_witness,\n        } = input;\n\n        commit_phase_commits\n            .iter()\n            .flat_map(|c| RecMmcs::Commitment::get_values(c))\n            .chain(\n                query_proofs\n                    .iter()\n                    .flat_map(|c| QueryProofTargets::\u003cF, EF, InputProof, RecMmcs\u003e::get_values(c)),\n            )\n            .chain(final_poly.iter().copied())\n            .chain(Witness::get_values(pow_witness))\n            .collect()\n    }\n}\n\n/// `Recursive` version of `QueryProof`.\npub struct QueryProofTargets\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    InputProof: Recursive\u003cEF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n\u003e {\n    pub input_proof: InputProof,\n    pub commit_phase_openings: Vec\u003cCommitPhaseProofStepTargets\u003cF, EF, RecMmcs\u003e\u003e,\n}\n\nimpl\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    InputProof: Recursive\u003cEF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n\u003e Recursive\u003cEF\u003e for QueryProofTargets\u003cF, EF, InputProof, RecMmcs\u003e\n{\n    type Input = QueryProof\u003cEF, RecMmcs::Input, InputProof::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        // Note that the iterator `lens` is updated by each call to `new`. So we can always pass the same `lens` for all structures.\n        let input_proof = InputProof::new(circuit, \u0026input.input_proof);\n        let commit_phase_openings = input\n            .commit_phase_openings\n            .iter()\n            .map(|commitment| CommitPhaseProofStepTargets::new(circuit, commitment))\n            .collect();\n        Self {\n            input_proof,\n            commit_phase_openings,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        InputProof::get_values(\u0026input.input_proof)\n            .into_iter()\n            .chain(\n                input\n                    .commit_phase_openings\n                    .iter()\n                    .flat_map(|o| CommitPhaseProofStepTargets::\u003c_, _, RecMmcs\u003e::get_values(o)),\n            )\n            .collect()\n    }\n}\n\n/// `Recursive` version of `CommitPhaseProofStepTargets`.\npub struct CommitPhaseProofStepTargets\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n\u003e {\n    pub sibling_value: Target,\n    pub opening_proof: RecMmcs::Proof,\n    // This is necessary because the `Input` type can include the extension field element.\n    _phantom: PhantomData\u003cEF\u003e,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e\u003e Recursive\u003cEF\u003e\n    for CommitPhaseProofStepTargets\u003cF, EF, RecMmcs\u003e\n{\n    // This is used with an extension field element, since it is part of `FriProof`, not a base field element.\n    type Input = CommitPhaseProofStep\u003cEF, RecMmcs::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let sibling_value = circuit.alloc_public_input(\"FRI commit phase sibling value\");\n        let opening_proof = RecMmcs::Proof::new(circuit, \u0026input.opening_proof);\n        Self {\n            sibling_value,\n            opening_proof,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        let CommitPhaseProofStep {\n            sibling_value,\n            opening_proof,\n        } = input;\n\n        let mut values = vec![*sibling_value];\n        values.extend(RecMmcs::Proof::get_values(opening_proof));\n        values\n    }\n}\n\n/// `Recursive` version of `BatchOpening`.\npub struct BatchOpeningTargets\u003cF: Field, EF: ExtensionField\u003cF\u003e, RecMmcs: RecursiveMmcs\u003cF, EF\u003e\u003e {\n    /// The opened row values from each matrix in the batch.\n    /// Each inner vector corresponds to one matrix.\n    pub opened_values: Vec\u003cVec\u003cTarget\u003e\u003e,\n    /// The proof showing the values are valid openings.\n    pub opening_proof: RecMmcs::Proof,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, Inner: RecursiveMmcs\u003cF, EF\u003e\u003e Recursive\u003cEF\u003e\n    for BatchOpeningTargets\u003cF, EF, Inner\u003e\n{\n    type Input = BatchOpening\u003cF, Inner::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let opened_values = input\n            .opened_values\n            .iter()\n            .map(|values| circuit.alloc_public_inputs(values.len(), \"batch opened values\"))\n            .collect();\n\n        let opening_proof = Inner::Proof::new(circuit, \u0026input.opening_proof);\n\n        Self {\n            opened_values,\n            opening_proof,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        let BatchOpening {\n            opened_values,\n            opening_proof,\n        } = input;\n\n        opened_values\n            .iter()\n            .flat_map(|inner| inner.iter().map(|v| EF::from(*v)))\n            .chain(Inner::Proof::get_values(opening_proof))\n            .collect()\n    }\n}\n\n// Now, we define the commitment schemes.\n\n/// `HashTargets` corresponds to a commitment in the form of hashes with `DIGEST_ELEMS` digest elements.\n#[derive(Clone)]\npub struct HashTargets\u003cF, const DIGEST_ELEMS: usize\u003e {\n    pub hash_targets: [Target; DIGEST_ELEMS],\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF, const DIGEST_ELEMS: usize\u003e ObservableCommitment for HashTargets\u003cF, DIGEST_ELEMS\u003e {\n    fn to_observation_targets(\u0026self) -\u003e Vec\u003cTarget\u003e {\n        self.hash_targets.to_vec()\n    }\n}\n\ntype ValMmcsCommitment\u003cF, const DIGEST_ELEMS: usize\u003e =\n    Hash\u003c\u003cF as PackedValue\u003e::Value, \u003cF as PackedValue\u003e::Value, DIGEST_ELEMS\u003e;\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, const DIGEST_ELEMS: usize\u003e Recursive\u003cEF\u003e\n    for HashTargets\u003cF, DIGEST_ELEMS\u003e\n{\n    type Input = ValMmcsCommitment\u003cF, DIGEST_ELEMS\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, _input: \u0026Self::Input) -\u003e Self {\n        Self {\n            hash_targets: circuit.alloc_public_input_array(\"MMCS commitment digest\"),\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        input.into_iter().map(|v| EF::from(v)).collect()\n    }\n}\n\n/// `HashProofTargets` corresponds to a Merkle tree `Proof` in the form of a vector of hashes with `DIGEST_ELEMS` digest elements.\npub struct HashProofTargets\u003cF, const DIGEST_ELEMS: usize\u003e {\n    pub hash_proof_targets: Vec\u003c[Target; DIGEST_ELEMS]\u003e,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\ntype ValMmcsProof\u003cPW, const DIGEST_ELEMS: usize\u003e = Vec\u003c[\u003cPW as PackedValue\u003e::Value; DIGEST_ELEMS]\u003e;\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, const DIGEST_ELEMS: usize\u003e Recursive\u003cEF\u003e\n    for HashProofTargets\u003cF, DIGEST_ELEMS\u003e\n{\n    type Input = ValMmcsProof\u003cF, DIGEST_ELEMS\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let proof_len = input.len();\n        let mut proof = Vec::with_capacity(proof_len);\n        for _ in 0..proof_len {\n            proof.push(circuit.alloc_public_input_array(\"Merkle proof hash\"));\n        }\n\n        Self {\n            hash_proof_targets: proof,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        input\n            .iter()\n            .flat_map(|h| h.iter().map(|v| EF::from(*v)))\n            .collect()\n    }\n}\n\n/// In TwoAdicFriPcs, the POW witness is just a base field element.\npub struct Witness\u003cF\u003e {\n    pub witness: Target,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e Recursive\u003cEF\u003e for Witness\u003cF\u003e {\n    type Input = F;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, _input: \u0026Self::Input) -\u003e Self {\n        Self {\n            witness: circuit.alloc_public_input(\"FRI proof-of-work witness\"),\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        vec![EF::from(*input)]\n    }\n}\n\n/// `Recursive` version of a `MerkleTreeMmcs` where the leaf and digest elements are base field values.\npub struct RecValMmcs\u003cF: Field, const DIGEST_ELEMS: usize, H, C\u003e\nwhere\n    H: CryptographicHasher\u003cF, [F; DIGEST_ELEMS]\u003e\n        + CryptographicHasher\u003cF::Packing, [F::Packing; DIGEST_ELEMS]\u003e\n        + Sync,\n{\n    pub hash: H,\n    pub compress: C,\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, const DIGEST_ELEMS: usize, H, C\u003e RecursiveMmcs\u003cF, EF\u003e\n    for RecValMmcs\u003cF, DIGEST_ELEMS, H, C\u003e\nwhere\n    H: CryptographicHasher\u003cF, [F; DIGEST_ELEMS]\u003e\n        + CryptographicHasher\u003cF::Packing, [F::Packing; DIGEST_ELEMS]\u003e\n        + Sync,\n    C: PseudoCompressionFunction\u003c[F; DIGEST_ELEMS], 2\u003e\n        + PseudoCompressionFunction\u003c[F::Packing; DIGEST_ELEMS], 2\u003e\n        + Sync,\n    [F; DIGEST_ELEMS]: Serialize + for\u003c'a\u003e Deserialize\u003c'a\u003e,\n{\n    type Input = MerkleTreeMmcs\u003cF::Packing, F::Packing, H, C, DIGEST_ELEMS\u003e;\n\n    type Commitment = HashTargets\u003cF, DIGEST_ELEMS\u003e;\n\n    type Proof = HashProofTargets\u003cF, DIGEST_ELEMS\u003e;\n}\n\n/// `Recursive` version of an `ExtensionFieldMmcs` where the inner `Mmcs` is a `MerkleTreeMmcs`.\npub struct RecExtensionValMmcs\u003c\n    F: Field,\n    EF: ExtensionField\u003cF\u003e,\n    const DIGEST_ELEMS: usize,\n    ValMmcs: RecursiveMmcs\u003cF, EF\u003e,\n\u003e {\n    _phantom: PhantomData\u003cF\u003e,\n    _phantom_ef: PhantomData\u003cEF\u003e,\n    _phantom_val: PhantomData\u003cValMmcs\u003e,\n}\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, const DIGEST_ELEMS: usize, RecValMmcs: RecursiveMmcs\u003cF, EF\u003e\u003e\n    RecursiveExtensionMmcs\u003cF, EF\u003e for RecExtensionValMmcs\u003cF, EF, DIGEST_ELEMS, RecValMmcs\u003e\n{\n    type Input = ExtensionMmcs\u003cF, EF, RecValMmcs::Input\u003e;\n\n    type Commitment = RecValMmcs::Commitment;\n\n    type Proof = RecValMmcs::Proof;\n}\n\npub type InputProofTargets\u003cF, EF, Inner\u003e = Vec\u003cBatchOpeningTargets\u003cF, EF, Inner\u003e\u003e;\n\npub type TwoAdicFriProofTargets\u003cF, EF, RecMmcs, Inner\u003e =\n    FriProofTargets\u003cF, EF, RecMmcs, InputProofTargets\u003cF, EF, Inner\u003e, Target\u003e;\n\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e, Inner: RecursiveMmcs\u003cF, EF\u003e\u003e Recursive\u003cEF\u003e\n    for InputProofTargets\u003cF, EF, Inner\u003e\n{\n    type Input = Vec\u003cBatchOpening\u003cF, Inner::Input\u003e\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cEF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let num_batch_openings = input.len();\n        let mut batch_openings = Self::with_capacity(num_batch_openings);\n        for batch_opening in input.iter() {\n            batch_openings.push(BatchOpeningTargets::new(circuit, batch_opening));\n        }\n\n        batch_openings\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cEF\u003e {\n        input\n            .iter()\n            .flat_map(|batch_opening| {\n                BatchOpeningTargets::\u003cF, EF, Inner\u003e::get_values(batch_opening)\n            })\n            .collect()\n    }\n}\n\n// Recursive type for the `FriProof` of `TwoAdicFriPcs`.\ntype RecursiveFriProof\u003cSC, RecursiveFriMmcs, RecursiveInputProof\u003e = FriProofTargets\u003c\n    Val\u003cSC\u003e,\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    RecursiveFriMmcs,\n    RecursiveInputProof,\n    Witness\u003cVal\u003cSC\u003e\u003e,\n\u003e;\n\n// Implement `RecursivePcs` for `TwoAdicFriPcs`.\nimpl\u003cSC, Dft, Comm, InputMmcs, RecursiveInputMmcs, RecursiveFriMmcs, FriMmcs\u003e\n    RecursivePcs\u003c\n        SC,\n        InputProofTargets\u003cVal\u003cSC\u003e, SC::Challenge, RecursiveInputMmcs\u003e,\n        RecursiveFriProof\u003c\n            SC,\n            RecursiveFriMmcs,\n            InputProofTargets\u003cVal\u003cSC\u003e, SC::Challenge, RecursiveInputMmcs\u003e,\n        \u003e,\n        Comm,\n        TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n    \u003e for TwoAdicFriPcs\u003cVal\u003cSC\u003e, Dft, InputMmcs, FriMmcs\u003e\nwhere\n    SC: StarkGenericConfig,\n    Val\u003cSC\u003e: TwoAdicField + PrimeField64,\n    InputMmcs: Mmcs\u003cVal\u003cSC\u003e\u003e,\n    FriMmcs: Mmcs\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    RecursiveInputMmcs: RecursiveMmcs\u003cVal\u003cSC\u003e, SC::Challenge, Input = InputMmcs\u003e,\n    RecursiveFriMmcs: RecursiveExtensionMmcs\u003cVal\u003cSC\u003e, SC::Challenge, Input = FriMmcs\u003e,\n    RecursiveFriMmcs::Commitment: ObservableCommitment,\n    SC::Challenger: GrindingChallenger + CanObserve\u003cFriMmcs::Commitment\u003e,\n{\n    type VerifierParams = FriVerifierParams;\n    type RecursiveProof = RecursiveFriProof\u003c\n        SC,\n        RecursiveFriMmcs,\n        InputProofTargets\u003cVal\u003cSC\u003e, SC::Challenge, RecursiveInputMmcs\u003e,\n    \u003e;\n\n    /// Observes all opened values and derives PCS-specific challenges.\n    fn get_challenges_circuit\u003cconst RATE: usize\u003e(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenger: \u0026mut CircuitChallenger\u003cRATE\u003e,\n        proof_targets: \u0026ProofTargets\u003cSC, Comm, Self::RecursiveProof\u003e,\n        opened_values: \u0026OpenedValuesTargets\u003cSC\u003e,\n        params: \u0026Self::VerifierParams,\n    ) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitError\u003e {\n        let fri_proof = \u0026proof_targets.opening_proof;\n\n        opened_values.observe(circuit, challenger);\n\n        // Sample FRI alpha (for batch opening reduction)\n        let fri_alpha = challenger.sample(circuit);\n\n        // Sample FRI betas: one per commit phase\n        // For each FRI commitment, observe it and sample beta\n        let mut betas = Vec::with_capacity(fri_proof.commit_phase_commits.len());\n        for commit in \u0026fri_proof.commit_phase_commits {\n            let commit_targets = commit.to_observation_targets();\n            challenger.observe_slice(circuit, \u0026commit_targets);\n            let beta = challenger.sample(circuit);\n            betas.push(beta);\n        }\n\n        // Observe final polynomial coefficients\n        challenger.observe_slice(circuit, \u0026fri_proof.final_poly);\n\n        // Check PoW witness.\n        challenger.check_witness(\n            circuit,\n            params.pow_bits,\n            fri_proof.pow_witness.witness,\n            Val::\u003cSC\u003e::bits(),\n        )?;\n\n        // Sample query indices\n        let num_queries = fri_proof.query_proofs.len();\n        let mut query_indices = Vec::with_capacity(num_queries);\n        for _ in 0..num_queries {\n            let index = challenger.sample(circuit);\n            query_indices.push(index);\n        }\n\n        // Return challenges in order: [fri_alpha, betas..., query_indices...]\n        let mut challenges = Vec::with_capacity(1 + betas.len() + num_queries);\n        challenges.push(fri_alpha);\n        challenges.extend(betas);\n        challenges.extend(query_indices);\n        Ok(challenges)\n    }\n\n    fn verify_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenges: \u0026[Target],\n        commitments_with_opening_points: \u0026ComsWithOpeningsTargets\u003c\n            Comm,\n            TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n        \u003e,\n        opening_proof: \u0026Self::RecursiveProof,\n        params: \u0026Self::VerifierParams,\n    ) -\u003e Result\u003c(), VerificationError\u003e {\n        let FriVerifierParams {\n            log_blowup,\n            log_final_poly_len,\n            pow_bits: _,\n        } = *params;\n        // Extract FRI challenges from the challenges slice.\n        // Layout: [alpha, beta_0, ..., beta_{n-1}, query_0, ..., query_{m-1}]\n        // where:\n        //   - alpha: FRI batch combination challenge\n        //   - betas: one challenge per FRI folding round\n        //   - query indices: sampled indices for FRI queries (as field elements)\n        let num_betas = opening_proof.commit_phase_commits.len();\n        let num_queries = opening_proof.query_proofs.len();\n\n        let alpha = challenges[0];\n        let betas = \u0026challenges[1..1 + num_betas];\n\n        let query_indices = \u0026challenges[1 + num_betas..1 + num_betas + num_queries];\n\n        // Calculate the maximum height of the FRI proof tree.\n        let log_max_height = num_betas + log_final_poly_len + log_blowup;\n\n        if log_max_height \u003e MAX_QUERY_INDEX_BITS {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"log_max_height {log_max_height} exceeds MAX_QUERY_INDEX_BITS {MAX_QUERY_INDEX_BITS}\"\n            )));\n        }\n\n        let index_bits_per_query: Vec\u003cVec\u003cTarget\u003e\u003e = query_indices\n            .iter()\n            .map(|\u0026index_target| {\n                let all_bits =\n                    circuit.decompose_to_bits::\u003cVal\u003cSC\u003e\u003e(index_target, MAX_QUERY_INDEX_BITS);\n                all_bits.map(|all_bits| {\n                    all_bits\n                        .into_iter()\n                        .take(log_max_height)\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                })\n            })\n            .collect::\u003cResult\u003c_, _\u003e\u003e()?;\n\n        verify_fri_circuit(\n            circuit,\n            opening_proof,\n            alpha,\n            betas,\n            \u0026index_bits_per_query,\n            commitments_with_opening_points,\n            log_blowup,\n        )\n    }\n\n    fn selectors_at_point_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        domain: \u0026TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n        point: \u0026Target,\n    ) -\u003e RecursiveLagrangeSelectors {\n        // Constants that we will need.\n        let shift_inv =\n            circuit.alloc_const(SC::Challenge::from(domain.shift_inverse()), \"shift_inv\");\n        let one = circuit.alloc_const(SC::Challenge::from(Val::\u003cSC\u003e::ONE), \"1\");\n        let subgroup_gen_inv = circuit.alloc_const(\n            SC::Challenge::from(domain.subgroup_generator().inverse()),\n            \"subgroup_gen_inv\",\n        );\n\n        // Unshifted and z_h\n        let unshifted_point = circuit.alloc_mul(shift_inv, *point, \"unshifted_point\");\n        let us_exp = circuit.exp_power_of_2(unshifted_point, domain.log_size());\n        let z_h = circuit.alloc_sub(us_exp, one, \"z_h\");\n\n        // Denominators\n        let us_minus_one = circuit.alloc_sub(unshifted_point, one, \"us_minus_one\");\n        let us_minus_gen_inv =\n            circuit.alloc_sub(unshifted_point, subgroup_gen_inv, \"us_minus_gen_inv\");\n\n        // Selectors\n        let is_first_row = circuit.alloc_div(z_h, us_minus_one, \"is_first_row\");\n        let is_last_row = circuit.alloc_div(z_h, us_minus_gen_inv, \"is_last_row\");\n        let is_transition = us_minus_gen_inv;\n        let inv_vanishing = circuit.alloc_div(one, z_h, \"inv_vanishing\");\n\n        let row_selectors = RowSelectorsTargets {\n            is_first_row,\n            is_last_row,\n            is_transition,\n        };\n        RecursiveLagrangeSelectors {\n            row_selectors,\n            inv_vanishing,\n        }\n    }\n\n    fn create_disjoint_domain(\n        \u0026self,\n        trace_domain: TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n        degree: usize,\n    ) -\u003e TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e {\n        trace_domain.create_disjoint_domain(degree)\n    }\n\n    fn split_domains(\n        \u0026self,\n        trace_domain: \u0026TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e,\n        degree: usize,\n    ) -\u003e Vec\u003cTwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e\u003e {\n        trace_domain.split_domains(degree)\n    }\n\n    fn log_size(\u0026self, trace_domain: \u0026TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e) -\u003e usize {\n        trace_domain.log_size()\n    }\n\n    fn first_point(\u0026self, trace_domain: \u0026TwoAdicMultiplicativeCoset\u003cVal\u003cSC\u003e\u003e) -\u003e SC::Challenge {\n        trace_domain.first_point().into()\n    }\n}\n","traces":[{"line":53,"address":[2561136,2561843,2561900],"length":1,"stats":{"Line":6}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[3509365,3508645,3509344],"length":1,"stats":{"Line":18}},{"line":60,"address":[3658214],"length":1,"stats":{"Line":6}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[2991430,2992032,2992053],"length":1,"stats":{"Line":18}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[3508833,3508900],"length":1,"stats":{"Line":14}},{"line":73,"address":[],"length":0,"stats":{"Line":7}},{"line":77,"address":[3657876,3657904,3657232],"length":1,"stats":{"Line":7}},{"line":78,"address":[3657270],"length":1,"stats":{"Line":7}},{"line":79,"address":[3657294],"length":1,"stats":{"Line":7}},{"line":80,"address":[2560358],"length":1,"stats":{"Line":7}},{"line":81,"address":[2928874],"length":1,"stats":{"Line":7}},{"line":82,"address":[2990446],"length":1,"stats":{"Line":7}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[2990801,2990485,2990902,2990621,2990466],"length":1,"stats":{"Line":34}},{"line":87,"address":[3657397,3657952,3657987],"length":1,"stats":{"Line":19}},{"line":89,"address":[3657407],"length":1,"stats":{"Line":7}},{"line":90,"address":[2806211],"length":1,"stats":{"Line":7}},{"line":91,"address":[2560566,2561072,2561107],"length":1,"stats":{"Line":19}},{"line":93,"address":[3508058,3508185,3508041,3508382],"length":1,"stats":{"Line":14}},{"line":94,"address":[2990861,2990934,2990868,2991001],"length":1,"stats":{"Line":12}},{"line":119,"address":[2805584,2805890,2805896],"length":1,"stats":{"Line":6}},{"line":121,"address":[2928448],"length":1,"stats":{"Line":6}},{"line":122,"address":[2805642],"length":1,"stats":{"Line":7}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[2990288,2990115,2990309],"length":1,"stats":{"Line":21}},{"line":133,"address":[2805200,2805501,2805473],"length":1,"stats":{"Line":6}},{"line":134,"address":[2989769,2989598],"length":1,"stats":{"Line":12}},{"line":137,"address":[3656551],"length":1,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[2805359],"length":1,"stats":{"Line":6}},{"line":140,"address":[2989762,2989923,2989888],"length":1,"stats":{"Line":18}},{"line":164,"address":[3498880],"length":1,"stats":{"Line":7}},{"line":165,"address":[],"length":0,"stats":{"Line":7}},{"line":166,"address":[2559402],"length":1,"stats":{"Line":7}},{"line":174,"address":[2989394,2989400,2989104],"length":1,"stats":{"Line":6}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[2804650],"length":1,"stats":{"Line":6}},{"line":177,"address":[2989142],"length":1,"stats":{"Line":6}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[2559051,2559194],"length":1,"stats":{"Line":6}},{"line":181,"address":[2989283,2989344],"length":1,"stats":{"Line":13}},{"line":182,"address":[2804880],"length":1,"stats":{"Line":7}},{"line":200,"address":[2988427,2988144,2988421],"length":1,"stats":{"Line":6}},{"line":201,"address":[3498210],"length":1,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[2927317,2927060,2927280],"length":1,"stats":{"Line":18}},{"line":207,"address":[3655730],"length":1,"stats":{"Line":6}},{"line":215,"address":[3497872],"length":1,"stats":{"Line":6}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":218,"address":[],"length":0,"stats":{"Line":6}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[2804048,2803955,2804112,2804133,2804073],"length":1,"stats":{"Line":30}},{"line":224,"address":[3655442],"length":1,"stats":{"Line":6}},{"line":239,"address":[2987232],"length":1,"stats":{"Line":5}},{"line":240,"address":[3484337],"length":1,"stats":{"Line":5}},{"line":252,"address":[3484224],"length":1,"stats":{"Line":7}},{"line":254,"address":[2555416],"length":1,"stats":{"Line":7}},{"line":259,"address":[2986960],"length":1,"stats":{"Line":6}},{"line":260,"address":[3654592,3654616,3654488],"length":1,"stats":{"Line":18}},{"line":277,"address":[3484576,3484920,3484926],"length":1,"stats":{"Line":6}},{"line":278,"address":[2926275],"length":1,"stats":{"Line":6}},{"line":279,"address":[2987565],"length":1,"stats":{"Line":6}},{"line":280,"address":[3484663,3484735],"length":1,"stats":{"Line":12}},{"line":281,"address":[2555902,2556028],"length":1,"stats":{"Line":12}},{"line":290,"address":[3654784],"length":1,"stats":{"Line":6}},{"line":291,"address":[2803328],"length":1,"stats":{"Line":6}},{"line":293,"address":[2803392,2803422,2803347,2803456,2803477],"length":1,"stats":{"Line":30}},{"line":307,"address":[3483216],"length":1,"stats":{"Line":7}},{"line":309,"address":[2950398],"length":1,"stats":{"Line":7}},{"line":314,"address":[2784480,2784710,2784704],"length":1,"stats":{"Line":6}},{"line":315,"address":[2554082,2554259],"length":1,"stats":{"Line":6}},{"line":381,"address":[1612524,1612144,1612518],"length":1,"stats":{"Line":6}},{"line":382,"address":[1741555],"length":1,"stats":{"Line":6}},{"line":383,"address":[1612216],"length":1,"stats":{"Line":6}},{"line":384,"address":[1992930,1992994],"length":1,"stats":{"Line":12}},{"line":385,"address":[3222154,3222090],"length":1,"stats":{"Line":12}},{"line":388,"address":[3222107],"length":1,"stats":{"Line":7}},{"line":391,"address":[1612048],"length":1,"stats":{"Line":6}},{"line":392,"address":[],"length":0,"stats":{"Line":6}},{"line":394,"address":[2554816],"length":1,"stats":{"Line":12}},{"line":395,"address":[2554851],"length":1,"stats":{"Line":6}},{"line":442,"address":[4200587,4199184,4200847],"length":1,"stats":{"Line":5}},{"line":449,"address":[],"length":0,"stats":{"Line":5}},{"line":451,"address":[2899105],"length":1,"stats":{"Line":5}},{"line":454,"address":[2970502],"length":1,"stats":{"Line":5}},{"line":458,"address":[2970531],"length":1,"stats":{"Line":5}},{"line":459,"address":[2262184,2262104],"length":1,"stats":{"Line":10}},{"line":460,"address":[2262294],"length":1,"stats":{"Line":5}},{"line":461,"address":[2236118,2236205],"length":1,"stats":{"Line":10}},{"line":462,"address":[2900564],"length":1,"stats":{"Line":5}},{"line":463,"address":[2263506],"length":1,"stats":{"Line":5}},{"line":467,"address":[],"length":0,"stats":{"Line":5}},{"line":470,"address":[2899537,2899666],"length":1,"stats":{"Line":5}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[2970846],"length":1,"stats":{"Line":5}},{"line":473,"address":[4199703],"length":1,"stats":{"Line":5}},{"line":474,"address":[2262398],"length":1,"stats":{"Line":5}},{"line":478,"address":[4199923],"length":1,"stats":{"Line":5}},{"line":479,"address":[2899736],"length":1,"stats":{"Line":5}},{"line":480,"address":[2899832,2899756],"length":1,"stats":{"Line":10}},{"line":481,"address":[2899901,2900373],"length":1,"stats":{"Line":10}},{"line":482,"address":[2263300],"length":1,"stats":{"Line":5}},{"line":486,"address":[],"length":0,"stats":{"Line":5}},{"line":487,"address":[],"length":0,"stats":{"Line":5}},{"line":488,"address":[2971483],"length":1,"stats":{"Line":5}},{"line":489,"address":[2263082],"length":1,"stats":{"Line":5}},{"line":490,"address":[],"length":0,"stats":{"Line":5}},{"line":493,"address":[2898935,2897344,2898929],"length":1,"stats":{"Line":5}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[2233258],"length":1,"stats":{"Line":5}},{"line":506,"address":[2968925],"length":1,"stats":{"Line":5}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[2260481],"length":1,"stats":{"Line":5}},{"line":516,"address":[4197822],"length":1,"stats":{"Line":5}},{"line":518,"address":[2969007,2969074],"length":1,"stats":{"Line":5}},{"line":519,"address":[2233398,2233467,2233538],"length":1,"stats":{"Line":10}},{"line":521,"address":[4198233,4198055,4198017],"length":1,"stats":{"Line":11}},{"line":524,"address":[2260903,2261008,2260947],"length":1,"stats":{"Line":10}},{"line":526,"address":[4198303],"length":1,"stats":{"Line":5}},{"line":527,"address":[2969610],"length":1,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[2233905,2234296],"length":1,"stats":{"Line":5}},{"line":534,"address":[2898195],"length":1,"stats":{"Line":15}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[2784866],"length":1,"stats":{"Line":5}},{"line":537,"address":[2950656,2950621],"length":1,"stats":{"Line":10}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[3483461],"length":1,"stats":{"Line":5}},{"line":540,"address":[3652212],"length":1,"stats":{"Line":5}},{"line":541,"address":[3652235],"length":1,"stats":{"Line":5}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[2261569],"length":1,"stats":{"Line":5}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[2263568],"length":1,"stats":{"Line":5}},{"line":564,"address":[2972103],"length":1,"stats":{"Line":5}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[2972158],"length":1,"stats":{"Line":5}},{"line":567,"address":[2236546],"length":1,"stats":{"Line":5}},{"line":568,"address":[],"length":0,"stats":{"Line":5}},{"line":573,"address":[2236592],"length":1,"stats":{"Line":5}},{"line":574,"address":[],"length":0,"stats":{"Line":5}},{"line":575,"address":[2972381],"length":1,"stats":{"Line":5}},{"line":578,"address":[2901047],"length":1,"stats":{"Line":5}},{"line":579,"address":[2901089],"length":1,"stats":{"Line":5}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[2264043],"length":1,"stats":{"Line":5}},{"line":584,"address":[2972549],"length":1,"stats":{"Line":5}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[2236879],"length":1,"stats":{"Line":5}},{"line":599,"address":[2970272],"length":1,"stats":{"Line":3}},{"line":604,"address":[4199166],"length":1,"stats":{"Line":3}},{"line":607,"address":[4197504],"length":1,"stats":{"Line":3}},{"line":612,"address":[4197557],"length":1,"stats":{"Line":3}},{"line":615,"address":[2901328],"length":1,"stats":{"Line":5}},{"line":616,"address":[2237017],"length":1,"stats":{"Line":5}},{"line":619,"address":[],"length":0,"stats":{"Line":5}},{"line":620,"address":[],"length":0,"stats":{"Line":5}}],"covered":140,"coverable":168},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","fri","verifier.rs"],"content":"use alloc::collections::btree_map::BTreeMap;\nuse alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::iter;\n\nuse p3_circuit::CircuitBuilder;\nuse p3_field::coset::TwoAdicMultiplicativeCoset;\nuse p3_field::{ExtensionField, Field, TwoAdicField};\nuse p3_util::zip_eq::zip_eq;\n\nuse super::{FriProofTargets, InputProofTargets};\nuse crate::Target;\nuse crate::traits::{ComsWithOpeningsTargets, Recursive, RecursiveExtensionMmcs, RecursiveMmcs};\nuse crate::verifier::VerificationError;\n\n/// Inputs for one FRI fold phase (matches the values used by the verifier per round).\n#[derive(Clone, Debug)]\npub struct FoldPhaseInputsTarget {\n    /// Per-phase challenge β (sampled after observing that layer's commitment).\n    pub beta: Target,\n    /// Subgroup point x₀ for this phase (the other point is x₁ = −x₀).\n    pub x0: Target,\n    /// Sibling evaluation at the opposite child index.\n    pub e_sibling: Target,\n    /// Boolean {0,1}. Equals 1 iff sibling occupies evals[1] (the \"right\" slot).\n    /// In Plonky3 this is 1 − (domain_index \u0026 1) at this phase.\n    pub sibling_is_right: Target,\n    /// Optional reduced opening to roll in at this height (added as β² · roll_in).\n    pub roll_in: Option\u003cTarget\u003e,\n}\n\n/// Perform the arity-2 FRI fold chain with optional roll-ins.\n/// Starts from the initial reduced opening at max height; returns the final folded value.\n/// All arithmetic is over the circuit field `EF`.\n///\n/// Interpolation per phase:\n///   folded ← e0 + (β − x0)·(e1 − e0)·(x1 − x0)^{-1}, with x1 = −x0\n///           = e0 + (β − x0)·(e1 − e0)·(−1/2)·x0^{-1}\nfn fold_row_chain\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    initial_folded_eval: Target,\n    phases: \u0026[FoldPhaseInputsTarget],\n) -\u003e Target {\n    builder.push_scope(\"fold_row_chain\");\n\n    let mut folded = initial_folded_eval;\n\n    let one = builder.alloc_const(EF::ONE, \"1\");\n\n    // Precompute constants as field constants: 2^{-1} and −1/2.\n    let two_inv_val = EF::ONE.halve(); // 1/2\n    let neg_half = builder.alloc_const(EF::NEG_ONE * two_inv_val, \"−1/2\"); // −1/2\n\n    for FoldPhaseInputsTarget {\n        beta,\n        x0,\n        e_sibling,\n        sibling_is_right,\n        roll_in,\n    } in phases.iter().cloned()\n    {\n        // TODO: Add recursive MMCS batch verification for this commit phase:\n        // Verify the sibling value against the commitment at the parent index.\n\n        // e0 = select(bit, folded, e_sibling)\n        let e0 = builder.select(sibling_is_right, folded, e_sibling);\n\n        // inv = (x1 − x0)^{-1} = (−2x0)^{-1} = (−1/2) / x0\n        let inv = builder.alloc_div(neg_half, x0, \"inv\");\n\n        // e1 − e0 = (2b − 1) · (e_sibling − folded)\n        let d = builder.alloc_sub(e_sibling, folded, \"d\");\n        let two_b = builder.alloc_add(sibling_is_right, sibling_is_right, \"two_b\");\n        let two_b_minus_one = builder.alloc_sub(two_b, one, \"two_b_minus_one\");\n        let e1_minus_e0 = builder.alloc_mul(two_b_minus_one, d, \"e1_minus_e0\");\n\n        // t = (β − x0) * (e1 − e0)\n        let beta_minus_x0 = builder.alloc_sub(beta, x0, \"beta_minus_x0\");\n        let t = builder.alloc_mul(beta_minus_x0, e1_minus_e0, \"t\");\n\n        // folded = e0 + t * inv\n        let t_inv = builder.alloc_mul(t, inv, \"t_inv\");\n        folded = builder.alloc_add(e0, t_inv, \"folded 1\");\n\n        // Optional roll-in: folded += β² · roll_in\n        if let Some(ro) = roll_in {\n            let beta_sq = builder.alloc_mul(beta, beta, \"beta_sq\");\n            let add_term = builder.alloc_mul(beta_sq, ro, \"add_term\");\n            folded = builder.alloc_add(folded, add_term, \"folded 2\");\n        }\n    }\n\n    builder.pop_scope(); // close `fold_row_chain` scope\n    folded\n}\n\n/// Evaluate a polynomial at a point `x` using Horner's method.\n/// Given coefficients [c0, c1, c2, ...], compute `p(x) = c0 + x*(c1 + x*(c2 + ...))`.\nfn evaluate_polynomial\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    coefficients: \u0026[Target],\n    point: Target,\n) -\u003e Target {\n    builder.push_scope(\"evaluate_polynomial\");\n\n    assert!(\n        !coefficients.is_empty(),\n        \"we should have at least a constant polynomial\"\n    );\n    if coefficients.len() == 1 {\n        return coefficients[0];\n    }\n\n    let mut result = coefficients[coefficients.len() - 1];\n    for \u0026coeff in coefficients.iter().rev().skip(1) {\n        result = builder.mul(result, point);\n        result = builder.add(result, coeff);\n    }\n\n    builder.pop_scope(); // close `evaluate_polynomial` scope\n    result\n}\n\n/// Arithmetic-only version of Plonky3 `verify_query`:\n/// - Applies the fold chain and enforces equality to the provided final polynomial evaluation.\n/// - Caller must supply `initial_folded_eval` (the reduced opening at max height).\nfn verify_query\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    initial_folded_eval: Target,\n    phases: \u0026[FoldPhaseInputsTarget],\n    final_value: Target,\n) {\n    builder.push_scope(\"verify_query\");\n    let folded_eval = fold_row_chain(builder, initial_folded_eval, phases);\n    builder.connect(folded_eval, final_value);\n    builder.pop_scope(); // close `verify_query` scope\n}\n\n/// Compute the final query point after all FRI folding rounds.\n/// This is the point at which the final polynomial should be evaluated.\nfn compute_final_query_point\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    index_bits: \u0026[Target],\n    log_max_height: usize,\n    num_phases: usize,\n) -\u003e Target\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"compute_final_query_point\");\n\n    // Extract the bits that form domain_index (bits [num_phases..log_max_height]) after `num_phases` folds\n    let domain_index_bits: Vec\u003cTarget\u003e = index_bits[num_phases..log_max_height].to_vec();\n\n    // Pad bits and reverse\n    let mut reversed_bits = vec![builder.add_const(EF::ZERO); num_phases];\n    reversed_bits.extend(domain_index_bits.iter().rev().copied());\n\n    // Compute g^{reversed_index}\n    let g = F::two_adic_generator(log_max_height);\n    let powers_of_g: Vec\u003c_\u003e = iter::successors(Some(g), |\u0026prev| Some(prev.square()))\n        .take(log_max_height)\n        .map(|p| builder.add_const(EF::from(p)))\n        .collect();\n\n    let one = builder.add_const(EF::ONE);\n    let mut result = one;\n    for (\u0026bit, \u0026power) in reversed_bits.iter().zip(\u0026powers_of_g) {\n        let multiplier = builder.select(bit, power, one);\n        result = builder.mul(result, multiplier);\n    }\n\n    builder.pop_scope(); // close `compute_final_query_point` scope\n    result\n}\n\n/// Compute x₀ for phase `i` from the query index bits and a caller-provided power ladder.\n///\n/// For phase with folded height `k` (log_folded_height), caller must pass:\n///   `pows = [g^{2^0}, g^{2^1}, ..., g^{2^{k-1}}]`\n/// where `g = two_adic_generator(k + 1)` (note the +1 for arity-2).\n///\n/// We use bit window `bits[i+1 .. i+1+k]` (little-endian), but multiplied in reverse to match\n/// `reverse_bits_len(index \u003e\u003e (i+1), k)` semantics from the verifier.\nfn compute_x0_from_index_bits\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    index_bits: \u0026[Target],\n    phase: usize,\n    pows: \u0026[EF],\n) -\u003e Target {\n    builder.push_scope(\"compute_x0_from_index_bits\");\n\n    let one = builder.add_const(EF::ONE);\n    let mut res = one;\n\n    // Bits window: offset = i+1, length = pows.len() = k\n    let offset = phase + 1;\n    let k = pows.len();\n\n    for j in 0..k {\n        let bit = index_bits[offset + k - 1 - j]; // reversed\n        let pow_const = builder.add_const(pows[j]);\n        let diff = builder.sub(pow_const, one);\n        let diff_bit = builder.mul(diff, bit);\n        let gate = builder.add(one, diff_bit);\n        res = builder.mul(res, gate);\n    }\n\n    builder.pop_scope(); // close `compute_x0_from_index_bits` scope\n    res\n}\n\n/// Build and verify the fold chain from index bits:\n/// - `index_bits`: little-endian query index bits (must be boolean-constrained by caller).\n/// - `betas`/`sibling_values`/`roll_ins`: per-phase arrays.\n/// - `pows_per_phase[i]`: power ladder for the generator at that phase (see `compute_x0_from_index_bits`).\n#[allow(clippy::too_many_arguments)]\nfn verify_query_from_index_bits\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    initial_folded_eval: Target,\n    index_bits: \u0026[Target],\n    betas: \u0026[Target],\n    sibling_values: \u0026[Target],\n    roll_ins: \u0026[Option\u003cTarget\u003e],\n    pows_per_phase: \u0026[Vec\u003cEF\u003e],\n    final_value: Target,\n) {\n    builder.push_scope(\"verify_query_from_index_bits\");\n\n    let num_phases = betas.len();\n    debug_assert_eq!(\n        sibling_values.len(),\n        num_phases,\n        \"sibling_values len mismatch\"\n    );\n    debug_assert_eq!(roll_ins.len(), num_phases, \"roll_ins len mismatch\");\n    debug_assert_eq!(\n        pows_per_phase.len(),\n        num_phases,\n        \"pows_per_phase len mismatch\"\n    );\n\n    let one = builder.add_const(EF::ONE);\n\n    let mut phases_vec = Vec::with_capacity(num_phases);\n    for i in 0..num_phases {\n        // x0 from bits (using the appropriate generator ladder for this phase)\n        let x0 = compute_x0_from_index_bits(builder, index_bits, i, \u0026pows_per_phase[i]);\n\n        // sibling_is_right = 1 − (index_bit[i])\n        let raw_bit = index_bits[i];\n        let sibling_is_right = builder.sub(one, raw_bit);\n\n        phases_vec.push(FoldPhaseInputsTarget {\n            beta: betas[i],\n            x0,\n            e_sibling: sibling_values[i],\n            sibling_is_right,\n            roll_in: roll_ins[i],\n        });\n    }\n\n    verify_query(builder, initial_folded_eval, \u0026phases_vec, final_value);\n    builder.pop_scope(); // close `verify_query_from_index_bits` scope\n}\n\n/// Compute evaluation point x from domain height and reversed reduced index bits in the circuit field EF.\n/// x = GENERATOR * two_adic_generator(log_height)^{rev_reduced_index}\nfn compute_evaluation_point\u003cF, EF\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    log_height: usize,\n    rev_reduced_index_bits: \u0026[Target],\n) -\u003e Target\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"compute_evaluation_point\");\n\n    // Build power-of-two ladder for two-adic generator g: [g, g^2, g^4, ...]\n    let g = F::two_adic_generator(log_height);\n    let powers_of_g: Vec\u003c_\u003e = iter::successors(Some(g), |\u0026prev| Some(prev.square()))\n        .take(rev_reduced_index_bits.len())\n        .map(|p| builder.add_const(EF::from(p)))\n        .collect();\n\n    // Compute g^{rev_reduced_index} using the provided reversed bits\n    let one = builder.add_const(EF::ONE);\n    let mut g_pow_index = one;\n    for (\u0026bit, \u0026power) in rev_reduced_index_bits.iter().zip(\u0026powers_of_g) {\n        let multiplier = builder.select(bit, power, one);\n        g_pow_index = builder.mul(g_pow_index, multiplier);\n    }\n\n    // Multiply by the coset generator (also lifted to EF) to get x\n    let generator = builder.alloc_const(EF::from(F::GENERATOR), \"coset_generator\");\n    let eval_point = builder.alloc_mul(generator, g_pow_index, \"eval_point\");\n\n    builder.pop_scope(); // close `compute_evaluation_point` scope\n    eval_point\n}\n\n/// Compute reduced opening for a single matrix in circuit form (EF-field).\n/// ro += alpha_pow * (p_at_z - p_at_x) * (z - x)^{-1}; and alpha_pow *= alpha (per column)\nfn compute_single_reduced_opening\u003cEF: Field\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    opened_values: \u0026[Target], // Values at evaluation point x\n    point_values: \u0026[Target],  // Values at challenge point z\n    evaluation_point: Target, // x\n    challenge_point: Target,  // z\n    alpha_pow: Target,        // Current alpha power (for this height)\n    alpha: Target,            // Alpha challenge\n) -\u003e (Target, Target) // (new_alpha_pow, reduced_opening_contrib)\n{\n    builder.push_scope(\"compute_single_reduced_opening\");\n\n    let mut reduced_opening = builder.add_const(EF::ZERO);\n    let mut current_alpha_pow = alpha_pow;\n\n    // quotient = (z - x)^{-1}\n    let z_minus_x = builder.sub(challenge_point, evaluation_point);\n    let one = builder.add_const(EF::ONE);\n    let quotient = builder.div(one, z_minus_x);\n\n    for (\u0026p_at_x, \u0026p_at_z) in opened_values.iter().zip(point_values.iter()) {\n        // diff = p_at_z - p_at_x\n        let diff = builder.sub(p_at_z, p_at_x);\n\n        // term = alpha_pow * diff * quotient\n        let alpha_diff = builder.mul(current_alpha_pow, diff);\n        let term = builder.mul(alpha_diff, quotient);\n\n        reduced_opening = builder.add(reduced_opening, term);\n\n        // advance alpha power for the *next column in this height*\n        current_alpha_pow = builder.mul(current_alpha_pow, alpha);\n    }\n\n    builder.pop_scope(); // close `compute_single_reduced_opening` scope\n    (current_alpha_pow, reduced_opening)\n}\n\n/// Compute reduced openings grouped **by height** with **per-height alpha powers**,\n/// Returns a vector of (log_height, ro) sorted by descending height.\n///\n/// Reference (Plonky3): `p3_fri::verifier::open_input`\n#[allow(clippy::too_many_arguments)]\nfn open_input\u003cF, EF, Comm\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    log_global_max_height: usize,\n    index_bits: \u0026[Target],\n    alpha: Target,\n    log_blowup: usize,\n    commitments_with_opening_points: \u0026ComsWithOpeningsTargets\u003cComm, TwoAdicMultiplicativeCoset\u003cF\u003e\u003e,\n    batch_opened_values: \u0026[Vec\u003cVec\u003cTarget\u003e\u003e], // Per batch -\u003e per matrix -\u003e per column\n) -\u003e Result\u003cVec\u003c(usize, Target)\u003e, VerificationError\u003e\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n{\n    builder.push_scope(\"open_input\");\n\n    // TODO(challenger): Indices should be sampled from a RecursiveChallenger, not passed in.\n    for \u0026b in index_bits {\n        builder.assert_bool(b);\n    }\n    debug_assert_eq!(\n        index_bits.len(),\n        log_global_max_height,\n        \"index_bits.len() must equal log_global_max_height\"\n    );\n\n    // height -\u003e (alpha_pow_for_this_height, ro_sum_for_this_height)\n    let mut reduced_openings = BTreeMap::\u003cusize, (Target, Target)\u003e::new();\n\n    // Process each batch\n    for (batch_idx, ((_batch_commit, mats), batch_openings)) in zip_eq(\n        commitments_with_opening_points.iter(),\n        batch_opened_values.iter(),\n        VerificationError::InvalidProofShape(\n            \"Opened values and commitments count must match\".to_string(),\n        ),\n    )?\n    .enumerate()\n    {\n        // TODO: Add recursive MMCS verification here for this batch:\n        // Verify batch_openings against _batch_commit at the computed reduced_index.\n\n        // For each matrix in the batch\n        for (mat_idx, ((mat_domain, mat_points_and_values), mat_opening)) in zip_eq(\n            mats.iter(),\n            batch_openings.iter(),\n            VerificationError::InvalidProofShape(format!(\n                \"batch {batch_idx}: opened_values and point_values count must match\"\n            )),\n        )?\n        .enumerate()\n        {\n            let log_height = mat_domain.log_size() + log_blowup;\n\n            let bits_reduced = log_global_max_height - log_height;\n            let rev_bits: Vec\u003cTarget\u003e = index_bits[bits_reduced..bits_reduced + log_height]\n                .iter()\n                .rev()\n                .copied()\n                .collect();\n\n            // Compute evaluation point x\n            let x = compute_evaluation_point::\u003cF, EF\u003e(builder, log_height, \u0026rev_bits);\n\n            // Initialize / fetch per-height (alpha_pow, ro)\n            let (alpha_pow_h, ro_h) = reduced_openings\n                .entry(log_height)\n                .or_insert_with(|| (builder.add_const(EF::ONE), builder.add_const(EF::ZERO)));\n\n            // Process each (z, ps_at_z) pair for this matrix\n            for (z, ps_at_z) in mat_points_and_values {\n                if mat_opening.len() != ps_at_z.len() {\n                    return Err(VerificationError::InvalidProofShape(format!(\n                        \"batch {batch_idx} mat {mat_idx}: opened_values columns must match point_values columns\"\n                    )));\n                }\n\n                let (new_alpha_pow_h, ro_contrib) = compute_single_reduced_opening(\n                    builder,\n                    mat_opening,\n                    ps_at_z,\n                    x,\n                    *z,\n                    *alpha_pow_h,\n                    alpha,\n                );\n\n                *ro_h = builder.add(*ro_h, ro_contrib);\n                *alpha_pow_h = new_alpha_pow_h;\n            }\n        }\n\n        // `reduced_openings` would have a log_height = log_blowup entry only if there was a\n        // trace matrix of height 1. In this case `f` is constant, so `(f(zeta) - f(x))/(zeta - x)`\n        // must equal `0`.\n        if let Some((_ap, ro0)) = reduced_openings.get(\u0026log_blowup) {\n            let zero = builder.add_const(EF::ZERO);\n            builder.connect(*ro0, zero);\n        }\n    }\n\n    builder.pop_scope(); // close `open_input` scope\n\n    // Into descending (height, ro) list\n    Ok(reduced_openings\n        .into_iter()\n        .rev()\n        .map(|(h, (_ap, ro))| (h, ro))\n        .collect())\n}\n\n/// Verify FRI arithmetic in-circuit.\n///\n/// TODO:\n/// - Challenge/indices generation lives in the outer verifier. Keep this\n///   function purely arithmetic and take `alpha`, `betas`, and\n///   `index_bits_per_query` as inputs.\n/// - Add recursive MMCS verification for both input openings (`open_input`) and\n///   per-phase commitments.\n///\n/// Reference (Plonky3): `p3_fri::verifier::verify_fri`\n#[allow(clippy::too_many_arguments)]\npub fn verify_fri_circuit\u003cF, EF, RecMmcs, Inner, Witness, Comm\u003e(\n    builder: \u0026mut CircuitBuilder\u003cEF\u003e,\n    fri_proof_targets: \u0026FriProofTargets\u003cF, EF, RecMmcs, InputProofTargets\u003cF, EF, Inner\u003e, Witness\u003e,\n    alpha: Target,\n    betas: \u0026[Target],\n    index_bits_per_query: \u0026[Vec\u003cTarget\u003e],\n    commitments_with_opening_points: \u0026ComsWithOpeningsTargets\u003cComm, TwoAdicMultiplicativeCoset\u003cF\u003e\u003e,\n    log_blowup: usize,\n) -\u003e Result\u003c(), VerificationError\u003e\nwhere\n    F: Field + TwoAdicField,\n    EF: ExtensionField\u003cF\u003e,\n    RecMmcs: RecursiveExtensionMmcs\u003cF, EF\u003e,\n    Inner: RecursiveMmcs\u003cF, EF\u003e,\n    Witness: Recursive\u003cEF\u003e,\n{\n    builder.push_scope(\"verify_fri\");\n\n    let num_phases = betas.len();\n    let num_queries = fri_proof_targets.query_proofs.len();\n\n    // Validate shape.\n    if num_phases != fri_proof_targets.commit_phase_commits.len() {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"betas length must equal number of commit-phase commitments: expected {}, got {}\",\n            num_phases,\n            fri_proof_targets.commit_phase_commits.len()\n        )));\n    }\n\n    if num_queries != index_bits_per_query.len() {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"index_bits_per_query length must equal number of query proofs: expected {}, got {}\",\n            num_queries,\n            index_bits_per_query.len()\n        )));\n    }\n\n    let log_max_height = index_bits_per_query[0].len();\n    if index_bits_per_query\n        .iter()\n        .any(|v| v.len() != log_max_height)\n    {\n        return Err(VerificationError::InvalidProofShape(\n            \"all index_bits_per_query entries must have same length\".to_string(),\n        ));\n    }\n\n    if betas.is_empty() {\n        return Err(VerificationError::InvalidProofShape(\n            \"FRI must have at least one fold phase\".to_string(),\n        ));\n    }\n\n    // Compute the expected final polynomial length from FRI parameters\n    // log_max_height = num_phases + log_final_poly_len + log_blowup\n    // So: log_final_poly_len = log_max_height - num_phases - log_blowup\n    let log_final_poly_len = log_max_height\n        .checked_sub(num_phases)\n        .and_then(|x| x.checked_sub(log_blowup))\n        .ok_or_else(|| {\n            VerificationError::InvalidProofShape(\n                \"Invalid FRI parameters: log_max_height too small\".to_string(),\n            )\n        })?;\n\n    let expected_final_poly_len = 1 \u003c\u003c log_final_poly_len;\n    let actual_final_poly_len = fri_proof_targets.final_poly.len();\n\n    //  Check the final polynomial length.\n    if actual_final_poly_len != expected_final_poly_len {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Final polynomial length mismatch: expected 2^{log_final_poly_len} = {expected_final_poly_len}, got {actual_final_poly_len}\"\n        )));\n    }\n\n    // Precompute two-adic generator ladders for each phase (in circuit field EF).\n    //\n    // For phase i, folded height k = log_max_height - i - 1.\n    // Use generator g = two_adic_generator(k + 1) and ladder [g^{2^0},...,g^{2^{k-1}}].\n    let pows_per_phase: Vec\u003cVec\u003cEF\u003e\u003e = (0..num_phases)\n        .map(|i| {\n            // `k` is the height of the folded domain after `i` rounds of folding.\n            let k = log_max_height.saturating_sub(i + 1);\n            if k == 0 {\n                return Vec::new();\n            }\n            let g = F::two_adic_generator(k + 1);\n            // Create the power ladder [g, g^2, g^4, ...].\n            iter::successors(Some(g), |\u0026prev| Some(prev.square()))\n                .take(k)\n                .map(EF::from)\n                .collect()\n        })\n        .collect();\n\n    // For each query, extract opened values from proof and compute reduced openings and fold.\n    for (q, query_proof) in fri_proof_targets.query_proofs.iter().enumerate() {\n        // Extract opened values from the input_proof (batch openings)\n        // Structure: Vec\u003cBatchOpening\u003e where each BatchOpening has Vec\u003cVec\u003cTarget\u003e\u003e (matrices -\u003e columns)\n        let batch_opened_values: Vec\u003cVec\u003cVec\u003cTarget\u003e\u003e\u003e = query_proof\n            .input_proof\n            .iter()\n            .map(|batch| batch.opened_values.clone())\n            .collect();\n\n        // Arithmetic `open_input` to get (height, ro) descending\n        let reduced_by_height = open_input::\u003cF, EF, Comm\u003e(\n            builder,\n            log_max_height,\n            \u0026index_bits_per_query[q],\n            alpha,\n            log_blowup,\n            commitments_with_opening_points,\n            \u0026batch_opened_values,\n        )?;\n\n        // Must have the max-height entry at the front\n\n        if reduced_by_height.is_empty() {\n            return Err(VerificationError::InvalidProofShape(\n                \"No reduced openings; did you commit to zero polynomials?\".to_string(),\n            ));\n        }\n        if reduced_by_height[0].0 != log_max_height {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"First reduced opening must be at max height {}, got {}\",\n                log_max_height, reduced_by_height[0].0\n            )));\n        }\n        let initial_folded_eval = reduced_by_height[0].1;\n\n        // Sibling values for this query (one per phase)\n        let sibling_values: Vec\u003cTarget\u003e = query_proof\n            .commit_phase_openings\n            .iter()\n            .map(|opening| opening.sibling_value)\n            .collect();\n\n        if sibling_values.len() != num_phases {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"sibling_values must match number of betas/phases: expected {}, got {}\",\n                num_phases,\n                sibling_values.len()\n            )));\n        }\n\n        // Build height-aligned roll-ins for each phase (desc heights -\u003e phases)\n        let mut roll_ins: Vec\u003cOption\u003cTarget\u003e\u003e = vec![None; num_phases];\n        for \u0026(h, ro) in reduced_by_height.iter().skip(1) {\n            // height -\u003e phase index mapping\n            let i = log_max_height\n                .checked_sub(1)\n                .and_then(|x| x.checked_sub(h))\n                .expect(\"height-\u003ephase mapping underflow\");\n            if i \u003c num_phases {\n                // There should be at most one roll-in per phase since `reduced_by_height`\n                // aggregates all matrices at the same height already (and we only support a\n                // single input batch). Multiple entries mapping to the same phase indicate an\n                // invariant violation.\n                if roll_ins[i].is_some() {\n                    return Err(VerificationError::InvalidProofShape(format!(\n                        \"duplicate roll-in for phase {i} (height {h})\",\n                    )));\n                }\n                roll_ins[i] = Some(ro);\n            } else {\n                // If a height is below final folded height, it should be unused; connect to zero.\n                let zero = builder.add_const(EF::ZERO);\n                builder.connect(ro, zero);\n            }\n        }\n\n        // Compute the final query point for this query and evaluate the final polynomial\n        let final_query_point = compute_final_query_point::\u003cF, EF\u003e(\n            builder,\n            \u0026index_bits_per_query[q],\n            log_max_height,\n            num_phases,\n        );\n\n        let final_poly_eval =\n            evaluate_polynomial(builder, \u0026fri_proof_targets.final_poly, final_query_point);\n\n        // Perform the fold chain and connect to the evaluated final polynomial value\n        verify_query_from_index_bits(\n            builder,\n            initial_folded_eval,\n            \u0026index_bits_per_query[q],\n            betas,\n            \u0026sibling_values,\n            \u0026roll_ins,\n            \u0026pows_per_phase,\n            final_poly_eval,\n        );\n\n        builder.pop_scope(); // close `verify_fri` scope\n    }\n\n    Ok(())\n}\n","traces":[{"line":40,"address":[2049728],"length":1,"stats":{"Line":6}},{"line":45,"address":[4074441],"length":1,"stats":{"Line":6}},{"line":47,"address":[2955107],"length":1,"stats":{"Line":7}},{"line":49,"address":[2789383],"length":1,"stats":{"Line":7}},{"line":52,"address":[2049881],"length":1,"stats":{"Line":7}},{"line":53,"address":[2049920],"length":1,"stats":{"Line":7}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[4074671],"length":1,"stats":{"Line":7}},{"line":57,"address":[],"length":0,"stats":{"Line":7}},{"line":58,"address":[2789754],"length":1,"stats":{"Line":7}},{"line":59,"address":[3943996],"length":1,"stats":{"Line":7}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":61,"address":[4074586,4074623],"length":1,"stats":{"Line":14}},{"line":67,"address":[2955546],"length":1,"stats":{"Line":6}},{"line":70,"address":[1976571],"length":1,"stats":{"Line":6}},{"line":73,"address":[3944113],"length":1,"stats":{"Line":6}},{"line":74,"address":[2789931],"length":1,"stats":{"Line":6}},{"line":75,"address":[1976689],"length":1,"stats":{"Line":6}},{"line":76,"address":[2050437],"length":1,"stats":{"Line":6}},{"line":79,"address":[2050479],"length":1,"stats":{"Line":6}},{"line":80,"address":[2050515],"length":1,"stats":{"Line":6}},{"line":83,"address":[2790119],"length":1,"stats":{"Line":6}},{"line":84,"address":[4075090],"length":1,"stats":{"Line":6}},{"line":87,"address":[1976897,1976948,1977062],"length":1,"stats":{"Line":10}},{"line":88,"address":[2790246],"length":1,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[4075137],"length":1,"stats":{"Line":6}},{"line":95,"address":[2790207],"length":1,"stats":{"Line":6}},{"line":100,"address":[3951456],"length":1,"stats":{"Line":7}},{"line":105,"address":[2797289],"length":1,"stats":{"Line":7}},{"line":107,"address":[3951540],"length":1,"stats":{"Line":5}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[2963170],"length":1,"stats":{"Line":7}},{"line":112,"address":[3951655,3951603,3951642],"length":1,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":116,"address":[2797515,2797757,2797640],"length":1,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[2797744],"length":1,"stats":{"Line":1}},{"line":121,"address":[1984484],"length":1,"stats":{"Line":1}},{"line":122,"address":[3951993],"length":1,"stats":{"Line":1}},{"line":128,"address":[2954896],"length":1,"stats":{"Line":6}},{"line":134,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[4074344],"length":1,"stats":{"Line":6}},{"line":136,"address":[2049708],"length":1,"stats":{"Line":6}},{"line":137,"address":[4074374],"length":1,"stats":{"Line":6}},{"line":142,"address":[2964592,2965710,2965716],"length":1,"stats":{"Line":6}},{"line":152,"address":[1985447],"length":1,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[4083758,4083839],"length":1,"stats":{"Line":12}},{"line":159,"address":[2059359,2059439],"length":1,"stats":{"Line":13}},{"line":162,"address":[2799111],"length":1,"stats":{"Line":7}},{"line":163,"address":[4084752,4084766,4084065],"length":1,"stats":{"Line":22}},{"line":164,"address":[],"length":0,"stats":{"Line":7}},{"line":165,"address":[2059640,2060272,2060285],"length":1,"stats":{"Line":21}},{"line":168,"address":[2799328,2799246],"length":1,"stats":{"Line":14}},{"line":169,"address":[4084244],"length":1,"stats":{"Line":7}},{"line":170,"address":[3953574,3953977],"length":1,"stats":{"Line":14}},{"line":171,"address":[4084513,4084626],"length":1,"stats":{"Line":14}},{"line":172,"address":[2799724],"length":1,"stats":{"Line":7}},{"line":175,"address":[2799623],"length":1,"stats":{"Line":7}},{"line":176,"address":[4084539],"length":1,"stats":{"Line":7}},{"line":187,"address":[3954128],"length":1,"stats":{"Line":7}},{"line":193,"address":[],"length":0,"stats":{"Line":7}},{"line":195,"address":[1986731],"length":1,"stats":{"Line":7}},{"line":196,"address":[2800072],"length":1,"stats":{"Line":7}},{"line":199,"address":[4084939,4085004],"length":1,"stats":{"Line":7}},{"line":200,"address":[4084974],"length":1,"stats":{"Line":7}},{"line":202,"address":[2800119,2800154,2800596],"length":1,"stats":{"Line":20}},{"line":203,"address":[2060703,2060658,2060861],"length":1,"stats":{"Line":14}},{"line":204,"address":[2966521,2966675,2966473],"length":1,"stats":{"Line":14}},{"line":205,"address":[2966582],"length":1,"stats":{"Line":6}},{"line":206,"address":[1987261],"length":1,"stats":{"Line":6}},{"line":207,"address":[1987284],"length":1,"stats":{"Line":6}},{"line":208,"address":[4085411],"length":1,"stats":{"Line":6}},{"line":211,"address":[2800249],"length":1,"stats":{"Line":6}},{"line":212,"address":[3954478],"length":1,"stats":{"Line":6}},{"line":220,"address":[4087109,4085456,4087103],"length":1,"stats":{"Line":6}},{"line":230,"address":[4085721],"length":1,"stats":{"Line":6}},{"line":232,"address":[4085746],"length":1,"stats":{"Line":6}},{"line":233,"address":[2800925],"length":1,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[4085906],"length":1,"stats":{"Line":6}},{"line":239,"address":[4086066],"length":1,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[2967461],"length":1,"stats":{"Line":6}},{"line":247,"address":[3955662],"length":1,"stats":{"Line":6}},{"line":248,"address":[2967523,2967606],"length":1,"stats":{"Line":12}},{"line":250,"address":[2062088,2062216],"length":1,"stats":{"Line":12}},{"line":253,"address":[3956189,3956131],"length":1,"stats":{"Line":6}},{"line":254,"address":[2062435,2062376],"length":1,"stats":{"Line":12}},{"line":256,"address":[],"length":0,"stats":{"Line":12}},{"line":257,"address":[2802010,2802060],"length":1,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[2968104,2968196,2968166],"length":1,"stats":{"Line":12}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[3956333,3956407,3956495],"length":1,"stats":{"Line":12}},{"line":265,"address":[2062106],"length":1,"stats":{"Line":6}},{"line":266,"address":[1988459],"length":1,"stats":{"Line":6}},{"line":271,"address":[3952016,3952737,3952731],"length":1,"stats":{"Line":6}},{"line":280,"address":[2058283],"length":1,"stats":{"Line":6}},{"line":283,"address":[2058305],"length":1,"stats":{"Line":6}},{"line":284,"address":[3952816,3952830,3952116],"length":1,"stats":{"Line":19}},{"line":285,"address":[4082845],"length":1,"stats":{"Line":6}},{"line":286,"address":[2058973,2058960,2058377],"length":1,"stats":{"Line":19}},{"line":290,"address":[2798059,2797970],"length":1,"stats":{"Line":13}},{"line":291,"address":[2798066],"length":1,"stats":{"Line":6}},{"line":292,"address":[],"length":0,"stats":{"Line":12}},{"line":293,"address":[2964134,2964306],"length":1,"stats":{"Line":12}},{"line":294,"address":[2964313],"length":1,"stats":{"Line":6}},{"line":298,"address":[2058753],"length":1,"stats":{"Line":6}},{"line":299,"address":[1985100],"length":1,"stats":{"Line":6}},{"line":301,"address":[4083329],"length":1,"stats":{"Line":6}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[2802320],"length":1,"stats":{"Line":6}},{"line":317,"address":[],"length":0,"stats":{"Line":6}},{"line":319,"address":[2802460],"length":1,"stats":{"Line":6}},{"line":320,"address":[2062958],"length":1,"stats":{"Line":6}},{"line":323,"address":[2802530],"length":1,"stats":{"Line":6}},{"line":324,"address":[2968615],"length":1,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":6}},{"line":327,"address":[2968702,2969005],"length":1,"stats":{"Line":12}},{"line":329,"address":[2063273],"length":1,"stats":{"Line":6}},{"line":332,"address":[2968924],"length":1,"stats":{"Line":6}},{"line":333,"address":[],"length":0,"stats":{"Line":6}},{"line":335,"address":[4087653],"length":1,"stats":{"Line":6}},{"line":338,"address":[4087675],"length":1,"stats":{"Line":6}},{"line":341,"address":[2802951],"length":1,"stats":{"Line":6}},{"line":342,"address":[3957180],"length":1,"stats":{"Line":6}},{"line":350,"address":[3939248,3943230,3943240],"length":1,"stats":{"Line":7}},{"line":363,"address":[1971961],"length":1,"stats":{"Line":7}},{"line":366,"address":[2045735,2045714],"length":1,"stats":{"Line":12}},{"line":367,"address":[2951109],"length":1,"stats":{"Line":6}},{"line":369,"address":[2785396],"length":1,"stats":{"Line":6}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[2951276],"length":1,"stats":{"Line":6}},{"line":379,"address":[2046306,2046435,2046531,2049446],"length":1,"stats":{"Line":12}},{"line":380,"address":[],"length":0,"stats":{"Line":6}},{"line":381,"address":[3939921],"length":1,"stats":{"Line":6}},{"line":382,"address":[4070903],"length":1,"stats":{"Line":6}},{"line":383,"address":[1972472],"length":1,"stats":{"Line":6}},{"line":386,"address":[2951804],"length":1,"stats":{"Line":6}},{"line":392,"address":[2952870,2954740,2952774,2952645],"length":1,"stats":{"Line":12}},{"line":393,"address":[1973246,1972982],"length":1,"stats":{"Line":12}},{"line":394,"address":[],"length":0,"stats":{"Line":6}},{"line":395,"address":[4071787],"length":1,"stats":{"Line":6}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":6}},{"line":401,"address":[2953278,2953347,2953041],"length":1,"stats":{"Line":12}},{"line":403,"address":[4072726,4072661,4072755],"length":1,"stats":{"Line":12}},{"line":404,"address":[2787663,2787734],"length":1,"stats":{"Line":11}},{"line":411,"address":[2048373,2048472],"length":1,"stats":{"Line":12}},{"line":414,"address":[4073251],"length":1,"stats":{"Line":6}},{"line":415,"address":[],"length":0,"stats":{"Line":6}},{"line":416,"address":[4073220,4074160,4074178],"length":1,"stats":{"Line":18}},{"line":419,"address":[4073820,4073279],"length":1,"stats":{"Line":12}},{"line":420,"address":[],"length":0,"stats":{"Line":12}},{"line":421,"address":[2788720,2788452],"length":1,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[3942651],"length":1,"stats":{"Line":6}},{"line":429,"address":[],"length":0,"stats":{"Line":6}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[2788596],"length":1,"stats":{"Line":6}},{"line":432,"address":[2049031],"length":1,"stats":{"Line":6}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[3942898],"length":1,"stats":{"Line":6}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":444,"address":[3941571],"length":1,"stats":{"Line":6}},{"line":445,"address":[2047897],"length":1,"stats":{"Line":2}},{"line":446,"address":[2787528],"length":1,"stats":{"Line":2}},{"line":450,"address":[3940520],"length":1,"stats":{"Line":6}},{"line":453,"address":[2046735,2046875],"length":1,"stats":{"Line":12}},{"line":454,"address":[],"length":0,"stats":{"Line":6}},{"line":455,"address":[2952110],"length":1,"stats":{"Line":6}},{"line":456,"address":[2789136,2786405,2789141],"length":1,"stats":{"Line":18}},{"line":457,"address":[1973148],"length":1,"stats":{"Line":6}},{"line":471,"address":[2956080,2962317,2961584],"length":1,"stats":{"Line":6}},{"line":487,"address":[2956312],"length":1,"stats":{"Line":6}},{"line":489,"address":[],"length":0,"stats":{"Line":6}},{"line":490,"address":[2790625],"length":1,"stats":{"Line":6}},{"line":493,"address":[3944874],"length":1,"stats":{"Line":6}},{"line":494,"address":[2790713],"length":1,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[4075617],"length":1,"stats":{"Line":6}},{"line":502,"address":[2051487],"length":1,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[1978085,1977743,1978171],"length":1,"stats":{"Line":12}},{"line":510,"address":[2791437],"length":1,"stats":{"Line":7}},{"line":512,"address":[3951296,3951328,3945640],"length":1,"stats":{"Line":21}},{"line":514,"address":[1978253],"length":1,"stats":{"Line":0}},{"line":515,"address":[1978219],"length":1,"stats":{"Line":0}},{"line":519,"address":[2791484],"length":1,"stats":{"Line":7}},{"line":520,"address":[1978478],"length":1,"stats":{"Line":0}},{"line":521,"address":[2791724],"length":1,"stats":{"Line":0}},{"line":528,"address":[2052306,2052047,2052103],"length":1,"stats":{"Line":13}},{"line":529,"address":[4076575],"length":1,"stats":{"Line":7}},{"line":530,"address":[],"length":0,"stats":{"Line":21}},{"line":531,"address":[2052090,2057456],"length":1,"stats":{"Line":7}},{"line":532,"address":[3950943],"length":1,"stats":{"Line":0}},{"line":533,"address":[1983774],"length":1,"stats":{"Line":0}},{"line":537,"address":[1978727,1978643],"length":1,"stats":{"Line":6}},{"line":538,"address":[3946194],"length":1,"stats":{"Line":7}},{"line":541,"address":[1978707],"length":1,"stats":{"Line":7}},{"line":542,"address":[2957848],"length":1,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[4076964],"length":1,"stats":{"Line":7}},{"line":552,"address":[],"length":0,"stats":{"Line":14}},{"line":554,"address":[1983499,1983560],"length":1,"stats":{"Line":7}},{"line":555,"address":[],"length":0,"stats":{"Line":7}},{"line":556,"address":[3951146],"length":1,"stats":{"Line":0}},{"line":558,"address":[2796824,2796894,2796790],"length":1,"stats":{"Line":14}},{"line":560,"address":[1983918,1983635,1983904],"length":1,"stats":{"Line":20}},{"line":561,"address":[1983652],"length":1,"stats":{"Line":7}},{"line":562,"address":[4081727],"length":1,"stats":{"Line":7}},{"line":563,"address":[2962610],"length":1,"stats":{"Line":6}},{"line":568,"address":[2792090,2792548],"length":1,"stats":{"Line":12}},{"line":571,"address":[],"length":0,"stats":{"Line":6}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[3947168,3950832,3950867],"length":1,"stats":{"Line":21}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[3947238],"length":1,"stats":{"Line":7}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[1979902],"length":1,"stats":{"Line":7}},{"line":590,"address":[4078546,4078485],"length":1,"stats":{"Line":12}},{"line":591,"address":[4081399],"length":1,"stats":{"Line":0}},{"line":592,"address":[2054074],"length":1,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":14}},{"line":596,"address":[3950420],"length":1,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[4078675],"length":1,"stats":{"Line":0}},{"line":601,"address":[3947921,3948008],"length":1,"stats":{"Line":14}},{"line":604,"address":[2793801],"length":1,"stats":{"Line":6}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[2959611,2962736,2962746],"length":1,"stats":{"Line":18}},{"line":610,"address":[2054444,2054377],"length":1,"stats":{"Line":12}},{"line":611,"address":[2961614],"length":1,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[4078999,4080797],"length":1,"stats":{"Line":0}},{"line":619,"address":[1980742],"length":1,"stats":{"Line":6}},{"line":620,"address":[3948305,3948384],"length":1,"stats":{"Line":12}},{"line":622,"address":[2055735,2054836],"length":1,"stats":{"Line":4}},{"line":624,"address":[3951017,3950992,3949460],"length":1,"stats":{"Line":6}},{"line":626,"address":[2795311,2795573],"length":1,"stats":{"Line":4}},{"line":631,"address":[2055799,2055877],"length":1,"stats":{"Line":4}},{"line":632,"address":[4080436,4080505],"length":1,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[2055898,2055996],"length":1,"stats":{"Line":4}},{"line":639,"address":[1982141,1982057],"length":1,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":6}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[4079568],"length":1,"stats":{"Line":7}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[4079670],"length":1,"stats":{"Line":6}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[3949079],"length":1,"stats":{"Line":6}},{"line":662,"address":[3949142],"length":1,"stats":{"Line":6}},{"line":663,"address":[2960703],"length":1,"stats":{"Line":6}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[2795138],"length":1,"stats":{"Line":6}},{"line":670,"address":[],"length":0,"stats":{"Line":6}}],"covered":215,"coverable":281},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","pcs","mod.rs"],"content":"//! Polynomial Commitment Scheme (PCS) implementations for recursive verification.\n\npub mod fri;\n\npub use fri::{\n    BatchOpeningTargets, CommitPhaseProofStepTargets, FriProofTargets, FriVerifierParams,\n    HashProofTargets, HashTargets, InputProofTargets, MAX_QUERY_INDEX_BITS, QueryProofTargets,\n    RecExtensionValMmcs, RecValMmcs, TwoAdicFriProofTargets, Witness, verify_fri_circuit,\n};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","prelude.rs"],"content":"//! Prelude module for common imports.\n//!\n//! This module re-exports the most commonly used items from the crate,\n//! allowing users to write:\n//!\n//! ```ignore\n//! use p3_recursion::prelude::*;\n//! ```\n//!\n//! Instead of importing each item individually.\n\npub use crate::Target;\npub use crate::challenger::CircuitChallenger;\npub use crate::generation::{GenerationError, PcsGeneration, generate_challenges};\npub use crate::pcs::fri::{FriVerifierParams, MAX_QUERY_INDEX_BITS};\npub use crate::public_inputs::{\n    CommitmentOpening, FriVerifierInputs, PublicInputBuilder, StarkVerifierInputs,\n    StarkVerifierInputsBuilder,\n};\npub use crate::traits::{\n    ComsWithOpeningsTargets, Recursive, RecursiveAir, RecursiveChallenger, RecursiveExtensionMmcs,\n    RecursiveMmcs, RecursivePcs,\n};\npub use crate::types::{\n    CommitmentTargets, OpenedValuesTargets, ProofTargets, RecursiveLagrangeSelectors,\n    StarkChallenges,\n};\npub use crate::verifier::{ObservableCommitment, VerificationError, verify_circuit};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","public_inputs.rs"],"content":"//! This module provides type-safe builders and helper functions\n//! for constructing public inputs for recursive verification circuits.\n\nuse alloc::vec::Vec;\n\nuse p3_batch_stark::{BatchProof, CommonData};\nuse p3_circuit::CircuitBuilder;\nuse p3_commit::Pcs;\nuse p3_field::{BasedVectorSpace, Field, PrimeField64};\nuse p3_uni_stark::{Proof, StarkGenericConfig, Val};\n\nuse crate::pcs::MAX_QUERY_INDEX_BITS;\nuse crate::traits::Recursive;\nuse crate::verifier::BatchProofTargets;\nuse crate::{PreprocessedVerifierDataTargets, ProofTargets};\n\n/// Builder for constructing a flat public input vector in a canonical order.\n///\n/// This type accumulates field elements in insertion order.\n///\n/// **NOTE:** The caller is responsible for calling the methods in the same logical\n/// order in which the circuit allocated its public input targets.\n///\n/// The key invariant is:\n///\n/// - The order of calls to this builder must match the order in which the\n///   circuit created its public input targets.\n///\n/// If this invariant is broken, the verifier circuit will read incorrect\n/// values and verification will fail, even if the proof is valid.\n///\n/// # Typical usage\n///\n/// ```ignore\n/// let inputs = PublicInputBuilder::new()\n///     .add_proof_values(proof_values)\n///     .add_challenge(alpha)\n///     .add_challenges(betas)\n///     .build();\n/// ```\n#[derive(Default)]\npub struct PublicInputBuilder\u003cF: Field\u003e {\n    /// Accumulated public input values in exact insertion order.\n    inputs: Vec\u003cF\u003e,\n}\n\nimpl\u003cF: Field\u003e PublicInputBuilder\u003cF\u003e {\n    /// Creates a new empty builder with no accumulated inputs.\n    ///\n    /// The internal vector starts empty and grows as values are added.\n    pub const fn new() -\u003e Self {\n        Self { inputs: Vec::new() }\n    }\n\n    /// Appends a sequence of proof-related values.\n    ///\n    /// These values are usually extracted from a proof or commitment structure.\n    /// They may represent commitments, opened evaluations, FRI data, and\n    /// other components that must appear as public inputs.\n    ///\n    /// # Parameters\n    /// - `values`: An iterable collection of field elements to append.\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_proof_values(\u0026mut self, values: impl IntoIterator\u003cItem = F\u003e) -\u003e \u0026mut Self {\n        // Append all provided values at the end of the internal buffer.\n        self.inputs.extend(values);\n        self\n    }\n\n    /// Appends a single challenge value.\n    ///\n    /// Challenges are random-looking values produced by Fiat–Shamir\n    /// procedure on the verifier side.\n    ///\n    /// # Parameters\n    /// - `challenge`: The challenge field element to append.\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_challenge(\u0026mut self, challenge: F) -\u003e \u0026mut Self {\n        // Push one challenge at the end of the buffer.\n        self.inputs.push(challenge);\n        self\n    }\n\n    /// Appends a sequence of challenge values.\n    ///\n    /// The order of the iterator is preserved in the public input vector.\n    ///\n    /// # Parameters\n    /// - `challenges`: An iterable collection of challenge elements.\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_challenges(\u0026mut self, challenges: impl IntoIterator\u003cItem = F\u003e) -\u003e \u0026mut Self {\n        self.inputs.extend(challenges);\n        self\n    }\n\n    /// Appends the bit decomposition of a query index.\n    ///\n    /// A FRI query index is decomposed into its binary representation.\n    ///\n    /// The bits are stored in little-endian order:\n    /// - bit 0 (least significant bit) comes first.\n    ///\n    /// More precisely, for an integer index `i` we append bits:\n    ///\n    /// ```text\n    ///     i = Σ(j=0 to k-1) b_j · 2^j\n    /// ```\n    ///\n    /// where b_j ∈ {0, 1} and k = `MAX_QUERY_INDEX_BITS`.\n    ///\n    /// # Parameters\n    /// - `index`: The query index as a field element.\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_query_index(\u0026mut self, index: F) -\u003e \u0026mut Self\n    where\n        F: PrimeField64,\n    {\n        // Interpret the field element as a canonical 64-bit integer.\n        let index_usize = index.as_canonical_u64() as usize;\n\n        // For each bit position k in [0, MAX_QUERY_INDEX_BITS):\n        for k in 0..MAX_QUERY_INDEX_BITS {\n            // Extract bit k: shift right by k, then mask with 1.\n            let bit = if (index_usize \u003e\u003e k) \u0026 1 == 1 {\n                F::ONE\n            } else {\n                F::ZERO\n            };\n            // Append the bit as a field element (0 or 1).\n            self.inputs.push(bit);\n        }\n\n        self\n    }\n\n    /// Appends pre-decomposed query index bits.\n    ///\n    /// Use this when the bit decomposition has already been performed elsewhere.\n    ///\n    /// The bits must be given in little-endian order (LSB first), and each bit\n    /// should be encoded as field element 0 or 1.\n    ///\n    /// **WARNING**: The number of bits should be \u003c= `MAX_QUERY_INDEX_BITS`.\n    ///\n    /// # Parameters\n    /// - `bits`: An iterable collection of bit elements (each 0 or 1).\n    ///\n    /// # Returns\n    /// A mutable reference to `self` for method chaining.\n    pub fn add_query_index_bits(\u0026mut self, bits: impl IntoIterator\u003cItem = F\u003e) -\u003e \u0026mut Self {\n        // Simply append the provided bits without modification.\n        self.inputs.extend(bits);\n        self\n    }\n\n    /// Returns the current number of accumulated inputs.\n    ///\n    /// This is the length of the internal `inputs` vector.\n    pub const fn len(\u0026self) -\u003e usize {\n        self.inputs.len()\n    }\n\n    /// Returns `true` if no inputs have been added yet.\n    ///\n    /// This is equivalent to `self.len() == 0`.\n    pub const fn is_empty(\u0026self) -\u003e bool {\n        self.inputs.is_empty()\n    }\n\n    /// Consumes the builder and returns the final public input vector.\n    ///\n    /// The returned vector contains all accumulated values in insertion order.\n    ///\n    /// No further modifications can be made through this builder.\n    pub fn build(self) -\u003e Vec\u003cF\u003e {\n        self.inputs\n    }\n}\n\n/// Opening data for a single polynomial commitment.\n///\n/// In a polynomial commitment scheme, a commitment binds to a polynomial.\n///\n/// An opening provides evidence that the committed polynomial evaluates to\n/// specific values at specific points.\n#[derive(Clone, Debug)]\npub struct CommitmentOpening\u003cF: Field\u003e {\n    /// The commitment value in the field representation used by the circuit.\n    pub commitment: F,\n\n    /// Opened evaluation points and their corresponding values.\n    ///\n    /// Each entry is a pair `(z, v)` where:\n    /// - `z` is an evaluation point,\n    /// - `v` is the vector of polynomial values at `z`.\n    pub opened_points: Vec\u003c(F, Vec\u003cF\u003e)\u003e,\n}\n\n/// Helper structure for constructing public inputs for FRI-only circuits.\npub struct FriVerifierInputs\u003cF: Field\u003e {\n    /// Field values extracted from the FRI proof.\n    pub fri_proof_values: Vec\u003cF\u003e,\n\n    /// The batching challenge α used to combine multiple polynomials.\n    ///\n    /// For polynomials p_i(x), the combined polynomial is:\n    ///\n    /// ```text\n    ///     p_comb(x) = Σ_i α^i · p_i(x)\n    /// ```\n    pub alpha: F,\n\n    /// FRI folding challenges.\n    ///\n    /// In each FRI round, the polynomial is folded using a challenge β:\n    ///\n    /// ```text\n    ///     p'(x) = p_even(x) + β · p_odd(x)\n    /// ```\n    pub betas: Vec\u003cF\u003e,\n\n    /// Query index bits for each query, in little-endian order.\n    ///\n    /// Each inner vector:\n    /// - has length `MAX_QUERY_INDEX_BITS`,\n    /// - encodes one query index as bits 0 or 1.\n    pub query_index_bits: Vec\u003cVec\u003cF\u003e\u003e,\n\n    /// Commitment openings for all committed polynomials involved in FRI.\n    pub commitment_openings: Vec\u003cCommitmentOpening\u003cF\u003e\u003e,\n}\n\nimpl\u003cF: Field\u003e FriVerifierInputs\u003cF\u003e {\n    /// Flattens all FRI-related data into a single public input vector.\n    ///\n    /// # Canonical input order\n    /// 1. FRI proof values,\n    /// 2. Batching challenge α,\n    /// 3. FRI folding challenges β,\n    /// 4. Query index bits for each query,\n    /// 5. Commitment openings:\n    ///    - Commitment,\n    ///    - For each opening: `(z, f(z))` values.\n    ///\n    /// # Returns\n    /// A vector of field elements ready for circuit execution.\n    pub fn build(self) -\u003e Vec\u003cF\u003e {\n        // Start from an empty builder.\n        let mut builder = PublicInputBuilder::new();\n\n        // 1. Add all values extracted from the FRI proof structure.\n        builder.add_proof_values(self.fri_proof_values);\n\n        // 2. Add the α challenge for polynomial batching.\n        builder.add_challenge(self.alpha);\n\n        // 3. Add all β challenges for FRI folding.\n        builder.add_challenges(self.betas);\n\n        // 4. Add query index bits for each query.\n        for bits in self.query_index_bits {\n            // Verify that the bit length is \u003c= MAX_QUERY_INDEX_BITS.\n            debug_assert!(\n                bits.len() \u003c= MAX_QUERY_INDEX_BITS,\n                \"query index bit length exceeds limit\"\n            );\n            builder.add_query_index_bits(bits);\n        }\n\n        // 5. Add commitment openings in a fixed layout.\n        for opening in self.commitment_openings {\n            // First add the commitment value itself.\n            builder.add_challenge(opening.commitment);\n\n            // Then, for each opened point, add (z, values at z).\n            for (z, values) in opening.opened_points {\n                builder.add_challenge(z);\n                builder.add_proof_values(values);\n            }\n        }\n\n        // Return the flattened public input vector.\n        builder.build()\n    }\n}\n\n/// Helper structure for constructing public inputs for full STARK verification.\n///\n/// The output is a vector of extension field elements fed to a verifier circuit.\npub struct StarkVerifierInputs\u003cF, EF\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: Field + BasedVectorSpace\u003cF\u003e + From\u003cF\u003e,\n{\n    /// Public input values for the AIR being verified, in the base field.\n    ///\n    /// These encode the statement being proven.\n    pub air_public_values: Vec\u003cF\u003e,\n\n    /// Values extracted from the proof in the extension field.\n    ///\n    /// These encodings usually include:\n    /// - trace commitments,\n    /// - opened values,\n    /// - FRI-related data.\n    pub proof_values: Vec\u003cEF\u003e,\n\n    /// Values extracted from the preprocessed commitment, if present.\n    ///\n    /// These are also in the extension field.\n    pub preprocessed: Vec\u003cEF\u003e,\n\n    /// All Fiat–Shamir challenges used by the verifier.\n    ///\n    /// This typically includes:\n    /// - batching challenge,\n    /// - evaluation points for openings,\n    /// - FRI folding challenges,\n    /// - query indices.\n    pub challenges: Vec\u003cEF\u003e,\n\n    /// Number of FRI queries in the proof.\n    pub num_queries: usize,\n}\n\nimpl\u003cF, EF\u003e StarkVerifierInputs\u003cF, EF\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: Field + BasedVectorSpace\u003cF\u003e + From\u003cF\u003e,\n{\n    /// Flattens all STARK-related data into a single public input vector.\n    ///\n    /// # Canonical input order\n    /// 1. AIR public values,\n    /// 2. Proof values,\n    /// 3. Preprocessed commitment values,\n    /// 4. All challenges.\n    ///\n    /// # Returns\n    /// A vector of extension field elements ready for circuit execution.\n    pub fn build(self) -\u003e Vec\u003cEF\u003e {\n        // Use a builder over extension field elements.\n        let mut builder = PublicInputBuilder::new();\n\n        // 1. Lift AIR public values from base field to extension field.\n        builder.add_proof_values(self.air_public_values.iter().map(|\u0026v| v.into()));\n\n        // 2. Add proof values (already in extension field).\n        builder.add_proof_values(self.proof_values);\n\n        // 3. Add preprocessed commitment values.\n        builder.add_proof_values(self.preprocessed);\n\n        // 4. Add all challenges in the order provided.\n        builder.add_challenges(self.challenges.iter().copied());\n\n        builder.build()\n    }\n}\n\n/// Constructs public inputs for a batch (multi-instance) STARK verification circuit.\n///\n/// Batch verification proves several AIR instances at once.\n/// All instances share the same challenges, but each instance has its own AIR public values.\n///\n/// # Parameters\n/// - `air_public_values`: For each instance, its AIR public values in `F`.\n/// - `proof_values`: Values extracted from the batch proof in `EF`.\n/// - `preprocessed`: Preprocessed values.\n/// - `challenges`: All challenges shared across the batch in `EF`.\n///\n/// # Returns\n/// A vector of extension field elements suitable for a batch verifier circuit.\npub fn construct_batch_stark_verifier_inputs\u003cF, EF\u003e(\n    air_public_values: \u0026[Vec\u003cF\u003e],\n    proof_values: \u0026[EF],\n    preprocessed: \u0026[EF],\n    challenges: \u0026[EF],\n) -\u003e Vec\u003cEF\u003e\nwhere\n    F: Field + PrimeField64,\n    EF: Field + BasedVectorSpace\u003cF\u003e + From\u003cF\u003e,\n{\n    // Builder over extension field elements.\n    let mut builder = PublicInputBuilder::new();\n\n    // Add public values for each AIR instance, lifting from F to EF.\n    for instance_pv in air_public_values {\n        builder.add_proof_values(instance_pv.iter().map(|\u0026v| v.into()));\n    }\n\n    // Add proof values (already in extension field).\n    builder.add_proof_values(proof_values.iter().copied());\n\n    // Add preprocessed values.\n    builder.add_proof_values(preprocessed.iter().copied());\n\n    // Add all shared challenges.\n    builder.add_challenges(challenges.iter().copied());\n\n    builder.build()\n}\n\n/// Two-phase builder for single-instance STARK verification circuits.\n///\n/// This builder ties together:\n/// 1. Circuit construction phase:\n///    - allocate public input targets in the circuit,\n///    - record their structure inside this builder.\n/// 2. Execution phase:\n///    - pack concrete values into a public input vector in exactly the same\n///      order as the allocation order.\n///\n/// The central invariant is that target allocation and value packing are\n/// perfectly aligned in both order and shape.\n///\n/// # Usage Pattern\n///\n/// ```ignore\n/// // Phase 1: Circuit building\n/// let mut circuit = CircuitBuilder::new();\n/// let verifier = StarkVerifierInputsBuilder::allocate(\u0026mut circuit, \u0026proof, pis.len());\n/// verify_circuit(config, air, \u0026mut circuit, \u0026verifier.proof_targets, \u0026verifier.air_public_targets, ...)?;\n/// let built_circuit = circuit.build()?;\n///\n/// // Phase 2: Execution\n/// let challenges = generate_challenges(...);\n/// let public_inputs = verifier.pack_values(\u0026pis, \u0026proof, \u0026challenges, num_queries);\n/// runner.set_public_inputs(\u0026public_inputs)?;\n/// ```\npub struct StarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e\nwhere\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n    OpeningProof:\n        Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    /// Public input targets for the AIR public values.\n    ///\n    /// The element at index `i` corresponds to the `i`-th AIR public value.\n    pub air_public_targets: Vec\u003ccrate::Target\u003e,\n\n    /// Targets representing the entire proof structure.\n    ///\n    /// This includes trace commitments, opened evaluations, and FRI data.\n    pub proof_targets: ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n\n    /// Target representation of the preprocessed commitment, if present.\n    ///\n    /// `None` when the AIR has no preprocessed columns.\n    pub preprocessed_commit: Option\u003cComm\u003e,\n}\n\n/// Type alias for the commitment type inside a STARK configuration.\n///\n/// This extracts the commitment type of the PCS used by the configuration.\ntype Com\u003cSC\u003e = \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    \u003cSC as StarkGenericConfig\u003e::Challenger,\n\u003e\u003e::Commitment;\n\nimpl\u003cSC, Comm, OpeningProof\u003e StarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e\nwhere\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n    OpeningProof:\n        Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    /// Allocates all public input targets during circuit construction.\n    ///\n    /// This method only inspects the *shape* of the proof and preprocessed\n    /// commitment. It does not depend on any concrete values.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder in which targets are allocated.\n    /// - `proof`: A reference proof used solely to determine the target shape.\n    /// - `preprocessed_commit`: Optional reference preprocessed commitment.\n    /// - `num_air_public_inputs`: Number of AIR public inputs.\n    ///\n    /// # Returns\n    /// A `StarkVerifierInputsBuilder` that remembers the allocation layout.\n    pub fn allocate(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        proof: \u0026Proof\u003cSC\u003e,\n        preprocessed_commit: Option\u003c\u0026Com\u003cSC\u003e\u003e,\n        num_air_public_inputs: usize,\n    ) -\u003e Self {\n        // Allocate public input targets for the AIR public values.\n        //\n        // These targets come first in the overall public input ordering.\n        let air_public_targets = (0..num_air_public_inputs)\n            .map(|_| circuit.add_public_input())\n            .collect();\n\n        // Allocate targets for all proof components based on the reference proof.\n        let proof_targets = ProofTargets::new(circuit, proof);\n\n        // Allocate targets for the preprocessed commitment if it exists.\n        //\n        // The commitment wrapper knows how to mirror the structure as targets.\n        let preprocessed_commit = preprocessed_commit\n            .as_ref()\n            .map(|prep_comm| Comm::new(circuit, prep_comm));\n\n        Self {\n            air_public_targets,\n            proof_targets,\n            preprocessed_commit,\n        }\n    }\n\n    /// Packs concrete values into public inputs in the canonical order.\n    ///\n    /// This must be called in the execution phase, after challenges and actual\n    /// proof data are known.\n    ///\n    /// The output vector is consistent with the target allocation order used in `allocate`.\n    ///\n    /// # Parameters\n    /// - `air_public_values`: AIR public values in the base field.\n    /// - `proof`: Actual proof whose values are extracted.\n    /// - `preprocessed_commit`: Actual preprocessed commitment, if any.\n    /// - `challenges`: All Fiat–Shamir challenges.\n    /// - `num_queries`: Number of FRI queries (forwarded to the helper).\n    ///\n    /// # Returns\n    /// A public input vector ready to be passed to the verifier circuit.\n    pub fn pack_values(\n        \u0026self,\n        air_public_values: \u0026[Val\u003cSC\u003e],\n        proof: \u0026Proof\u003cSC\u003e,\n        preprocessed_commit: \u0026Option\u003cCom\u003cSC\u003e\u003e,\n        challenges: \u0026[SC::Challenge],\n        num_queries: usize,\n    ) -\u003e Vec\u003cSC::Challenge\u003e\n    where\n        Val\u003cSC\u003e: PrimeField64,\n        SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e + From\u003cVal\u003cSC\u003e\u003e,\n    {\n        // Extract extension-field values from the proof structure.\n        //\n        // The internal order is compatible with the way the proof targets were created.\n        let proof_values = ProofTargets::\u003cSC, Comm, OpeningProof\u003e::get_values(proof);\n\n        // Extract values from the preprocessed commitment, if it exists.\n        //\n        // If there is no preprocessed commitment, use an empty vector.\n        let preprocessed = preprocessed_commit\n            .as_ref()\n            .map_or_else(Vec::new, |prep_comm| Comm::get_values(prep_comm));\n\n        // Combine all components into a single public input vector.\n        StarkVerifierInputs {\n            air_public_values: air_public_values.to_vec(),\n            proof_values: proof_values.to_vec(),\n            preprocessed: preprocessed.to_vec(),\n            challenges: challenges.to_vec(),\n            num_queries,\n        }\n        .build()\n    }\n}\n\n/// Two-phase builder for batch (multi-instance) STARK verification circuits.\n///\n/// This is the batch analogue of the single-instance inputs builder.\n///\n/// It manages:\n/// - per-instance AIR public input targets,\n/// - batch proof targets,\n///\n/// and later packs concrete values into a flat public input vector.\npub struct BatchStarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e\nwhere\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n    OpeningProof:\n        Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    /// Per-instance public input targets.\n    ///\n    /// `air_public_targets[i]` is the list of public input targets for instance `i`.\n    pub air_public_targets: Vec\u003cVec\u003ccrate::Target\u003e\u003e,\n\n    /// Targets representing the batch proof structure.\n    ///\n    /// This includes all commitments and openings for all instances.\n    pub proof_targets: BatchProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    /// Allocated preprocessed commitment targets (if any).\n    pub preprocessed: PreprocessedVerifierDataTargets\u003cSC, Comm\u003e,\n}\n\nimpl\u003cSC, Comm, OpeningProof\u003e BatchStarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e\nwhere\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n    OpeningProof:\n        Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n{\n    /// Allocates public input targets for batch verification.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder into which targets are allocated.\n    /// - `proof`: Reference batch proof used only for its structure.\n    /// - `air_public_counts`: Number of public inputs per AIR instance.\n    ///\n    /// # Panics\n    /// Panics if `air_public_counts.len()` does not match the number of instances in the batch proof.\n    pub fn allocate(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        proof: \u0026BatchProof\u003cSC\u003e,\n        common_data: \u0026CommonData\u003cSC\u003e,\n        air_public_counts: \u0026[usize],\n    ) -\u003e Self {\n        // Ensure we have one public count per instance.\n        assert_eq!(\n            air_public_counts.len(),\n            proof.opened_values.instances.len(),\n            \"public input count must match number of instances\"\n        );\n\n        // For each instance, allocate `count` public input targets.\n        let air_public_targets = air_public_counts\n            .iter()\n            .map(|\u0026count| (0..count).map(|_| circuit.add_public_input()).collect())\n            .collect();\n\n        // Allocate targets for the batch proof structure, based on the reference proof.\n        let proof_targets = BatchProofTargets::new(circuit, proof);\n\n        let preprocessed = PreprocessedVerifierDataTargets::\u003cSC, Comm\u003e::new(circuit, common_data);\n\n        Self {\n            air_public_targets,\n            proof_targets,\n            preprocessed,\n        }\n    }\n\n    /// Packs concrete values into public inputs for batch verification.\n    ///\n    /// # Parameters\n    /// - `air_public_values`: AIR public values for each instance.\n    /// - `proof`: Actual batch proof.\n    /// - `challenges`: All shared challenges.\n    ///\n    /// # Returns\n    /// A flattened public input vector ready for the batch verifier circuit.\n    pub fn pack_values(\n        \u0026self,\n        air_public_values: \u0026[Vec\u003cVal\u003cSC\u003e\u003e],\n        proof: \u0026BatchProof\u003cSC\u003e,\n        common: \u0026CommonData\u003cSC\u003e,\n        challenges: \u0026[SC::Challenge],\n    ) -\u003e Vec\u003cSC::Challenge\u003e\n    where\n        Val\u003cSC\u003e: PrimeField64,\n        SC::Challenge: BasedVectorSpace\u003cVal\u003cSC\u003e\u003e + From\u003cVal\u003cSC\u003e\u003e,\n    {\n        // Extract extension-field values from the batch proof structure.\n        //\n        // The internal order matches the structure used when targets were created.\n        let common_data = PreprocessedVerifierDataTargets::\u003cSC, Comm\u003e::get_values(common);\n        let proof_values = BatchProofTargets::\u003cSC, Comm, OpeningProof\u003e::get_values(proof);\n\n        // Combine AIR public values, proof values, and challenges into a single public input vector.\n        construct_batch_stark_verifier_inputs(\n            air_public_values,\n            \u0026proof_values,\n            \u0026common_data,\n            challenges,\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_baby_bear::BabyBear;\n    use p3_field::PrimeCharacteristicRing;\n    use proptest::prelude::*;\n\n    use super::*;\n\n    #[test]\n    fn test_public_input_builder() {\n        let mut builder = PublicInputBuilder::\u003cBabyBear\u003e::new();\n\n        // Initially empty.\n        assert_eq!(builder.len(), 0);\n        assert!(builder.is_empty());\n\n        // Add various values.\n        builder\n            .add_proof_values([BabyBear::from_u32(1), BabyBear::from_u32(2)])\n            .add_challenge(BabyBear::from_u32(3))\n            .add_challenges([BabyBear::from_u32(4), BabyBear::from_u32(5)]);\n\n        // Verify accumulated count.\n        assert_eq!(builder.len(), 5);\n        assert!(!builder.is_empty());\n\n        // Build and verify contents.\n        let inputs = builder.build();\n        assert_eq!(inputs.len(), 5);\n        assert_eq!(inputs[0], BabyBear::from_u32(1));\n        assert_eq!(inputs[4], BabyBear::from_u32(5));\n    }\n\n    #[test]\n    fn test_query_index_bit_decomposition() {\n        let mut builder = PublicInputBuilder::\u003cBabyBear\u003e::new();\n\n        // Index 5 = 0b101 in binary.\n        builder.add_query_index(BabyBear::from_u32(5));\n\n        let inputs = builder.build();\n\n        // Should have exactly MAX_QUERY_INDEX_BITS bits.\n        assert_eq!(inputs.len(), MAX_QUERY_INDEX_BITS);\n\n        // Verify little-endian bit pattern: 101 means bits are [1, 0, 1, 0, 0, ...].\n        assert_eq!(inputs[0], BabyBear::ONE); // bit 0 (LSB)\n        assert_eq!(inputs[1], BabyBear::ZERO); // bit 1\n        assert_eq!(inputs[2], BabyBear::ONE); // bit 2\n\n        // Remaining bits should all be zero.\n        for \u0026bit in \u0026inputs[3..] {\n            assert_eq!(bit, BabyBear::ZERO);\n        }\n    }\n\n    /// Strategy for generating random BabyBear field elements.\n    fn field_element() -\u003e impl Strategy\u003cValue = BabyBear\u003e {\n        any::\u003cu32\u003e().prop_map(BabyBear::from_u32)\n    }\n\n    proptest! {\n        #[test]\n        fn build_preserves_order(vals in prop::collection::vec(field_element(), 1..20)) {\n            let mut builder = PublicInputBuilder::\u003cBabyBear\u003e::new();\n            builder.add_proof_values(vals.clone());\n\n            let result = builder.build();\n\n            // Length must match.\n            prop_assert_eq!(result.len(), vals.len());\n\n            // Each element must be in the same position.\n            for (i, \u0026val) in vals.iter().enumerate() {\n                prop_assert_eq!(result[i], val);\n            }\n        }\n\n        #[test]\n        fn chaining_preserves_order(\n            vals1 in prop::collection::vec(field_element(), 1..10),\n            challenge in field_element(),\n            vals2 in prop::collection::vec(field_element(), 1..10)\n        ) {\n            let mut builder = PublicInputBuilder::\u003cBabyBear\u003e::new();\n\n            // Chain multiple additions.\n            builder\n                .add_proof_values(vals1.clone())\n                .add_challenge(challenge)\n                .add_challenges(vals2.clone());\n\n            let result = builder.build();\n\n            // Verify total length.\n            let expected_len = vals1.len() + 1 + vals2.len();\n            prop_assert_eq!(result.len(), expected_len);\n\n            // Verify vals1 appears first, in order.\n            for (i, \u0026val) in vals1.iter().enumerate() {\n                prop_assert_eq!(result[i], val, \"vals1 order\");\n            }\n\n            // Verify challenge appears after vals1.\n            prop_assert_eq!(result[vals1.len()], challenge, \"challenge position\");\n\n            // Verify vals2 appears after challenge, in order.\n            for (i, \u0026val) in vals2.iter().enumerate() {\n                prop_assert_eq!(result[vals1.len() + 1 + i], val, \"vals2 order\");\n            }\n        }\n    }\n}\n","traces":[{"line":51,"address":[4135008],"length":1,"stats":{"Line":7}},{"line":52,"address":[],"length":0,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":13}},{"line":68,"address":[],"length":0,"stats":{"Line":13}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[4455057],"length":1,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[3936816],"length":1,"stats":{"Line":8}},{"line":98,"address":[4134904],"length":1,"stats":{"Line":8}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[4455168],"length":1,"stats":{"Line":1}},{"line":127,"address":[4455186],"length":1,"stats":{"Line":1}},{"line":130,"address":[4455231,4455206],"length":1,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[4455338],"length":1,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":138,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[2367616],"length":1,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[4455472],"length":1,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[4135072],"length":1,"stats":{"Line":7}},{"line":184,"address":[3937027],"length":1,"stats":{"Line":7}},{"line":255,"address":[2367141,2365568,2367457],"length":1,"stats":{"Line":1}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[2367008,2366221,2366403],"length":1,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[2367118,2366856,2366666],"length":1,"stats":{"Line":3}},{"line":285,"address":[2366949],"length":1,"stats":{"Line":1}},{"line":286,"address":[2367050],"length":1,"stats":{"Line":1}},{"line":291,"address":[],"length":0,"stats":{"Line":1}},{"line":349,"address":[3069792,3070411],"length":1,"stats":{"Line":3}},{"line":351,"address":[],"length":0,"stats":{"Line":3}},{"line":354,"address":[],"length":0,"stats":{"Line":8}},{"line":357,"address":[3070056],"length":1,"stats":{"Line":3}},{"line":360,"address":[3070113],"length":1,"stats":{"Line":3}},{"line":363,"address":[],"length":0,"stats":{"Line":3}},{"line":365,"address":[3014686],"length":1,"stats":{"Line":3}},{"line":382,"address":[3937056,3937972,3937944],"length":1,"stats":{"Line":2}},{"line":393,"address":[3053893],"length":1,"stats":{"Line":2}},{"line":396,"address":[3937298,3937378],"length":1,"stats":{"Line":4}},{"line":397,"address":[3054646,3054624,3054120,3054510],"length":1,"stats":{"Line":4}},{"line":401,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[3054338],"length":1,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":496,"address":[3071392,3071823,3071829],"length":1,"stats":{"Line":3}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[4136832,4137200,4137214],"length":1,"stats":{"Line":5}},{"line":510,"address":[],"length":0,"stats":{"Line":3}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":7}},{"line":542,"address":[4135904,4136677,4136683],"length":1,"stats":{"Line":3}},{"line":557,"address":[],"length":0,"stats":{"Line":3}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[3071376,3071360,3070825],"length":1,"stats":{"Line":7}},{"line":568,"address":[3070842],"length":1,"stats":{"Line":3}},{"line":569,"address":[3070903,3070979],"length":1,"stats":{"Line":6}},{"line":570,"address":[],"length":0,"stats":{"Line":6}},{"line":571,"address":[3071089],"length":1,"stats":{"Line":3}},{"line":629,"address":[3055754,3055152,3055748],"length":1,"stats":{"Line":2}},{"line":636,"address":[],"length":0,"stats":{"Line":2}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":6}},{"line":649,"address":[],"length":0,"stats":{"Line":2}},{"line":651,"address":[3938885],"length":1,"stats":{"Line":2}},{"line":669,"address":[3055132,3054688,3055126],"length":1,"stats":{"Line":2}},{"line":683,"address":[3938203],"length":1,"stats":{"Line":2}},{"line":684,"address":[3054864],"length":1,"stats":{"Line":2}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":2}},{"line":690,"address":[],"length":0,"stats":{"Line":2}},{"line":691,"address":[],"length":0,"stats":{"Line":0}}],"covered":72,"coverable":89},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","air.rs"],"content":"//! Trait for recursive AIR constraint evaluation.\n\nuse p3_air::Air;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::utils::{ColumnsTargets, symbolic_to_circuit};\nuse p3_field::Field;\nuse p3_uni_stark::{SymbolicAirBuilder, get_log_num_quotient_chunks, get_symbolic_constraints};\n\nuse crate::Target;\nuse crate::types::RecursiveLagrangeSelectors;\n\n/// Trait for evaluating AIR constraints within a recursive verification circuit.\n///\n/// This trait provides methods for computing constraint evaluations over circuit targets\n/// rather than concrete field values.\npub trait RecursiveAir\u003cF: Field\u003e {\n    /// Returns the number of columns in the AIR's execution trace.\n    ///\n    /// This corresponds to the width of the trace matrix.\n    fn width(\u0026self) -\u003e usize;\n\n    /// Evaluate all AIR constraints and fold them into a single target.\n    ///\n    /// This method:\n    /// 1. Retrieves all symbolic constraints from the AIR\n    /// 2. Converts them to circuit targets\n    /// 3. Folds them using powers of alpha: acc = acc * alpha + constraint\n    ///\n    /// # Parameters\n    /// - `builder`: Circuit builder for creating operations\n    /// - `sels`: Row selectors and vanishing inverse for constraint evaluation\n    /// - `alpha`: Challenge used for folding constraints\n    /// - `columns`: Trace columns (local, next) and public values\n    ///\n    /// # Returns\n    /// A single target representing the folded constraint evaluation\n    fn eval_folded_circuit(\n        \u0026self,\n        builder: \u0026mut CircuitBuilder\u003cF\u003e,\n        sels: \u0026RecursiveLagrangeSelectors,\n        alpha: \u0026Target,\n        columns: ColumnsTargets\u003c'_\u003e,\n    ) -\u003e Target;\n\n    /// Compute the log of the quotient polynomial degree.\n    ///\n    /// The quotient polynomial is formed by dividing the constraint polynomial\n    /// by the vanishing polynomial. Its degree depends on:\n    /// - The maximum constraint degree\n    /// - Number of public values\n    /// - Whether ZK randomization is used\n    ///\n    /// # Parameters\n    /// - `num_public_values`: Number of public input values\n    /// - `is_zk`: Whether ZK mode is enabled (0 or 1)\n    ///\n    /// # Returns\n    /// Log₂ of the number of quotient chunks\n    fn get_log_num_quotient_chunks(\n        \u0026self,\n        preprocessed_width: usize,\n        num_public_values: usize,\n        is_zk: usize,\n    ) -\u003e usize;\n}\n\nimpl\u003cF: Field, A\u003e RecursiveAir\u003cF\u003e for A\nwhere\n    A: Air\u003cSymbolicAirBuilder\u003cF\u003e\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        Self::width(self)\n    }\n\n    fn eval_folded_circuit(\n        \u0026self,\n        builder: \u0026mut CircuitBuilder\u003cF\u003e,\n        sels: \u0026RecursiveLagrangeSelectors,\n        alpha: \u0026Target,\n        columns: ColumnsTargets\u003c'_\u003e,\n    ) -\u003e Target {\n        builder.push_scope(\"eval_folded_circuit\");\n\n        let num_preprocessed = columns.local_prep_values.len();\n        // Get symbolic constraints from the AIR\n        let symbolic_constraints =\n            get_symbolic_constraints(self, num_preprocessed, columns.public_values.len());\n\n        // Fold all constraints: result = c₀ + α·c₁ + α²·c₂ + ...\n        let mut acc = builder.add_const(F::ZERO);\n        for s_c in symbolic_constraints {\n            let mul_prev = builder.mul(acc, *alpha);\n            let constraints = symbolic_to_circuit(sels.row_selectors, \u0026columns, \u0026s_c, builder);\n            acc = builder.add(mul_prev, constraints);\n        }\n        builder.pop_scope();\n        acc\n    }\n\n    fn get_log_num_quotient_chunks(\n        \u0026self,\n        preprocessed_width: usize,\n        num_public_values: usize,\n        is_zk: usize,\n    ) -\u003e usize {\n        get_log_num_quotient_chunks(self, preprocessed_width, num_public_values, is_zk)\n    }\n}\n","traces":[{"line":71,"address":[2491680],"length":1,"stats":{"Line":11}},{"line":72,"address":[4308725],"length":1,"stats":{"Line":11}},{"line":75,"address":[4308628,4307936],"length":1,"stats":{"Line":11}},{"line":82,"address":[1705949],"length":1,"stats":{"Line":11}},{"line":84,"address":[2173056],"length":1,"stats":{"Line":11}},{"line":86,"address":[1840716],"length":1,"stats":{"Line":11}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":22}},{"line":91,"address":[2491285,2491110],"length":1,"stats":{"Line":22}},{"line":92,"address":[2117466,2117589],"length":1,"stats":{"Line":18}},{"line":93,"address":[1869851],"length":1,"stats":{"Line":9}},{"line":94,"address":[2491552],"length":1,"stats":{"Line":9}},{"line":96,"address":[1841086],"length":1,"stats":{"Line":11}},{"line":97,"address":[3116950],"length":1,"stats":{"Line":11}},{"line":100,"address":[3117184],"length":1,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":5}}],"covered":15,"coverable":16},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","challenger.rs"],"content":"//! Trait for recursive Fiat-Shamir challenger operations within circuits.\n\nuse alloc::vec::Vec;\n\nuse p3_circuit::{CircuitBuilder, CircuitError};\nuse p3_field::{ExtensionField, Field, PrimeField64};\n\nuse crate::Target;\n\n/// Trait for performing Fiat-Shamir transformations within a circuit.\n///\n/// This trait provides an interface for implementing the Fiat-Shamir heuristic\n/// in recursive verification circuits. Implementations maintain an internal sponge\n/// state as circuit targets and provide methods to observe values and sample challenges.\n///\n/// # Design\n/// The trait follows the duplex sponge construction pattern:\n/// - **Observe**: Absorb field elements into the sponge state\n/// - **Sample**: Squeeze field elements from the sponge state as challenges\npub trait RecursiveChallenger\u003cF: Field\u003e {\n    /// Observe a single field element in the Fiat-Shamir transcript.\n    ///\n    /// Absorbs the value into the internal sponge state. The value will influence\n    /// all future challenge samples.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `value`: The target to observe\n    fn observe(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cF\u003e, value: Target);\n\n    /// Observe multiple field elements in the Fiat-Shamir transcript.\n    ///\n    /// This is equivalent to calling `observe()` for each element in order.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `values`: Slice of targets to observe\n    fn observe_slice(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cF\u003e, values: \u0026[Target]) {\n        for \u0026value in values {\n            self.observe(circuit, value);\n        }\n    }\n\n    /// Sample a challenge from the current sponge state.\n    ///\n    /// Squeezes a field element from the sponge. This challenge is deterministically\n    /// derived from all previously observed values.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    ///\n    /// # Returns\n    /// A target representing the sampled challenge\n    fn sample(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cF\u003e) -\u003e Target;\n\n    /// Sample multiple challenges from the current sponge state.\n    ///\n    /// This is equivalent to calling `sample()` multiple times.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `count`: Number of challenges to sample\n    ///\n    /// # Returns\n    /// Vector of sampled challenge targets\n    fn sample_vec(\u0026mut self, circuit: \u0026mut CircuitBuilder\u003cF\u003e, count: usize) -\u003e Vec\u003cTarget\u003e {\n        (0..count).map(|_| self.sample(circuit)).collect()\n    }\n\n    /// Sample a challenge and decompose it into bits.\n    ///\n    /// This is useful for sampling query indices in FRI or other bit-based challenges.\n    /// The challenge is first sampled as a field element, then decomposed into\n    /// `total_num_bits` bits, and the first `num_bits` are returned.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `total_num_bits`: Total number of bits to decompose (typically field bit width)\n    /// - `num_bits`: Number of bits to return (e.g., log of domain size)\n    ///\n    /// # Returns\n    /// Vector of the first `num_bits` bits as targets (each in {0, 1})\n    fn sample_public_bits\u003cBF: PrimeField64\u003e(\n        \u0026mut self,\n        circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n        total_num_bits: usize,\n        num_bits: usize,\n    ) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitError\u003e\n    where\n        F: ExtensionField\u003cBF\u003e,\n    {\n        let x = self.sample(circuit);\n\n        // Decompose to bits and verifies they reconstruct x\n        let bits = circuit.decompose_to_bits::\u003cBF\u003e(x, total_num_bits)?;\n\n        Ok(bits[..num_bits].to_vec())\n    }\n\n    /// Verify a proof-of-work witness.\n    ///\n    /// Observes the witness, samples a challenge, decomposes it to bits,\n    /// and verifies that the first `witness_bits` bits are all zero.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `witness_bits`: Number of leading bits that must be zero\n    /// - `witness`: The proof-of-work witness target\n    /// - `total_num_bits`: Total number of bits to decompose\n    fn check_witness\u003cBF: PrimeField64\u003e(\n        \u0026mut self,\n        circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n        witness_bits: usize,\n        witness: Target,\n        total_num_bits: usize,\n    ) -\u003e Result\u003c(), CircuitError\u003e\n    where\n        F: ExtensionField\u003cBF\u003e,\n    {\n        self.observe(circuit, witness);\n        let bits = self.sample_public_bits(circuit, total_num_bits, witness_bits)?;\n\n        // All bits must be zero for valid PoW\n        for bit in bits {\n            circuit.assert_zero(bit);\n        }\n\n        Ok(())\n    }\n\n    /// Clear the challenger state.\n    ///\n    /// Resets the internal sponge state. This is typically called to start\n    /// a fresh transcript for a new proof verification.\n    fn clear(\u0026mut self);\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":5}},{"line":39,"address":[3155755,3155740],"length":1,"stats":{"Line":10}},{"line":40,"address":[2757820],"length":1,"stats":{"Line":5}},{"line":66,"address":[4502832],"length":1,"stats":{"Line":1}},{"line":67,"address":[4422656,4422673],"length":1,"stats":{"Line":3}},{"line":83,"address":[3156281,3155840,3156275],"length":1,"stats":{"Line":5}},{"line":92,"address":[],"length":0,"stats":{"Line":5}},{"line":95,"address":[2757949],"length":1,"stats":{"Line":5}},{"line":97,"address":[2758197,2758114],"length":1,"stats":{"Line":10}},{"line":110,"address":[2902029,2902035,2901376],"length":1,"stats":{"Line":5}},{"line":120,"address":[],"length":0,"stats":{"Line":5}},{"line":121,"address":[2757129,2757245],"length":1,"stats":{"Line":10}},{"line":124,"address":[2901689,2901787,2901922],"length":1,"stats":{"Line":15}},{"line":125,"address":[],"length":0,"stats":{"Line":10}},{"line":128,"address":[],"length":0,"stats":{"Line":5}}],"covered":15,"coverable":15},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","mmcs.rs"],"content":"//! Traits for recursive MMCS operations.\n\nuse p3_commit::Mmcs;\nuse p3_field::{ExtensionField, Field};\n\nuse super::Recursive;\n\n/// Trait for the recursive version of an MMCS operating over the base field.\n///\n/// Associates a non-recursive MMCS with its recursive commitment and proof types.\n/// This is used for commitments to trace polynomials (which are over the base field).\npub trait RecursiveMmcs\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e {\n    /// The non-recursive MMCS type this corresponds to.\n    type Input: Mmcs\u003cF\u003e;\n\n    /// The recursive commitment type (targets representing the commitment).\n    ///\n    /// Must implement `Recursive` with `Input` being the commitment type from `Self::Input`.\n    type Commitment: Recursive\u003cEF, Input = \u003cSelf::Input as Mmcs\u003cF\u003e\u003e::Commitment\u003e;\n\n    /// The recursive proof type (targets representing the opening proof).\n    ///\n    /// Must implement `Recursive` with `Input` being the proof type from `Self::Input`.\n    type Proof: Recursive\u003cEF, Input = \u003cSelf::Input as Mmcs\u003cF\u003e\u003e::Proof\u003e;\n}\n\n/// Trait for the recursive version of an MMCS operating over the extension field.\n///\n/// Associates a non-recursive MMCS with its recursive commitment and proof types.\n/// This is used for commitments to quotient polynomials and FRI layers\n/// (which are over the extension field).\npub trait RecursiveExtensionMmcs\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e {\n    /// The non-recursive MMCS type this corresponds to.\n    type Input: Mmcs\u003cEF\u003e;\n\n    /// The recursive commitment type (targets representing the commitment).\n    ///\n    /// Must implement `Recursive` with `Input` being the commitment type from `Self::Input`.\n    type Commitment: Recursive\u003cEF, Input = \u003cSelf::Input as Mmcs\u003cEF\u003e\u003e::Commitment\u003e;\n\n    /// The recursive proof type (targets representing the opening proof).\n    ///\n    /// Must implement `Recursive` with `Input` being the proof type from `Self::Input`.\n    type Proof: Recursive\u003cEF, Input = \u003cSelf::Input as Mmcs\u003cEF\u003e\u003e::Proof\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","mod.rs"],"content":"//! Core trait definitions for recursive verification.\n\nmod air;\nmod challenger;\nmod mmcs;\nmod pcs;\nmod recursive;\n\npub use air::RecursiveAir;\npub use challenger::RecursiveChallenger;\npub use mmcs::{RecursiveExtensionMmcs, RecursiveMmcs};\npub use pcs::{ComsWithOpeningsTargets, RecursivePcs};\npub use recursive::Recursive;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","pcs.rs"],"content":"//! Trait for recursive Polynomial Commitment Scheme (PCS) operations.\n\nuse alloc::vec::Vec;\n\nuse p3_circuit::{CircuitBuilder, CircuitError};\nuse p3_uni_stark::StarkGenericConfig;\n\nuse super::Recursive;\nuse crate::Target;\nuse crate::types::{OpenedValuesTargets, ProofTargets, RecursiveLagrangeSelectors};\nuse crate::verifier::VerificationError;\n\n/// Type alias for commitments with their opening points.\n///\n/// Each entry is:\n/// - A commitment (Comm)\n/// - A list of (Domain, Vec\u003c(point, opened_values)\u003e) tuples\npub type ComsWithOpeningsTargets\u003cComm, Domain\u003e =\n    [(Comm, Vec\u003c(Domain, Vec\u003c(Target, Vec\u003cTarget\u003e)\u003e)\u003e)];\n\n/// Trait for recursive polynomial commitment scheme verification.\n///\n/// This trait provides the interface for verifying polynomial openings within\n/// a recursive circuit.\npub trait RecursivePcs\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain,\n\u003e\n{\n    /// PCS-specific verifier parameters (e.g., FRI parameters).\n    type VerifierParams;\n\n    /// Recursive proof type (may differ from OpeningProof for some schemes).\n    type RecursiveProof;\n\n    /// Generate PCS-specific challenges (e.g., FRI beta challenges, query indices).\n    ///\n    /// This method observes the opened values and opening proof, then samples\n    /// challenges needed for verification. For FRI, this includes:\n    /// - Beta challenges for each folding round\n    /// - Query indices for spot-checking\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `challenger`: Running Fiat-Shamir challenger state\n    /// - `proof_targets`: Proof structure with commitments and opening proof\n    /// - `opened_values`: All opened values at evaluation points\n    /// - `params`: PCS-specific verifier parameters\n    ///\n    /// # Returns\n    /// Vector of challenge targets (ordering depends on PCS scheme)\n    fn get_challenges_circuit\u003cconst RATE: usize\u003e(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenger: \u0026mut crate::challenger::CircuitChallenger\u003cRATE\u003e,\n        proof_targets: \u0026ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n        opened_values: \u0026OpenedValuesTargets\u003cSC\u003e,\n        params: \u0026Self::VerifierParams,\n    ) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitError\u003e;\n\n    /// Verify the polynomial commitment opening proof in-circuit.\n    ///\n    /// This method checks that the claimed opened values are consistent with\n    /// the commitments, using the opening proof and challenges.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `challenges`: PCS challenges (from `get_challenges_circuit`)\n    /// - `commitments_with_opening_points`: All commitments and their opening points\n    /// - `opening_proof`: The opening proof targets\n    /// - `params`: PCS-specific verifier parameters\n    ///\n    /// # Returns\n    /// `Ok(())` if verification constraints were successfully added,\n    /// `Err` if there was a structural error in the proof\n    fn verify_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenges: \u0026[Target],\n        commitments_with_opening_points: \u0026ComsWithOpeningsTargets\u003cComm, Domain\u003e,\n        opening_proof: \u0026OpeningProof,\n        params: \u0026Self::VerifierParams,\n    ) -\u003e Result\u003c(), VerificationError\u003e;\n\n    /// Compute Lagrange selector values at a point within the circuit.\n    ///\n    /// Evaluates row selector polynomials (is_first_row, is_last_row, is_transition)\n    /// and computes the vanishing polynomial inverse at the given point.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder for creating operations\n    /// - `domain`: The domain over which the polynomials are defined\n    /// - `point`: The evaluation point\n    ///\n    /// # Returns\n    /// Row selectors and vanishing inverse at the point\n    fn selectors_at_point_circuit(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        domain: \u0026Domain,\n        point: \u0026Target,\n    ) -\u003e RecursiveLagrangeSelectors;\n\n    /// Create a disjoint domain for the quotient polynomial.\n    ///\n    /// The quotient domain must be:\n    /// - Large enough to hold the quotient polynomial\n    /// - Disjoint from the trace domain (to avoid division by zero)\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The trace polynomial domain\n    /// - `degree`: The quotient polynomial degree\n    ///\n    /// # Returns\n    /// A disjoint domain of appropriate size\n    fn create_disjoint_domain(\u0026self, trace_domain: Domain, degree: usize) -\u003e Domain;\n\n    /// Split a domain into subdomains for quotient chunks.\n    ///\n    /// When the quotient polynomial is too large, it's split into chunks\n    /// committed separately. This method computes the subdomain for each chunk.\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The trace polynomial domain\n    /// - `degree`: The quotient polynomial degree\n    ///\n    /// # Returns\n    /// Vector of subdomains (one per chunk)\n    fn split_domains(\u0026self, trace_domain: \u0026Domain, degree: usize) -\u003e Vec\u003cDomain\u003e;\n\n    /// Return log₂ of the domain size.\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The domain\n    ///\n    /// # Returns\n    /// Log₂ of the domain size\n    fn log_size(\u0026self, trace_domain: \u0026Domain) -\u003e usize;\n\n    /// Return the domain size.\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The domain\n    ///\n    /// # Returns\n    /// The domain size (power of 2)\n    fn size(\u0026self, trace_domain: \u0026Domain) -\u003e usize {\n        1 \u003c\u003c self.log_size(trace_domain)\n    }\n\n    /// Return the first point in the domain.\n    ///\n    /// For a multiplicative coset, this is the coset offset.\n    ///\n    /// # Parameters\n    /// - `trace_domain`: The domain\n    ///\n    /// # Returns\n    /// The first domain point\n    fn first_point(\u0026self, trace_domain: \u0026Domain) -\u003e SC::Challenge;\n}\n","traces":[{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":3}}],"covered":2,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","traits","recursive.rs"],"content":"use alloc::vec;\nuse alloc::vec::Vec;\n\nuse p3_circuit::CircuitBuilder;\nuse p3_field::Field;\n\n/// Trait for converting a non-recursive type into its circuit representation.\n///\n/// Types implementing this trait can be used in recursive verification circuits.\n/// The trait handles allocation of circuit targets and extraction of field element values.\npub trait Recursive\u003cF: Field\u003e {\n    /// The non-recursive type associated with this recursive type.\n    type Input;\n\n    /// Creates a new instance of the recursive type by allocating targets in the circuit.\n    ///\n    /// This method should allocate all necessary public/private inputs and return\n    /// a structure containing the allocated targets.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder to allocate targets in\n    /// - `input`: The non-recursive input (used only for structure, not values)\n    fn new(circuit: \u0026mut CircuitBuilder\u003cF\u003e, input: \u0026Self::Input) -\u003e Self;\n\n    /// Extracts private field element values from the input.\n    ///\n    /// Values returned here will be used to populate private inputs during execution.\n    /// Default implementation returns an empty vector (no private inputs).\n    ///\n    /// # Parameters\n    /// - `input`: The non-recursive input to extract private values from\n    fn get_private_values(_input: \u0026Self::Input) -\u003e Vec\u003cF\u003e {\n        vec![]\n    }\n\n    /// Extracts public field element values from the input.\n    ///\n    /// Values returned here will be used to populate public inputs during execution.\n    /// The order must match the order in which targets were allocated in `new()`.\n    ///\n    /// # Parameters\n    /// - `input`: The non-recursive input to extract public values from\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cF\u003e;\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","types","challenges.rs"],"content":"//! Challenge target structures for STARK verification circuits.\n\nuse alloc::vec;\nuse alloc::vec::Vec;\n\nuse p3_circuit::CircuitBuilder;\nuse p3_field::PrimeCharacteristicRing;\nuse p3_uni_stark::StarkGenericConfig;\n\nuse crate::Target;\nuse crate::traits::{Recursive, RecursiveChallenger};\nuse crate::types::ProofTargets;\nuse crate::verifier::ObservableCommitment;\n\n/// Base STARK challenges (independent of PCS choice).\n#[derive(Debug, Clone)]\npub struct StarkChallenges {\n    /// Alpha: challenge for folding all constraint polynomials\n    pub alpha: Target,\n    /// Zeta: out-of-domain evaluation point\n    pub zeta: Target,\n    /// Zeta next: evaluation point for next row (zeta * g in the trace domain)\n    pub zeta_next: Target,\n}\n\nimpl StarkChallenges {\n    /// Allocate base STARK challenge targets using Fiat-Shamir transform.\n    ///\n    /// This method follows the standard STARK protocol ordering:\n    /// 1. Observe domain parameters\n    /// 2. Observe trace commitment\n    /// 3. Observe public values\n    /// 4. Sample alpha\n    /// 5. Observe quotient commitment\n    /// 6. Observe random commitment (if ZK)\n    /// 7. Sample zeta and zeta_next\n    ///\n    /// The challenger state is mutated and can be used for further PCS challenge sampling.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder\n    /// - `challenger`: Fiat-Shamir challenger (will be mutated)\n    /// - `proof_targets`: Proof structure with commitments\n    /// - `public_values`: AIR public input values\n    /// - `log_quotient_degree`: Log₂ of the quotient polynomial degree\n    ///\n    /// # Returns\n    /// The three base STARK challenges\n    pub fn allocate\u003cSC, Comm, OpeningProof\u003e(\n        circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n        challenger: \u0026mut impl RecursiveChallenger\u003cSC::Challenge\u003e,\n        proof_targets: \u0026ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n        public_values: \u0026[Target],\n        log_quotient_degree: usize,\n    ) -\u003e Self\n    where\n        SC: StarkGenericConfig,\n        SC::Challenge: PrimeCharacteristicRing,\n        Comm: Recursive\u003cSC::Challenge\u003e + ObservableCommitment,\n        OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    {\n        // Extract commitment targets from proof\n        let trace_comm_targets = proof_targets\n            .commitments_targets\n            .trace_targets\n            .to_observation_targets();\n        let quotient_comm_targets = proof_targets\n            .commitments_targets\n            .quotient_chunks_targets\n            .to_observation_targets();\n        let random_comm_targets = proof_targets\n            .commitments_targets\n            .random_commit\n            .as_ref()\n            .map(|c| c.to_observation_targets());\n\n        // Observe domain parameters\n        let degree_bits_target = circuit.alloc_const(\n            SC::Challenge::from_usize(proof_targets.degree_bits),\n            \"degree bits\",\n        );\n        let log_quotient_degree_target = circuit.alloc_const(\n            SC::Challenge::from_usize(log_quotient_degree),\n            \"log quotient degree\",\n        );\n        challenger.observe(circuit, degree_bits_target);\n        challenger.observe(circuit, log_quotient_degree_target);\n\n        // Observe trace commitment\n        challenger.observe_slice(circuit, \u0026trace_comm_targets);\n\n        // Observe public values\n        challenger.observe_slice(circuit, public_values);\n\n        // Sample alpha challenge\n        let alpha = challenger.sample(circuit);\n\n        // Observe quotient chunks commitment\n        challenger.observe_slice(circuit, \u0026quotient_comm_targets);\n\n        // Observe random commitment if in ZK mode\n        if let Some(random_comm) = random_comm_targets {\n            challenger.observe_slice(circuit, \u0026random_comm);\n        }\n\n        // Sample zeta and zeta_next challenges\n        let zeta = challenger.sample(circuit);\n        let zeta_next = challenger.sample(circuit);\n\n        Self {\n            alpha,\n            zeta,\n            zeta_next,\n        }\n    }\n\n    /// Convert to flat vector: [alpha, zeta, zeta_next]\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cTarget\u003e {\n        vec![self.alpha, self.zeta, self.zeta_next]\n    }\n\n    /// Get the alpha challenge (for constraint folding).\n    pub const fn alpha(\u0026self) -\u003e Target {\n        self.alpha\n    }\n\n    /// Get the zeta challenge (OOD evaluation point).\n    pub const fn zeta(\u0026self) -\u003e Target {\n        self.zeta\n    }\n\n    /// Get the zeta_next challenge (next row evaluation point).\n    pub const fn zeta_next(\u0026self) -\u003e Target {\n        self.zeta_next\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use p3_circuit::ExprId;\n\n    use super::*;\n\n    #[test]\n    fn test_stark_challenges_to_vec() {\n        let alpha = ExprId(1);\n        let zeta = ExprId(2);\n        let zeta_next = ExprId(3);\n        let challenges = StarkChallenges {\n            alpha,\n            zeta,\n            zeta_next,\n        };\n\n        let vec = challenges.to_vec();\n        assert_eq!(vec.len(), 3);\n        assert_eq!(vec[0], alpha);\n        assert_eq!(vec[1], zeta);\n        assert_eq!(vec[2], zeta_next);\n    }\n}\n","traces":[{"line":49,"address":[2802944,2803107,2802000],"length":1,"stats":{"Line":3}},{"line":63,"address":[4622867],"length":1,"stats":{"Line":3}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":3}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[2641888,2641050,2641872],"length":1,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[2641073],"length":1,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[2641224],"length":1,"stats":{"Line":3}},{"line":86,"address":[4623276],"length":1,"stats":{"Line":3}},{"line":87,"address":[2802561],"length":1,"stats":{"Line":3}},{"line":90,"address":[4623312],"length":1,"stats":{"Line":3}},{"line":93,"address":[2641392],"length":1,"stats":{"Line":3}},{"line":96,"address":[2641409],"length":1,"stats":{"Line":3}},{"line":99,"address":[2641439],"length":1,"stats":{"Line":3}},{"line":102,"address":[2802731],"length":1,"stats":{"Line":3}},{"line":103,"address":[2641568,2641670],"length":1,"stats":{"Line":0}},{"line":107,"address":[2802843,2802964],"length":1,"stats":{"Line":6}},{"line":108,"address":[2802971],"length":1,"stats":{"Line":3}},{"line":118,"address":[2976912],"length":1,"stats":{"Line":4}},{"line":119,"address":[3620647,3620797],"length":1,"stats":{"Line":4}},{"line":123,"address":[7696256],"length":1,"stats":{"Line":0}},{"line":124,"address":[2257589],"length":1,"stats":{"Line":0}},{"line":128,"address":[3620592],"length":1,"stats":{"Line":0}},{"line":129,"address":[3620597],"length":1,"stats":{"Line":0}},{"line":133,"address":[3620816],"length":1,"stats":{"Line":0}},{"line":134,"address":[3499557],"length":1,"stats":{"Line":0}}],"covered":20,"coverable":33},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","types","mod.rs"],"content":"//! Core type definitions for recursive verification.\n\nmod challenges;\nmod proof;\nmod selectors;\n\npub use challenges::StarkChallenges;\npub use proof::{\n    CommitmentTargets, OpenedValuesTargets, PreprocessedVerifierDataTargets, ProofTargets,\n};\npub use selectors::RecursiveLagrangeSelectors;\n\n/// Canonical circuit target type used across recursive components.\n///\n/// This is an alias representing a node in the circuit expression graph.\npub type Target = p3_circuit::ExprId;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","types","proof.rs"],"content":"//! Target structures for STARK proofs in recursive circuits.\n\nuse alloc::vec;\nuse alloc::vec::Vec;\nuse core::marker::PhantomData;\n\nuse p3_batch_stark::CommonData;\nuse p3_batch_stark::common::PreprocessedInstanceMeta;\nuse p3_circuit::CircuitBuilder;\nuse p3_commit::Pcs;\nuse p3_field::Field;\nuse p3_uni_stark::{Commitments, OpenedValues, Proof, StarkGenericConfig};\n\nuse crate::Target;\nuse crate::traits::{Recursive, RecursiveChallenger};\n\n/// Structure representing all the targets necessary for an input proof.\n///\n/// This contains the circuit representation of a STARK proof, with all\n/// commitments, opened values, and the opening proof as targets.\n#[derive(Clone)]\npub struct ProofTargets\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n\u003e {\n    /// Commitments to trace, quotient chunks, and optional random polynomial\n    pub commitments_targets: CommitmentTargets\u003cSC::Challenge, Comm\u003e,\n    /// Opened values at evaluation points (zeta, zeta_next)\n    pub opened_values_targets: OpenedValuesTargets\u003cSC\u003e,\n    /// PCS opening proof\n    pub opening_proof: OpeningProof,\n    /// Log₂ of the trace domain size\n    pub degree_bits: usize,\n}\n\n/// Target structure for STARK commitments.\n#[derive(Clone)]\npub struct CommitmentTargets\u003cF: Field, Comm: Recursive\u003cF\u003e\u003e {\n    /// Commitment to the trace polynomial\n    pub trace_targets: Comm,\n    /// Commitment to the quotient polynomial chunks\n    pub quotient_chunks_targets: Comm,\n    /// Optional commitment to random polynomial (ZK mode)\n    pub random_commit: Option\u003cComm\u003e,\n    pub _phantom: PhantomData\u003cF\u003e,\n}\n\n/// Target structure for opened polynomial values.\n#[derive(Clone)]\npub struct OpenedValuesTargets\u003cSC: StarkGenericConfig\u003e {\n    /// Trace values at point zeta\n    pub trace_local_targets: Vec\u003cTarget\u003e,\n    /// Trace values at point zeta * g (next row)\n    pub trace_next_targets: Vec\u003cTarget\u003e,\n    /// Optional preprocessed values at point zeta\n    pub preprocessed_local_targets: Option\u003cVec\u003cTarget\u003e\u003e,\n    /// Optional preprocessed values at point zeta * g (next row)\n    pub preprocessed_next_targets: Option\u003cVec\u003cTarget\u003e\u003e,\n    /// Quotient chunk values at zeta\n    pub quotient_chunks_targets: Vec\u003cVec\u003cTarget\u003e\u003e,\n    /// Optional random polynomial values (ZK mode)\n    pub random_targets: Option\u003cVec\u003cTarget\u003e\u003e,\n    pub _phantom: PhantomData\u003cSC\u003e,\n}\n\n/// Structure which holds the targets and metadata for existing global preprocessed data.\npub struct GlobalPreprocessedTargets\u003cComm\u003e {\n    /// Global commitment targets for all preprocessed columns, over all instances.\n    pub commitment: Comm,\n    /// Per-instance metadata for preprocessed traces.\n    pub instances: PreprocessedInstanceMetas,\n    /// Mapping from preprocessed matrix index to the corresponding instance index.\n    pub matrix_to_instance: Vec\u003cusize\u003e,\n}\n\n/// Structure which holds per-instance metadata for preprocessed traces\npub struct PreprocessedInstanceMetas {\n    /// Vector of optional per-instance metadata\n    pub instances: Vec\u003cOption\u003cPreprocessedInstanceMeta\u003e\u003e,\n}\n\n/// Structure which holds the optional targets and metadata necessary for handling preprocessed data in the verification circuit.\npub struct PreprocessedVerifierDataTargets\u003cSC, Comm\u003e {\n    /// If at least one of the instances uses preprocessed columns, holds the global preprocessed targets.\n    pub preprocessed: Option\u003cGlobalPreprocessedTargets\u003cComm\u003e\u003e,\n    pub _phantom: PhantomData\u003cSC\u003e,\n}\n\nimpl\u003cSC: StarkGenericConfig, Comm\u003e Recursive\u003cSC::Challenge\u003e\n    for PreprocessedVerifierDataTargets\u003cSC, Comm\u003e\nwhere\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e,\n{\n    type Input = CommonData\u003cSC\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let preprocessed = input\n            .preprocessed\n            .as_ref()\n            .map(|prep| GlobalPreprocessedTargets {\n                commitment: Comm::new(circuit, \u0026prep.commitment),\n                instances: PreprocessedInstanceMetas {\n                    instances: prep.instances.clone(),\n                },\n                matrix_to_instance: prep.matrix_to_instance.clone(),\n            });\n\n        Self {\n            preprocessed,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let mut values = vec![];\n        if let Some(prep) = \u0026input.preprocessed {\n            values.extend(Comm::get_values(\u0026prep.commitment));\n        }\n        values\n    }\n}\n\nimpl\u003cSC: StarkGenericConfig\u003e OpenedValuesTargets\u003cSC\u003e {\n    /// Observe all opened values in the Fiat-Shamir transcript.\n    ///\n    /// This method absorbs all opened values into the challenger state,\n    /// which is necessary before sampling PCS challenges.\n    ///\n    /// # Parameters\n    /// - `circuit`: Circuit builder\n    /// - `challenger`: Running challenger state\n    pub fn observe\u003cF: Field\u003e(\n        \u0026self,\n        circuit: \u0026mut CircuitBuilder\u003cF\u003e,\n        challenger: \u0026mut impl RecursiveChallenger\u003cF\u003e,\n    ) {\n        // Observe trace values at zeta and zeta_next\n        challenger.observe_slice(circuit, \u0026self.trace_local_targets);\n        challenger.observe_slice(circuit, \u0026self.trace_next_targets);\n\n        // Observe quotient chunk values\n        for chunk_values in \u0026self.quotient_chunks_targets {\n            challenger.observe_slice(circuit, chunk_values);\n        }\n\n        // Observe random values if in ZK mode\n        if let Some(random_vals) = \u0026self.random_targets {\n            challenger.observe_slice(circuit, random_vals);\n        }\n    }\n}\n\nimpl\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n\u003e Recursive\u003cSC::Challenge\u003e for ProofTargets\u003cSC, Comm, OpeningProof\u003e\n{\n    type Input = Proof\u003cSC\u003e;\n\n    /// Allocates the necessary circuit targets for storing the proof's public data.\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let commitments_targets = CommitmentTargets::new(circuit, \u0026input.commitments);\n        let opened_values_targets = OpenedValuesTargets::new(circuit, \u0026input.opened_values);\n        let opening_proof = OpeningProof::new(circuit, \u0026input.opening_proof);\n\n        Self {\n            commitments_targets,\n            opened_values_targets,\n            opening_proof,\n            degree_bits: input.degree_bits,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let Proof {\n            commitments,\n            opened_values,\n            opening_proof,\n            degree_bits: _,\n        } = input;\n\n        CommitmentTargets::\u003cSC::Challenge, Comm\u003e::get_values(commitments)\n            .into_iter()\n            .chain(OpenedValuesTargets::\u003cSC\u003e::get_values(opened_values))\n            .chain(OpeningProof::get_values(opening_proof))\n            .collect()\n    }\n}\n\nimpl\u003cF: Field, Comm\u003e Recursive\u003cF\u003e for CommitmentTargets\u003cF, Comm\u003e\nwhere\n    Comm: Recursive\u003cF\u003e,\n{\n    type Input = Commitments\u003cComm::Input\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cF\u003e, input: \u0026Self::Input) -\u003e Self {\n        let trace_targets = Comm::new(circuit, \u0026input.trace);\n        let quotient_chunks_targets = Comm::new(circuit, \u0026input.quotient_chunks);\n        let random_commit = input\n            .random\n            .as_ref()\n            .map(|random| Comm::new(circuit, random));\n\n        Self {\n            trace_targets,\n            quotient_chunks_targets,\n            random_commit,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cF\u003e {\n        let Commitments {\n            trace,\n            quotient_chunks,\n            random,\n        } = input;\n\n        let mut values = vec![];\n        values.extend(Comm::get_values(trace));\n        values.extend(Comm::get_values(quotient_chunks));\n        if let Some(random) = random {\n            values.extend(Comm::get_values(random));\n        }\n        values\n    }\n}\n\nimpl\u003cSC: StarkGenericConfig\u003e Recursive\u003cSC::Challenge\u003e for OpenedValuesTargets\u003cSC\u003e {\n    type Input = OpenedValues\u003cSC::Challenge\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let trace_local_len = input.trace_local.len();\n        let trace_local_targets =\n            circuit.alloc_public_inputs(trace_local_len, \"trace local values\");\n\n        let trace_next_len = input.trace_next.len();\n        let trace_next_targets = circuit.alloc_public_inputs(trace_next_len, \"trace next values\");\n\n        let preprocessed_local_targets = input\n            .preprocessed_local\n            .as_ref()\n            .map(|prep| circuit.alloc_public_inputs(prep.len(), \"local preprocessed values\"));\n        let preprocessed_next_targets = input\n            .preprocessed_next\n            .as_ref()\n            .map(|prep| circuit.alloc_public_inputs(prep.len(), \"local preprocessed values\"));\n\n        let quotient_chunks_len = input.quotient_chunks.len();\n        let mut quotient_chunks_targets = Vec::with_capacity(quotient_chunks_len);\n        for quotient_chunk in input.quotient_chunks.iter() {\n            let quotient_chunks_cols_len = quotient_chunk.len();\n            let quotient_col =\n                circuit.alloc_public_inputs(quotient_chunks_cols_len, \"quotient chunk columns\");\n            quotient_chunks_targets.push(quotient_col);\n        }\n\n        let random_targets = input\n            .random\n            .as_ref()\n            .map(|random| circuit.alloc_public_inputs(random.len(), \"random values (ZK mode)\"));\n\n        Self {\n            trace_local_targets,\n            trace_next_targets,\n            preprocessed_local_targets,\n            preprocessed_next_targets,\n            quotient_chunks_targets,\n            random_targets,\n            _phantom: PhantomData,\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let OpenedValues {\n            trace_local,\n            trace_next,\n            preprocessed_local,\n            preprocessed_next,\n            quotient_chunks,\n            random,\n        } = input;\n\n        let mut values = vec![];\n        values.extend(trace_local);\n        values.extend(trace_next);\n        if let Some(preprocessed_local) = preprocessed_local {\n            values.extend(preprocessed_local);\n        }\n        if let Some(preprocessed_next) = preprocessed_next {\n            values.extend(preprocessed_next);\n        }\n        for chunk in quotient_chunks {\n            values.extend(chunk);\n        }\n        if let Some(random) = random {\n            values.extend(random);\n        }\n\n        values\n    }\n}\n","traces":[{"line":100,"address":[2853120],"length":1,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[4329094],"length":1,"stats":{"Line":2}},{"line":106,"address":[2853345],"length":1,"stats":{"Line":2}},{"line":107,"address":[2853289],"length":1,"stats":{"Line":2}},{"line":109,"address":[2853365],"length":1,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[4328774],"length":1,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[2853017],"length":1,"stats":{"Line":2}},{"line":136,"address":[2833888],"length":1,"stats":{"Line":5}},{"line":142,"address":[4219973],"length":1,"stats":{"Line":5}},{"line":143,"address":[],"length":0,"stats":{"Line":5}},{"line":146,"address":[3555560,3555541],"length":1,"stats":{"Line":10}},{"line":147,"address":[2834081],"length":1,"stats":{"Line":5}},{"line":151,"address":[2618649],"length":1,"stats":{"Line":5}},{"line":152,"address":[2618704],"length":1,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[3563042],"length":1,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[2626064,2626444,2626472],"length":1,"stats":{"Line":3}},{"line":180,"address":[2626097],"length":1,"stats":{"Line":3}},{"line":181,"address":[2492641],"length":1,"stats":{"Line":3}},{"line":182,"address":[3562547],"length":1,"stats":{"Line":3}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":9}},{"line":189,"address":[2492743,2492750,2492823,2493014],"length":1,"stats":{"Line":6}},{"line":190,"address":[3562754,3562881,3562817,3562747],"length":1,"stats":{"Line":6}},{"line":201,"address":[2486579,2486496],"length":1,"stats":{"Line":3}},{"line":202,"address":[2619227],"length":1,"stats":{"Line":3}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[2486912,2486670,2486933],"length":1,"stats":{"Line":3}},{"line":217,"address":[4221212,4220912,4221218],"length":1,"stats":{"Line":5}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":5}},{"line":220,"address":[2837874],"length":1,"stats":{"Line":5}},{"line":221,"address":[2618934],"length":1,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[2618947],"length":1,"stats":{"Line":5}},{"line":225,"address":[4221010,4221064],"length":1,"stats":{"Line":10}},{"line":226,"address":[2837993],"length":1,"stats":{"Line":5}},{"line":227,"address":[2838022],"length":1,"stats":{"Line":5}},{"line":228,"address":[2838054,2838115],"length":1,"stats":{"Line":0}},{"line":230,"address":[2619111],"length":1,"stats":{"Line":5}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":238,"address":[3560899],"length":1,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[2624535,2624611],"length":1,"stats":{"Line":6}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":245,"address":[2624652],"length":1,"stats":{"Line":3}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[2492400,2492442,2491258],"length":1,"stats":{"Line":7}},{"line":249,"address":[],"length":0,"stats":{"Line":3}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[2625872,2624813,2625914],"length":1,"stats":{"Line":7}},{"line":254,"address":[3561241,3561299],"length":1,"stats":{"Line":6}},{"line":255,"address":[],"length":0,"stats":{"Line":3}},{"line":256,"address":[2624983,2624911],"length":1,"stats":{"Line":6}},{"line":257,"address":[3562097,3561549],"length":1,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[2625733],"length":1,"stats":{"Line":3}},{"line":263,"address":[2491681],"length":1,"stats":{"Line":3}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[2492346,2492304,2491713],"length":1,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[3560254],"length":1,"stats":{"Line":3}},{"line":282,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[2490414],"length":1,"stats":{"Line":3}},{"line":285,"address":[3560322],"length":1,"stats":{"Line":3}},{"line":286,"address":[3560342],"length":1,"stats":{"Line":3}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[3560359],"length":1,"stats":{"Line":3}},{"line":290,"address":[],"length":0,"stats":{"Line":3}},{"line":291,"address":[3560446],"length":1,"stats":{"Line":3}},{"line":292,"address":[],"length":0,"stats":{"Line":3}},{"line":293,"address":[2490658,2490612],"length":1,"stats":{"Line":4}},{"line":295,"address":[2490665,2490624],"length":1,"stats":{"Line":5}},{"line":296,"address":[],"length":0,"stats":{"Line":4}},{"line":298,"address":[],"length":0,"stats":{"Line":6}},{"line":299,"address":[2490812,2490927],"length":1,"stats":{"Line":6}},{"line":301,"address":[3560720],"length":1,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":3}}],"covered":78,"coverable":96},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","types","selectors.rs"],"content":"//! Lagrange selector structures for constraint evaluation.\n\nuse p3_circuit::utils::RowSelectorsTargets;\n\nuse crate::Target;\n\n/// Circuit version of Lagrange selectors for AIR constraint evaluation.\n#[derive(Clone, Debug)]\npub struct RecursiveLagrangeSelectors {\n    /// Row selector targets (is_first_row, is_last_row, is_transition)\n    pub row_selectors: RowSelectorsTargets,\n    /// Inverse of the vanishing polynomial: 1 / Z_H(point)\n    ///\n    /// The vanishing polynomial Z_H(x) = x^n - 1 for a domain of size n.\n    /// This inverse is used to compute the quotient polynomial evaluation.\n    pub inv_vanishing: Target,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","batch_stark.rs"],"content":"use alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\nuse core::marker::PhantomData;\n\nuse p3_air::{Air as P3Air, BaseAir as P3BaseAir, PairBuilder};\nuse p3_batch_stark::{BatchProof, CommonData};\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::utils::ColumnsTargets;\nuse p3_circuit_prover::air::{AddAir, ConstAir, MulAir, PublicAir, WitnessAir};\nuse p3_circuit_prover::batch_stark_prover::{PrimitiveTable, RowCounts};\nuse p3_commit::{Pcs, PolynomialSpace};\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_uni_stark::StarkGenericConfig;\n\nuse super::{ObservableCommitment, VerificationError, recompose_quotient_from_chunks_circuit};\nuse crate::challenger::CircuitChallenger;\nuse crate::traits::{Recursive, RecursiveAir, RecursiveChallenger, RecursivePcs};\nuse crate::types::{\n    CommitmentTargets, OpenedValuesTargets, PreprocessedVerifierDataTargets, ProofTargets,\n};\nuse crate::{BatchStarkVerifierInputsBuilder, Target};\n\n/// Type alias for PCS verifier parameters.\npub type PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e =\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as RecursivePcs\u003c\n        SC,\n        InputProof,\n        OpeningProof,\n        Comm,\n        \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n            \u003cSC as StarkGenericConfig\u003e::Challenge,\n            \u003cSC as StarkGenericConfig\u003e::Challenger,\n        \u003e\u003e::Domain,\n    \u003e\u003e::VerifierParams;\n\n// TODO(Robin): Remove with dynamic dispatch\n/// Wrapper enum for heterogeneous circuit table AIRs used by circuit-prover tables.\npub enum CircuitTablesAir\u003cF: Field, const D: usize\u003e {\n    Witness(WitnessAir\u003cF, D\u003e),\n    Const(ConstAir\u003cF, D\u003e),\n    Public(PublicAir\u003cF, D\u003e),\n    Add(AddAir\u003cF, D\u003e),\n    Mul(MulAir\u003cF, D\u003e),\n}\n\nimpl\u003cF: Field, const D: usize\u003e P3BaseAir\u003cF\u003e for CircuitTablesAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::Witness(a) =\u003e P3BaseAir::width(a),\n            Self::Const(a) =\u003e P3BaseAir::width(a),\n            Self::Public(a) =\u003e P3BaseAir::width(a),\n            Self::Add(a) =\u003e P3BaseAir::width(a),\n            Self::Mul(a) =\u003e P3BaseAir::width(a),\n        }\n    }\n}\n\nimpl\u003cAB, const D: usize\u003e P3Air\u003cAB\u003e for CircuitTablesAir\u003cAB::F, D\u003e\nwhere\n    AB: PairBuilder,\n    AB::F: Field,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        match self {\n            Self::Witness(a) =\u003e a.eval(builder),\n            Self::Const(a) =\u003e a.eval(builder),\n            Self::Public(a) =\u003e a.eval(builder),\n            Self::Add(a) =\u003e a.eval(builder),\n            Self::Mul(a) =\u003e a.eval(builder),\n        }\n    }\n}\n\n/// Build and attach a recursive verifier circuit for a circuit-prover [`BatchStarkProof`].\n///\n/// This reconstructs the circuit table AIRs from the proof metadata (rows + packing) so callers\n/// don't need to pass `circuit_airs` explicitly. Returns the allocated input builder to pack\n/// public inputs afterwards.\npub fn verify_p3_recursion_proof_circuit\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e + Clone\n        + ObservableCommitment,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n    const RATE: usize,\n    const TRACE_D: usize,\n\u003e(\n    config: \u0026SC,\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    proof: \u0026p3_circuit_prover::batch_stark_prover::BatchStarkProof\u003cSC\u003e,\n    pcs_params: \u0026PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e,\n    common_data: \u0026CommonData\u003cSC\u003e,\n) -\u003e Result\u003cBatchStarkVerifierInputsBuilder\u003cSC, Comm, OpeningProof\u003e, VerificationError\u003e\nwhere\n    \u003cSC as StarkGenericConfig\u003e::Pcs: RecursivePcs\u003c\n            SC,\n            InputProof,\n            OpeningProof,\n            Comm,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain: Clone,\n{\n    assert_eq!(proof.ext_degree, TRACE_D, \"trace extension degree mismatch\");\n    let rows: RowCounts = proof.rows;\n    let packing = proof.table_packing;\n    let witness_lanes = packing.witness_lanes();\n    let add_lanes = packing.add_lanes();\n    let mul_lanes = packing.mul_lanes();\n\n    let circuit_airs = vec![\n        CircuitTablesAir::Witness(WitnessAir::\u003cSC::Challenge, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Witness],\n            witness_lanes,\n        )),\n        CircuitTablesAir::Const(ConstAir::\u003cSC::Challenge, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Const],\n        )),\n        CircuitTablesAir::Public(PublicAir::\u003cSC::Challenge, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Public],\n        )),\n        CircuitTablesAir::Add(AddAir::\u003cSC::Challenge, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Add],\n            add_lanes,\n        )),\n        CircuitTablesAir::Mul(MulAir::\u003cSC::Challenge, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Mul],\n            mul_lanes,\n        )),\n    ];\n\n    // TODO: public values are empty for all circuit tables for now.\n    let air_public_counts = vec![0usize; proof.proof.opened_values.instances.len()];\n    let verifier_inputs = BatchStarkVerifierInputsBuilder::\u003cSC, Comm, OpeningProof\u003e::allocate(\n        circuit,\n        \u0026proof.proof,\n        common_data,\n        \u0026air_public_counts,\n    );\n\n    let preprocessed = \u0026verifier_inputs.preprocessed;\n\n    verify_batch_circuit::\u003c\n        CircuitTablesAir\u003cSC::Challenge, TRACE_D\u003e,\n        SC,\n        Comm,\n        InputProof,\n        OpeningProof,\n        RATE,\n    \u003e(\n        config,\n        \u0026circuit_airs,\n        circuit,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        pcs_params,\n        preprocessed,\n    )?;\n\n    Ok(verifier_inputs)\n}\n\n/// Opened values for a single STARK instance within the batch-proof.\n#[derive(Clone)]\npub struct InstanceOpenedValuesTargets\u003cSC: StarkGenericConfig\u003e {\n    pub trace_local: Vec\u003cTarget\u003e,\n    pub trace_next: Vec\u003cTarget\u003e,\n    pub preprocessed_local: Option\u003cVec\u003cTarget\u003e\u003e,\n    pub preprocessed_next: Option\u003cVec\u003cTarget\u003e\u003e,\n    pub quotient_chunks: Vec\u003cVec\u003cTarget\u003e\u003e,\n    _phantom: PhantomData\u003cSC\u003e,\n}\n\n/// Recursive targets for a batch-STARK proof.\n///\n/// The `flattened` field stores the aggregated commitments, opened values, and opening proof in the\n/// same layout expected by single-instance PCS logic. The `instances` field retains per-instance\n/// opened values so that AIR constraints can be enforced individually.\npub struct BatchProofTargets\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n\u003e {\n    pub flattened: ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    pub instances: Vec\u003cInstanceOpenedValuesTargets\u003cSC\u003e\u003e,\n    pub degree_bits: Vec\u003cusize\u003e,\n}\n\nimpl\u003c\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge, Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Proof\u003e,\n\u003e Recursive\u003cSC::Challenge\u003e for BatchProofTargets\u003cSC, Comm, OpeningProof\u003e\n{\n    type Input = BatchProof\u003cSC\u003e;\n\n    fn new(circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e, input: \u0026Self::Input) -\u003e Self {\n        let trace_targets = Comm::new(circuit, \u0026input.commitments.main);\n        let quotient_chunks_targets = Comm::new(circuit, \u0026input.commitments.quotient_chunks);\n\n        // Flattened opened values are ordered as:\n        // 1. All `trace_local` rows per instance (instance 0 .. N)\n        // 2. All `trace_next` rows per instance (instance 0 .. N)\n        // 3. Quotient chunks for each instance in commit order\n        let mut aggregated_trace_local = Vec::new();\n        let mut aggregated_trace_next = Vec::new();\n        let mut aggregated_prep_local = Vec::new();\n        let mut aggregated_prep_next = Vec::new();\n        let mut aggregated_quotient_chunks = Vec::new();\n\n        let mut instances = Vec::with_capacity(input.opened_values.instances.len());\n\n        for inst in \u0026input.opened_values.instances {\n            let trace_local =\n                circuit.alloc_public_inputs(inst.trace_local.len(), \"trace local values\");\n            aggregated_trace_local.extend(trace_local.iter().copied());\n\n            let trace_next =\n                circuit.alloc_public_inputs(inst.trace_next.len(), \"trace next values\");\n            aggregated_trace_next.extend(trace_next.iter().copied());\n\n            let preprocessed_local = inst.preprocessed_local.as_ref().map(|prep_local_vals| {\n                let prep_local =\n                    circuit.alloc_public_inputs(prep_local_vals.len(), \"preprocessed local values\");\n                aggregated_prep_local.extend(prep_local.iter().copied());\n\n                prep_local\n            });\n            let preprocessed_next = inst.preprocessed_next.as_ref().map(|prep_next_vals| {\n                let prep_next =\n                    circuit.alloc_public_inputs(prep_next_vals.len(), \"preprocessed next values\");\n                aggregated_prep_next.extend(prep_next.iter().copied());\n\n                prep_next\n            });\n\n            let mut quotient_chunks = Vec::with_capacity(inst.quotient_chunks.len());\n            for chunk in \u0026inst.quotient_chunks {\n                let chunk_targets =\n                    circuit.alloc_public_inputs(chunk.len(), \"quotient chunk values\");\n                aggregated_quotient_chunks.push(chunk_targets.clone());\n                quotient_chunks.push(chunk_targets);\n            }\n\n            instances.push(InstanceOpenedValuesTargets {\n                trace_local,\n                trace_next,\n                preprocessed_local,\n                preprocessed_next,\n                quotient_chunks,\n                _phantom: PhantomData,\n            });\n        }\n\n        let opened_values_targets = OpenedValuesTargets {\n            trace_local_targets: aggregated_trace_local,\n            trace_next_targets: aggregated_trace_next,\n            preprocessed_local_targets: if aggregated_prep_local.is_empty() {\n                None\n            } else {\n                Some(aggregated_prep_local)\n            },\n            preprocessed_next_targets: if aggregated_prep_next.is_empty() {\n                None\n            } else {\n                Some(aggregated_prep_next)\n            },\n            quotient_chunks_targets: aggregated_quotient_chunks,\n            random_targets: None,\n            _phantom: PhantomData,\n        };\n\n        let flattened = ProofTargets {\n            commitments_targets: CommitmentTargets {\n                trace_targets,\n                quotient_chunks_targets,\n                random_commit: None,\n                _phantom: PhantomData,\n            },\n            opened_values_targets,\n            opening_proof: OpeningProof::new(circuit, \u0026input.opening_proof),\n            // Placeholder value: degree_bits is not used from the flattened ProofTargets in batch verification.\n            // The actual per-instance degree bits are stored in BatchProofTargets.degree_bits (Vec\u003cusize\u003e)\n            // and used directly by the verifier. The flattened structure is only used for PCS verification\n            // which doesn't access this field.\n            degree_bits: 0,\n        };\n\n        Self {\n            flattened,\n            instances,\n            degree_bits: input.degree_bits.clone(),\n        }\n    }\n\n    fn get_values(input: \u0026Self::Input) -\u003e Vec\u003cSC::Challenge\u003e {\n        let commitments = p3_uni_stark::Commitments {\n            trace: input.commitments.main.clone(),\n            quotient_chunks: input.commitments.quotient_chunks.clone(),\n            random: None,\n        };\n\n        let mut values = CommitmentTargets::\u003cSC::Challenge, Comm\u003e::get_values(\u0026commitments);\n\n        // Opened values, preserving per-instance allocation order.\n        for inst in \u0026input.opened_values.instances {\n            values.extend(inst.trace_local.iter().copied());\n            values.extend(inst.trace_next.iter().copied());\n            if let Some(prep_local) = \u0026inst.preprocessed_local {\n                values.extend(prep_local.iter().copied());\n            }\n            if let Some(prep_next) = \u0026inst.preprocessed_next {\n                values.extend(prep_next.iter().copied());\n            }\n            for chunk in \u0026inst.quotient_chunks {\n                values.extend(chunk.iter().copied());\n            }\n        }\n\n        values.extend(OpeningProof::get_values(\u0026input.opening_proof));\n        values\n    }\n}\n\n/// Verify a batch-STARK proof inside a recursive circuit.\npub fn verify_batch_circuit\u003c\n    A,\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e + Clone\n        + ObservableCommitment,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    const RATE: usize,\n\u003e(\n    config: \u0026SC,\n    airs: \u0026[A],\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    proof_targets: \u0026BatchProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    public_values: \u0026[Vec\u003cTarget\u003e],\n    pcs_params: \u0026PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e,\n    common: \u0026PreprocessedVerifierDataTargets\u003cSC, Comm\u003e,\n) -\u003e Result\u003c(), VerificationError\u003e\nwhere\n    A: RecursiveAir\u003cSC::Challenge\u003e,\n    \u003cSC as StarkGenericConfig\u003e::Pcs: RecursivePcs\u003c\n            SC,\n            InputProof,\n            OpeningProof,\n            Comm,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain: Clone,\n{\n    //TODO: Add support for ZK mode.\n    debug_assert_eq!(config.is_zk(), 0, \"batch recursion assumes non-ZK\");\n    if airs.is_empty() {\n        return Err(VerificationError::InvalidProofShape(\n            \"batch-STARK verification requires at least one instance\".to_string(),\n        ));\n    }\n\n    if airs.len() != proof_targets.instances.len()\n        || airs.len() != public_values.len()\n        || airs.len() != proof_targets.degree_bits.len()\n    {\n        return Err(VerificationError::InvalidProofShape(\n            \"Mismatch between number of AIRs, instances, public values, or degree bits\".to_string(),\n        ));\n    }\n\n    let pcs = config.pcs();\n\n    let flattened = \u0026proof_targets.flattened;\n    let commitments_targets = \u0026flattened.commitments_targets;\n    let opened_values_targets = \u0026flattened.opened_values_targets;\n    let opening_proof = \u0026flattened.opening_proof;\n    let instances = \u0026proof_targets.instances;\n    let degree_bits = \u0026proof_targets.degree_bits;\n\n    if commitments_targets.random_commit.is_some() {\n        return Err(VerificationError::InvalidProofShape(\n            \"Batch-STARK verifier does not support random commitments\".to_string(),\n        ));\n    }\n\n    let n_instances = airs.len();\n\n    // Pre-compute per-instance quotient degrees and preprocessed widths, and validate proof shape.\n    let mut preprocessed_widths = Vec::with_capacity(airs.len());\n    let mut log_quotient_degrees = Vec::with_capacity(n_instances);\n    let mut quotient_degrees = Vec::with_capacity(n_instances);\n    for (i, ((air, instance), public_vals)) in airs\n        .iter()\n        .zip(instances.iter())\n        .zip(public_values)\n        .enumerate()\n    {\n        let pre_w = common\n            .preprocessed\n            .as_ref()\n            .and_then(|g| g.instances.instances[i].as_ref().map(|m| m.width))\n            .unwrap_or(0);\n        preprocessed_widths.push(pre_w);\n\n        let local_prep_len = instance.preprocessed_local.as_ref().map_or(0, |v| v.len());\n        let next_prep_len = instance.preprocessed_next.as_ref().map_or(0, |v| v.len());\n        if local_prep_len != pre_w || next_prep_len != pre_w {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"Instance has incorrect preprocessed width: expected {pre_w}, got {local_prep_len} / {next_prep_len}\"\n            )));\n        }\n        let air_width = A::width(air);\n        if instance.trace_local.len() != air_width || instance.trace_next.len() != air_width {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"Instance has incorrect trace width: expected {}, got {} / {}\",\n                air_width,\n                instance.trace_local.len(),\n                instance.trace_next.len()\n            )));\n        }\n\n        let log_qd = A::get_log_num_quotient_chunks(air, pre_w, public_vals.len(), config.is_zk());\n        let quotient_degree = 1 \u003c\u003c (log_qd + config.is_zk());\n\n        if instance.quotient_chunks.len() != quotient_degree {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"Instance quotient chunk count mismatch: expected {}, got {}\",\n                quotient_degree,\n                instance.quotient_chunks.len()\n            )));\n        }\n\n        if instance\n            .quotient_chunks\n            .iter()\n            .any(|chunk| chunk.len() != SC::Challenge::DIMENSION)\n        {\n            return Err(VerificationError::InvalidProofShape(format!(\n                \"Invalid quotient chunk length: expected {}\",\n                SC::Challenge::DIMENSION\n            )));\n        }\n\n        log_quotient_degrees.push(log_qd);\n        quotient_degrees.push(quotient_degree);\n    }\n\n    // Challenger initialisation mirrors the native batch-STARK verifier transcript.\n    let mut challenger = CircuitChallenger::\u003cRATE\u003e::new();\n    let inst_count_target = circuit.alloc_const(\n        SC::Challenge::from_usize(n_instances),\n        \"number of instances\",\n    );\n    challenger.observe(circuit, inst_count_target);\n\n    for ((\u0026ext_db, quotient_degree), air) in degree_bits\n        .iter()\n        .zip(quotient_degrees.iter())\n        .zip(airs.iter())\n    {\n        let base_db = ext_db.checked_sub(config.is_zk()).ok_or_else(|| {\n            VerificationError::InvalidProofShape(\n                \"Extended degree bits smaller than ZK adjustment\".to_string(),\n            )\n        })?;\n        let base_db_target =\n            circuit.alloc_const(SC::Challenge::from_usize(base_db), \"base degree bits\");\n        let ext_db_target =\n            circuit.alloc_const(SC::Challenge::from_usize(ext_db), \"extended degree bits\");\n        let width_target =\n            circuit.alloc_const(SC::Challenge::from_usize(A::width(air)), \"air width\");\n        let quotient_chunks_target = circuit.alloc_const(\n            SC::Challenge::from_usize(*quotient_degree),\n            \"quotient chunk count\",\n        );\n\n        challenger.observe(circuit, ext_db_target);\n        challenger.observe(circuit, base_db_target);\n        challenger.observe(circuit, width_target);\n        challenger.observe(circuit, quotient_chunks_target);\n    }\n\n    challenger.observe_slice(\n        circuit,\n        \u0026commitments_targets.trace_targets.to_observation_targets(),\n    );\n    for pv in public_values {\n        challenger.observe_slice(circuit, pv);\n    }\n\n    // Observe preprocessed widths for each instance. If a global\n    // preprocessed commitment exists, observe it once.\n    for \u0026pre_w in preprocessed_widths.iter() {\n        let pre_w_target =\n            circuit.alloc_const(SC::Challenge::from_usize(pre_w), \"preprocessed width\");\n        challenger.observe(circuit, pre_w_target);\n    }\n    if let Some(global) = \u0026common.preprocessed {\n        challenger.observe_slice(circuit, \u0026global.commitment.to_observation_targets());\n    }\n\n    let alpha = challenger.sample(circuit);\n\n    challenger.observe_slice(\n        circuit,\n        \u0026commitments_targets\n            .quotient_chunks_targets\n            .to_observation_targets(),\n    );\n    let zeta = challenger.sample(circuit);\n\n    // Build per-instance domains.\n    let mut trace_domains = Vec::with_capacity(n_instances);\n    let mut ext_trace_domains = Vec::with_capacity(n_instances);\n    for \u0026ext_db in degree_bits {\n        let base_db = ext_db - config.is_zk();\n        trace_domains.push(pcs.natural_domain_for_degree(1 \u003c\u003c base_db));\n        ext_trace_domains.push(pcs.natural_domain_for_degree(1 \u003c\u003c ext_db));\n    }\n\n    // Collect commitments with opening points for PCS verification.\n    let mut coms_to_verify = vec![];\n\n    let trace_round: Vec\u003c_\u003e = ext_trace_domains\n        .iter()\n        .zip(instances.iter())\n        .map(|(ext_dom, inst)| {\n            let first_point = pcs.first_point(ext_dom);\n            let next_point = ext_dom.next_point(first_point).ok_or_else(|| {\n                VerificationError::InvalidProofShape(\n                    \"Trace domain does not provide next point\".to_string(),\n                )\n            })?;\n            let generator = next_point * first_point.inverse();\n            let generator_const = circuit.add_const(generator);\n            let zeta_next = circuit.mul(zeta, generator_const);\n            Ok((\n                *ext_dom,\n                vec![\n                    (zeta, inst.trace_local.clone()),\n                    (zeta_next, inst.trace_next.clone()),\n                ],\n            ))\n        })\n        .collect::\u003cResult\u003c_, VerificationError\u003e\u003e()?;\n    coms_to_verify.push((commitments_targets.trace_targets.clone(), trace_round));\n\n    let quotient_domains: Vec\u003cVec\u003c_\u003e\u003e = degree_bits\n        .iter()\n        .zip(ext_trace_domains.iter())\n        .zip(log_quotient_degrees.iter())\n        .map(|((\u0026ext_db, ext_dom), \u0026log_qd)| {\n            let base_db = ext_db - config.is_zk();\n            let q_domain = ext_dom.create_disjoint_domain(1 \u003c\u003c (base_db + log_qd + config.is_zk()));\n            q_domain.split_domains(1 \u003c\u003c (log_qd + config.is_zk()))\n        })\n        .collect();\n\n    let mut quotient_round = Vec::new();\n    for (domains, inst) in quotient_domains.iter().zip(instances.iter()) {\n        if domains.len() != inst.quotient_chunks.len() {\n            return Err(VerificationError::InvalidProofShape(\n                \"Quotient chunk count mismatch across domains\".to_string(),\n            ));\n        }\n        for (domain, values) in domains.iter().zip(inst.quotient_chunks.iter()) {\n            quotient_round.push((*domain, vec![(zeta, values.clone())]));\n        }\n    }\n    coms_to_verify.push((\n        commitments_targets.quotient_chunks_targets.clone(),\n        quotient_round,\n    ));\n\n    if let Some(global) = \u0026common.preprocessed {\n        let mut pre_round = Vec::with_capacity(global.matrix_to_instance.len());\n\n        for (matrix_index, \u0026inst_idx) in global.matrix_to_instance.iter().enumerate() {\n            let pre_w = preprocessed_widths[inst_idx];\n            if pre_w == 0 {\n                return Err(VerificationError::InvalidProofShape(\n                    \"Instance has preprocessed columns with zero width\".to_string(),\n                ));\n            }\n\n            let inst = \u0026instances[inst_idx];\n            let local = inst.preprocessed_local.as_ref().ok_or_else(|| {\n                VerificationError::InvalidProofShape(\n                    \"Missing preprocessed local columns\".to_string(),\n                )\n            })?;\n            let next = inst.preprocessed_next.as_ref().ok_or_else(|| {\n                VerificationError::InvalidProofShape(\n                    \"Missing preprocessed next columns\".to_string(),\n                )\n            })?;\n            // Validate that the preprocessed data's base degree matches what we expect.\n            let ext_db = degree_bits[inst_idx];\n            let expected_base_db = ext_db - config.is_zk();\n\n            let meta = global.instances.instances[inst_idx]\n                .as_ref()\n                .ok_or_else(|| {\n                    VerificationError::InvalidProofShape(\n                        \"Missing preprocessed instance metadata\".to_string(),\n                    )\n                })?;\n            if meta.matrix_index != matrix_index || meta.degree_bits != expected_base_db {\n                return Err(VerificationError::InvalidProofShape(\n                    \"Preprocessed instance metadata mismatch\".to_string(),\n                ));\n            }\n\n            let ext_dom = \u0026ext_trace_domains[inst_idx];\n\n            let first_point = pcs.first_point(ext_dom);\n            let next_point = ext_dom.next_point(first_point).ok_or_else(|| {\n                VerificationError::InvalidProofShape(\n                    \"Trace domain does not provide next point\".to_string(),\n                )\n            })?;\n            let generator = next_point * first_point.inverse();\n            let generator_const = circuit.add_const(generator);\n            let zeta_next = circuit.mul(zeta, generator_const);\n\n            pre_round.push((\n                *ext_dom,\n                vec![(zeta, local.clone()), (zeta_next, next.clone())],\n            ));\n        }\n\n        coms_to_verify.push((global.commitment.clone(), pre_round));\n    }\n\n    let pcs_challenges = SC::Pcs::get_challenges_circuit::\u003cRATE\u003e(\n        circuit,\n        \u0026mut challenger,\n        flattened,\n        opened_values_targets,\n        pcs_params,\n    )?;\n\n    pcs.verify_circuit(\n        circuit,\n        \u0026pcs_challenges,\n        \u0026coms_to_verify,\n        opening_proof,\n        pcs_params,\n    )?;\n\n    // Verify AIR constraints per instance.\n    for i in 0..n_instances {\n        let air = \u0026airs[i];\n        let inst = \u0026instances[i];\n        let trace_domain = \u0026trace_domains[i];\n        let public_vals = \u0026public_values[i];\n        let domains = \u0026quotient_domains[i];\n\n        let quotient = recompose_quotient_from_chunks_circuit::\u003cSC, _, _, _, _\u003e(\n            circuit,\n            domains,\n            \u0026inst.quotient_chunks,\n            zeta,\n            pcs,\n        );\n\n        let local_prep_values = match inst.preprocessed_local.as_ref() {\n            Some(v) =\u003e v.as_slice(),\n            None =\u003e \u0026[],\n        };\n        let next_prep_values = match inst.preprocessed_next.as_ref() {\n            Some(v) =\u003e v.as_slice(),\n            None =\u003e \u0026[],\n        };\n\n        let sels = pcs.selectors_at_point_circuit(circuit, trace_domain, \u0026zeta);\n        let columns_targets = ColumnsTargets {\n            challenges: \u0026[],\n            public_values: public_vals,\n            local_prep_values,\n            next_prep_values,\n            local_values: \u0026inst.trace_local,\n            next_values: \u0026inst.trace_next,\n        };\n        let folded_constraints = air.eval_folded_circuit(circuit, \u0026sels, \u0026alpha, columns_targets);\n\n        let folded_mul = circuit.mul(folded_constraints, sels.inv_vanishing);\n        circuit.connect(folded_mul, quotient);\n    }\n\n    Ok(())\n}\n","traces":[{"line":48,"address":[2343488],"length":1,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[2343564],"length":1,"stats":{"Line":1}},{"line":51,"address":[2343589],"length":1,"stats":{"Line":1}},{"line":52,"address":[2343614],"length":1,"stats":{"Line":1}},{"line":53,"address":[2343639],"length":1,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":64,"address":[2395184],"length":1,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[2395355],"length":1,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[2383597,2380992,2383603],"length":1,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[2381253],"length":1,"stats":{"Line":1}},{"line":111,"address":[2381298],"length":1,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[2382088,2381933,2383616,2381599,2381542,2382843,2382359,2382267,2381778],"length":1,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":125,"address":[2381886,2381973],"length":1,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[2382041,2382136],"length":1,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[2382326],"length":1,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[2382828,2382916],"length":1,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[2383050],"length":1,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[2397248,2401665,2399825],"length":1,"stats":{"Line":2}},{"line":203,"address":[2993639],"length":1,"stats":{"Line":2}},{"line":204,"address":[2397456,2397519],"length":1,"stats":{"Line":4}},{"line":210,"address":[2993871],"length":1,"stats":{"Line":2}},{"line":211,"address":[2397580],"length":1,"stats":{"Line":2}},{"line":212,"address":[2993977],"length":1,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[2994099],"length":1,"stats":{"Line":2}},{"line":216,"address":[2397832,2397909],"length":1,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":6}},{"line":219,"address":[2398119,2399892],"length":1,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[2996441],"length":1,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[2400178,2400246],"length":1,"stats":{"Line":4}},{"line":227,"address":[2996659,2998016,2998310,2998304],"length":1,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[2402064],"length":1,"stats":{"Line":2}},{"line":230,"address":[2998126,2998194],"length":1,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":234,"address":[],"length":0,"stats":{"Line":6}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[2401858,2401790],"length":1,"stats":{"Line":4}},{"line":239,"address":[2998590],"length":1,"stats":{"Line":2}},{"line":242,"address":[2400500,2400567],"length":1,"stats":{"Line":4}},{"line":243,"address":[2400659,2401403,2400590],"length":1,"stats":{"Line":6}},{"line":244,"address":[2997545,2997091],"length":1,"stats":{"Line":4}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[2997581,2997661],"length":1,"stats":{"Line":4}},{"line":247,"address":[2401332],"length":1,"stats":{"Line":2}},{"line":250,"address":[2400969],"length":1,"stats":{"Line":2}},{"line":251,"address":[2997105],"length":1,"stats":{"Line":2}},{"line":252,"address":[],"length":0,"stats":{"Line":2}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[2997265],"length":1,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[2398400,2398225,2398290],"length":1,"stats":{"Line":6}},{"line":268,"address":[2398489,2398428,2398599],"length":1,"stats":{"Line":6}},{"line":279,"address":[2398960],"length":1,"stats":{"Line":2}},{"line":286,"address":[2995452],"length":1,"stats":{"Line":2}},{"line":297,"address":[2399502],"length":1,"stats":{"Line":2}},{"line":301,"address":[2993559,2993565,2992080],"length":1,"stats":{"Line":2}},{"line":303,"address":[2992119],"length":1,"stats":{"Line":2}},{"line":304,"address":[2992144],"length":1,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":313,"address":[2396471],"length":1,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[2993046,2993215],"length":1,"stats":{"Line":4}},{"line":318,"address":[2993223,2993279],"length":1,"stats":{"Line":4}},{"line":320,"address":[2397024,2396912],"length":1,"stats":{"Line":4}},{"line":321,"address":[2993460],"length":1,"stats":{"Line":2}},{"line":325,"address":[2396253],"length":1,"stats":{"Line":2}},{"line":326,"address":[2396311],"length":1,"stats":{"Line":2}},{"line":331,"address":[2984699,2972298,2969040],"length":1,"stats":{"Line":2}},{"line":364,"address":[2363323],"length":1,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[2969570],"length":1,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[2969502],"length":1,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":2}},{"line":373,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[2363739],"length":1,"stats":{"Line":0}},{"line":376,"address":[2363705],"length":1,"stats":{"Line":0}},{"line":380,"address":[2363869],"length":1,"stats":{"Line":2}},{"line":382,"address":[2363901],"length":1,"stats":{"Line":2}},{"line":383,"address":[],"length":0,"stats":{"Line":2}},{"line":384,"address":[2969903],"length":1,"stats":{"Line":2}},{"line":385,"address":[2363943],"length":1,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":387,"address":[],"length":0,"stats":{"Line":2}},{"line":389,"address":[2364017],"length":1,"stats":{"Line":2}},{"line":390,"address":[2364115],"length":1,"stats":{"Line":0}},{"line":391,"address":[2364081],"length":1,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":2}},{"line":398,"address":[2364050],"length":1,"stats":{"Line":2}},{"line":399,"address":[2970039],"length":1,"stats":{"Line":2}},{"line":400,"address":[2364257],"length":1,"stats":{"Line":2}},{"line":401,"address":[2364612],"length":1,"stats":{"Line":2}},{"line":402,"address":[2970289],"length":1,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[2364566],"length":1,"stats":{"Line":2}},{"line":405,"address":[2970557],"length":1,"stats":{"Line":2}},{"line":407,"address":[2376588],"length":1,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":10}},{"line":412,"address":[],"length":0,"stats":{"Line":2}},{"line":414,"address":[2985888,2982599,2985897],"length":1,"stats":{"Line":6}},{"line":415,"address":[2986752,2982669,2986761],"length":1,"stats":{"Line":6}},{"line":416,"address":[2376763],"length":1,"stats":{"Line":2}},{"line":417,"address":[2378417,2376807],"length":1,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[2982892,2982986],"length":1,"stats":{"Line":4}},{"line":423,"address":[2984042],"length":1,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[2983004],"length":1,"stats":{"Line":2}},{"line":432,"address":[2377127,2377250],"length":1,"stats":{"Line":2}},{"line":434,"address":[2983198,2983244],"length":1,"stats":{"Line":4}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[2983262,2983359,2983398],"length":1,"stats":{"Line":6}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[2379561,2379536,2377415],"length":1,"stats":{"Line":6}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[2983409],"length":1,"stats":{"Line":2}},{"line":454,"address":[],"length":0,"stats":{"Line":2}},{"line":458,"address":[2970789],"length":1,"stats":{"Line":2}},{"line":459,"address":[],"length":0,"stats":{"Line":2}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[2970931],"length":1,"stats":{"Line":2}},{"line":465,"address":[2970946,2971259],"length":1,"stats":{"Line":4}},{"line":466,"address":[2970985],"length":1,"stats":{"Line":2}},{"line":467,"address":[2971052],"length":1,"stats":{"Line":2}},{"line":468,"address":[2971181],"length":1,"stats":{"Line":2}},{"line":470,"address":[2378752,2375799,2376475,2365461,2375975],"length":1,"stats":{"Line":4}},{"line":471,"address":[2985967],"length":1,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[2981992],"length":1,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":2}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":2}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":2}},{"line":482,"address":[2982244],"length":1,"stats":{"Line":2}},{"line":486,"address":[],"length":0,"stats":{"Line":2}},{"line":487,"address":[2982371],"length":1,"stats":{"Line":2}},{"line":488,"address":[],"length":0,"stats":{"Line":2}},{"line":489,"address":[2376463],"length":1,"stats":{"Line":2}},{"line":492,"address":[],"length":0,"stats":{"Line":2}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[2365487],"length":1,"stats":{"Line":2}},{"line":496,"address":[2971623],"length":1,"stats":{"Line":2}},{"line":497,"address":[2981739,2971768],"length":1,"stats":{"Line":4}},{"line":502,"address":[2365834],"length":1,"stats":{"Line":2}},{"line":503,"address":[2366076,2375663],"length":1,"stats":{"Line":4}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[2981695],"length":1,"stats":{"Line":2}},{"line":507,"address":[],"length":0,"stats":{"Line":2}},{"line":508,"address":[],"length":0,"stats":{"Line":4}},{"line":511,"address":[2366177,2366351],"length":1,"stats":{"Line":4}},{"line":513,"address":[],"length":0,"stats":{"Line":2}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":4}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":2}},{"line":519,"address":[2972494],"length":1,"stats":{"Line":2}},{"line":522,"address":[],"length":0,"stats":{"Line":2}},{"line":523,"address":[],"length":0,"stats":{"Line":2}},{"line":524,"address":[],"length":0,"stats":{"Line":4}},{"line":525,"address":[2972817,2981370,2981413],"length":1,"stats":{"Line":4}},{"line":526,"address":[2981405,2981450],"length":1,"stats":{"Line":4}},{"line":527,"address":[2375559],"length":1,"stats":{"Line":2}},{"line":531,"address":[2972843],"length":1,"stats":{"Line":2}},{"line":533,"address":[2375336,2367365,2366890,2367259],"length":1,"stats":{"Line":4}},{"line":535,"address":[2973000],"length":1,"stats":{"Line":2}},{"line":536,"address":[2379776,2380816,2380822,2379832,2367157],"length":1,"stats":{"Line":6}},{"line":537,"address":[],"length":0,"stats":{"Line":2}},{"line":538,"address":[2984810,2984948,2986864],"length":1,"stats":{"Line":2}},{"line":539,"address":[2986911],"length":1,"stats":{"Line":0}},{"line":540,"address":[2986878],"length":1,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":2}},{"line":544,"address":[],"length":0,"stats":{"Line":2}},{"line":545,"address":[2380159],"length":1,"stats":{"Line":2}},{"line":546,"address":[2380675],"length":1,"stats":{"Line":2}},{"line":547,"address":[2985138],"length":1,"stats":{"Line":2}},{"line":548,"address":[],"length":0,"stats":{"Line":4}},{"line":549,"address":[],"length":0,"stats":{"Line":4}},{"line":550,"address":[],"length":0,"stats":{"Line":4}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":557,"address":[2973633],"length":1,"stats":{"Line":2}},{"line":559,"address":[],"length":0,"stats":{"Line":2}},{"line":560,"address":[2367888],"length":1,"stats":{"Line":2}},{"line":561,"address":[2378944,2368017,2378971],"length":1,"stats":{"Line":6}},{"line":562,"address":[2379018,2379086],"length":1,"stats":{"Line":2}},{"line":563,"address":[2986655,2986476,2986512],"length":1,"stats":{"Line":4}},{"line":564,"address":[2986672,2986622,2986737],"length":1,"stats":{"Line":4}},{"line":568,"address":[2974023],"length":1,"stats":{"Line":2}},{"line":569,"address":[],"length":0,"stats":{"Line":4}},{"line":570,"address":[2368558,2374242],"length":1,"stats":{"Line":4}},{"line":571,"address":[2375157],"length":1,"stats":{"Line":0}},{"line":572,"address":[2374317],"length":1,"stats":{"Line":0}},{"line":575,"address":[],"length":0,"stats":{"Line":4}},{"line":576,"address":[2980706],"length":1,"stats":{"Line":2}},{"line":579,"address":[],"length":0,"stats":{"Line":2}},{"line":580,"address":[],"length":0,"stats":{"Line":2}},{"line":581,"address":[2368603],"length":1,"stats":{"Line":2}},{"line":584,"address":[2369454,2368738],"length":1,"stats":{"Line":4}},{"line":585,"address":[],"length":0,"stats":{"Line":4}},{"line":587,"address":[2974949,2974865],"length":1,"stats":{"Line":4}},{"line":588,"address":[2369259,2369467],"length":1,"stats":{"Line":4}},{"line":589,"address":[2369478],"length":1,"stats":{"Line":2}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[2369484],"length":1,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":4}},{"line":596,"address":[2371730,2378848,2369836,2369672],"length":1,"stats":{"Line":2}},{"line":597,"address":[2378895],"length":1,"stats":{"Line":0}},{"line":598,"address":[2986126],"length":1,"stats":{"Line":0}},{"line":601,"address":[2369893,2370057,2371725,2379584],"length":1,"stats":{"Line":2}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[2379598],"length":1,"stats":{"Line":0}},{"line":607,"address":[2370122],"length":1,"stats":{"Line":2}},{"line":608,"address":[2370179,2370283],"length":1,"stats":{"Line":2}},{"line":610,"address":[],"length":0,"stats":{"Line":4}},{"line":612,"address":[2370342,2379408],"length":1,"stats":{"Line":2}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[2985806],"length":1,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":2}},{"line":618,"address":[2371638],"length":1,"stats":{"Line":0}},{"line":619,"address":[2370555],"length":1,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":2}},{"line":625,"address":[2976627],"length":1,"stats":{"Line":2}},{"line":626,"address":[2976826,2976642,2977593,2986256],"length":1,"stats":{"Line":2}},{"line":627,"address":[2986303],"length":1,"stats":{"Line":0}},{"line":628,"address":[2986270],"length":1,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":2}},{"line":632,"address":[2370977],"length":1,"stats":{"Line":2}},{"line":633,"address":[2371037],"length":1,"stats":{"Line":2}},{"line":635,"address":[2977512],"length":1,"stats":{"Line":2}},{"line":636,"address":[2371080],"length":1,"stats":{"Line":2}},{"line":637,"address":[2977069,2977588],"length":1,"stats":{"Line":2}},{"line":641,"address":[2369300],"length":1,"stats":{"Line":2}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":2}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":2}},{"line":655,"address":[2978074],"length":1,"stats":{"Line":2}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[2372377],"length":1,"stats":{"Line":2}},{"line":662,"address":[],"length":0,"stats":{"Line":4}},{"line":663,"address":[2372812,2372887],"length":1,"stats":{"Line":4}},{"line":664,"address":[2978863],"length":1,"stats":{"Line":2}},{"line":665,"address":[],"length":0,"stats":{"Line":2}},{"line":666,"address":[2978970,2979045],"length":1,"stats":{"Line":4}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[2373085],"length":1,"stats":{"Line":2}},{"line":671,"address":[2979116],"length":1,"stats":{"Line":2}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[2979245],"length":1,"stats":{"Line":2}},{"line":677,"address":[2979311,2979418],"length":1,"stats":{"Line":4}},{"line":678,"address":[2979350],"length":1,"stats":{"Line":1}},{"line":680,"address":[2979383,2979444],"length":1,"stats":{"Line":4}},{"line":681,"address":[],"length":0,"stats":{"Line":4}},{"line":682,"address":[2979522],"length":1,"stats":{"Line":1}},{"line":685,"address":[2979587],"length":1,"stats":{"Line":2}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":2}},{"line":692,"address":[],"length":0,"stats":{"Line":2}},{"line":694,"address":[],"length":0,"stats":{"Line":2}},{"line":696,"address":[],"length":0,"stats":{"Line":2}},{"line":697,"address":[],"length":0,"stats":{"Line":2}},{"line":700,"address":[],"length":0,"stats":{"Line":2}}],"covered":245,"coverable":320},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","errors.rs"],"content":"//! Error types for recursive verification.\n\nuse alloc::string::String;\n\nuse p3_circuit::{CircuitBuilderError, CircuitError};\nuse thiserror::Error;\n\nuse crate::generation::GenerationError;\n\n/// Errors that can occur during recursive STARK verification.\n#[derive(Debug, Error)]\npub enum VerificationError {\n    /// The proof structure is invalid (wrong dimensions, missing data, etc.)\n    #[error(\"Invalid proof shape: {0}\")]\n    InvalidProofShape(String),\n\n    /// ZK randomization is inconsistent (random commitment exists but no opened values)\n    #[error(\"Missing random opened values for existing random commitment\")]\n    RandomizationError,\n\n    /// Error from the circuit execution layer\n    #[error(\"Circuit error: {0}\")]\n    Circuit(#[from] CircuitError),\n\n    /// Error from the circuit builder layer\n    #[error(\"Circuit builder error: {0}\")]\n    CircuitBuilder(#[from] CircuitBuilderError),\n\n    /// Error from challenge generation\n    #[error(\"Generation error: {0}\")]\n    Generation(#[from] GenerationError),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","mod.rs"],"content":"//! STARK verification within recursive circuits.\n\nmod batch_stark;\nmod errors;\nmod observable;\nmod quotient;\nmod stark;\n\npub use batch_stark::{\n    BatchProofTargets, CircuitTablesAir, InstanceOpenedValuesTargets, PcsVerifierParams,\n    verify_batch_circuit, verify_p3_recursion_proof_circuit,\n};\npub use errors::VerificationError;\npub use observable::ObservableCommitment;\npub use quotient::recompose_quotient_from_chunks_circuit;\npub use stark::verify_circuit;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","observable.rs"],"content":"use alloc::vec::Vec;\n\nuse crate::Target;\n\n/// Trait for extracting commitment targets for Fiat-Shamir observation.\n///\n/// This trait allows commitments to be observed in the Fiat-Shamir transcript\n/// without the verifier needing to know the specific commitment structure.\npub trait ObservableCommitment {\n    /// Extract the targets that should be observed in the Fiat-Shamir transcript.\n    ///\n    /// These targets represent the commitment in a form suitable for hashing\n    /// into the challenger state.\n    ///\n    /// # Returns\n    /// A vector of targets representing the commitment\n    fn to_observation_targets(\u0026self) -\u003e Vec\u003cTarget\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","quotient.rs"],"content":"//! Quotient polynomial recomposition for recursive STARK verification.\n\nuse alloc::vec::Vec;\n\nuse itertools::Itertools;\nuse p3_circuit::CircuitBuilder;\nuse p3_field::{BasedVectorSpace, Field, PrimeCharacteristicRing};\nuse p3_uni_stark::StarkGenericConfig;\n\nuse crate::Target;\nuse crate::traits::{Recursive, RecursivePcs};\n\n/// Reconstructs the quotient polynomial evaluation `Q(ζ)` from opened chunks.\n///\n/// # Mathematical Background\n///\n/// When the quotient polynomial `Q(X)` is split into chunks `Q_i(X)` over disjoint domains\n/// `D_i`, we reconstruct `Q(ζ)` at an out-of-domain point using:\n///\n/// ```text\n/// Q(ζ) = ∑_i Q_i(·) · L_i(ζ)\n/// ```\n///\n/// where `L_i(ζ)` is the Lagrange interpolation coefficient:\n///\n/// ```text\n/// L_i(ζ) = ∏_{j≠i} [Z_j(ζ) / Z_j(g_i)]\n/// ```\n///\n/// Here:\n/// - `Z_j(X) = (X/g_j)^|D_j| - 1` is the vanishing polynomial for domain `D_j`\n/// - `g_i` is the first point (generator) of domain `D_i`\n/// - `Q_i(·)` is evaluated in the extension field basis\n///\n/// # Optimization: Constant Pre-computation\n///\n/// The critical insight is that `Z_j(g_i)` values are **field constants** that can be computed\n/// outside the circuit! This allows us to restructure the computation as:\n///\n/// ```text\n/// L_i(ζ) = [∏_j Z_j(ζ) / Z_i(ζ)] · [1 / ∏_{j≠i} Z_j(g_i)]\n///          └─────────────────────┘   └────────────────────┘\n///            computed in-circuit      pre-computed constant\n/// ```\n///\n/// This transforms the denominator from O(N^2) in-circuit operations to O(N^2) native field\n/// operations.\n///\n/// # Arguments\n///\n/// * `circuit` - The circuit builder for adding verification constraints.\n/// * `quotient_chunks_domains` - Domains `[D_0, ..., D_{n-1}]` for each chunk.\n/// * `quotient_chunks` - Coefficient vectors for each chunk in extension field basis.\n/// * `zeta` - The out-of-domain evaluation point `ζ`.\n/// * `pcs` - The polynomial commitment scheme providing domain operations.\n///\n/// # Returns\n///\n/// A `Target` representing the circuit variable for `Q(ζ)`.\npub fn recompose_quotient_from_chunks_circuit\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain: Copy,\n\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    quotient_chunks_domains: \u0026[Domain],\n    quotient_chunks: \u0026[Vec\u003cTarget\u003e],\n    zeta: Target,\n    pcs: \u0026SC::Pcs,\n) -\u003e Target\nwhere\n    SC::Pcs: RecursivePcs\u003cSC, InputProof, OpeningProof, Comm, Domain\u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    // Compute the Lagrange interpolation coefficients.\n    let zps = compute_quotient_chunk_products::\u003cSC, _, _, _, _\u003e(\n        circuit,\n        quotient_chunks_domains,\n        zeta,\n        pcs,\n    );\n\n    // Combine chunk evaluations with their interpolation coefficients.\n    compute_quotient_evaluation::\u003cSC\u003e(circuit, quotient_chunks, \u0026zps)\n}\n\n/// Computes a vanishing polynomial evaluation as a **native field operation** (outside the circuit).\n///\n/// This helper function evaluates `Z_H(point) = (point/g)^|H| - 1` for a domain `H` as a\n/// regular field computation, producing a constant that can be embedded in the circuit.\n///\n/// # Explainer\n///\n/// When computing Lagrange interpolation coefficients `L_i(ζ) = ∏_{j≠i} [Z_j(ζ) / Z_j(g_i)]`,\n/// the denominator terms `Z_j(g_i)` are **field constants** (not dependent on witness values).\n/// By computing them natively, we:\n///\n/// 1. **Eliminate circuit operations**: No constraints needed for these evaluations\n/// 2. **Reduce proof size**: Fewer gates and witness elements\n/// 3. **Improve verification time**: Fewer operations to verify\n///\n/// This single optimization transforms O(N^2·log|D|) circuit operations into O(N^2·log|D|)\n/// native operations that are \"free\" from the circuit's perspective.\n///\n/// # Mathematical Formula\n///\n/// For a multiplicative coset `H = {g, gω, ..., gω^(n-1)}`:\n///\n/// ```text\n/// Z_H(point) = (point/g)^n - 1\n/// ```\n///\n/// where `n = |H|` and `g` is the coset generator.\n///\n/// # Arguments\n///\n/// * `pcs` - PCS providing domain metadata (generator and size).\n/// * `domain` - The domain `H` for which to compute the vanishing polynomial.\n/// * `point` - The evaluation point.\n///\n/// # Returns\n///\n/// The field element `Z_H(point)`.\nfn vanishing_poly_at_point_native\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain,\n\u003e(\n    pcs: \u0026SC::Pcs,\n    domain: \u0026Domain,\n    point: SC::Challenge,\n) -\u003e SC::Challenge\nwhere\n    SC::Pcs: RecursivePcs\u003cSC, InputProof, OpeningProof, Comm, Domain\u003e,\n{\n    // Normalize: compute point/g where g is the coset generator\n    let normalized = point * pcs.first_point(domain).inverse();\n\n    // Exponentiate: compute (point/g)^n where n = 2^(log_size)\n    let power = normalized.exp_power_of_2(pcs.log_size(domain));\n\n    // Subtract: Z_H(point) = (point/g)^n - 1\n    power - SC::Challenge::ONE\n}\n\n/// Computes Lagrange interpolation coefficients with O(N) in-circuit complexity.\n///\n/// This function computes the product terms needed for Lagrange interpolation:\n///\n/// ```text\n/// L_i(ζ) = [∏_j Z_j(ζ) / Z_i(ζ)] · [1 / ∏_{j≠i} Z_j(g_i)]\n/// ```\n///\n/// We split this into two parts:\n/// 1. **In-circuit numerator**: `∏_j Z_j(ζ) / Z_i(ζ)` - computed using total product\n/// 2. **Pre-computed denominator**: `1 / ∏_{j≠i} Z_j(g_i)` - computed as native field constant\n///\n/// # Arguments\n///\n/// * `circuit` - The circuit builder.\n/// * `quotient_chunks_domains` - All quotient chunk domains.\n/// * `zeta` - The out-of-domain evaluation point.\n/// * `pcs` - The polynomial commitment scheme.\n///\n/// # Returns\n///\n/// A vector `[L_0(ζ), L_1(ζ), ..., L_{n-1}(ζ)]` of Lagrange interpolation coefficients.\nfn compute_quotient_chunk_products\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain: Copy,\n\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    quotient_chunks_domains: \u0026[Domain],\n    zeta: Target,\n    pcs: \u0026SC::Pcs,\n) -\u003e Vec\u003cTarget\u003e\nwhere\n    SC::Pcs: RecursivePcs\u003cSC, InputProof, OpeningProof, Comm, Domain\u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    if quotient_chunks_domains.is_empty() {\n        return Vec::new();\n    }\n\n    // Phase 1: In-circuit computation of numerators\n\n    // Compute Z_j(ζ) for all domains j in-circuit.\n    //\n    // This is the only place we evaluate vanishing polynomials at ζ in the circuit.\n    // Cost: O(N·log|D|) constraints\n    let vp_zeta_values = quotient_chunks_domains\n        .iter()\n        .map(|\u0026domain| {\n            vanishing_poly_at_point_circuit::\u003cSC, _, _, _, _\u003e(pcs, \u0026domain, zeta, circuit)\n        })\n        .collect_vec();\n\n    // Compute the total product ∏_j Z_j(ζ).\n    //\n    // Cost: O(N) multiplications\n    let total_vp_zeta_product = circuit.mul_many(\u0026vp_zeta_values);\n\n    // Phase 2: Native pre-computation of denominator constants\n\n    // Pre-compute the denominator constants ∏_{j≠i} Z_j(g_i) OUTSIDE the circuit.\n    //\n    // Why this works: g_i (first points) are public constants, so Z_j(g_i) are constants.\n    // We compute them as native field operations and embed them as circuit constants.\n    //\n    // Cost: O(N^2·log|D|) native field operations (no circuit cost!)\n    let den_constants = quotient_chunks_domains\n        .iter()\n        .enumerate()\n        .map(|(i, \u0026domain_i)| {\n            let fp_i = pcs.first_point(\u0026domain_i);\n            quotient_chunks_domains\n                    .iter()\n                    .enumerate()\n                    .filter(|\u0026(j, _)| j != i)\n                    .fold(SC::Challenge::ONE, |acc, (_, \u0026domain_j)| {\n                        // Compute Z_j(g_i) natively (no circuit operations!)\n                        acc * vanishing_poly_at_point_native::\u003c\n                            SC,\n                            InputProof,\n                            OpeningProof,\n                            Comm,\n                            Domain,\n                        \u003e(pcs, \u0026domain_j, fp_i)\n                    })\n        })\n        .collect_vec();\n\n    // Phase 3: In-circuit combination\n\n    // For each chunk i, compute L_i(ζ) = [∏_j Z_j(ζ) / Z_i(ζ)] / den_i\n    //\n    // Cost: O(N) divisions (2 divisions per chunk)\n    vp_zeta_values\n        .iter()\n        .enumerate()\n        .map(|(i, \u0026vp_zeta_i)| {\n            // Numerator: (∏_j Z_j(ζ)) / Z_i(ζ)\n            //\n            // Reuse the total product and divide by the i-th vanishing polynomial\n            let num = circuit.div(total_vp_zeta_product, vp_zeta_i);\n\n            // Denominator: Pre-computed constant ∏_{j≠i} Z_j(g_i)\n            //\n            // Simply embed the constant into the circuit (no computation!)\n            let den = circuit.add_const(den_constants[i]);\n\n            // Final Lagrange coefficient: L_i(ζ) = numerator / denominator\n            circuit.div(num, den)\n        })\n        .collect()\n}\n\n/// Computes the quotient polynomial evaluation.\n///\n/// Given chunk coefficients and Lagrange interpolation coefficients, this computes:\n///\n/// ```text\n/// Q(ζ) = ∑_i Q_i(·) · L_i(ζ)\n/// ```\n///\n/// where each `Q_i(·)` is evaluated from its extension field basis representation:\n///\n/// ```text\n/// Q_i(·) = ∑_j e_j · chunk_i[j]\n/// ```\n///\n/// # Arguments\n///\n/// * `circuit` - The circuit builder.\n/// * `opened_quotient_chunks` - Coefficient vectors in extension field basis.\n/// * `zps` - Lagrange interpolation coefficients `[L_0(ζ), ..., L_{n-1}(ζ)]`.\n///\n/// # Returns\n///\n/// A `Target` representing `Q(ζ)`.\nfn compute_quotient_evaluation\u003cSC: StarkGenericConfig\u003e(\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    opened_quotient_chunks: \u0026[Vec\u003cTarget\u003e],\n    zps: \u0026[Target],\n) -\u003e Target\nwhere\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    // Get the extension field degree.\n    let d = SC::Challenge::DIMENSION;\n\n    // Handle edge cases: empty chunks or trivial extension\n    if d == 0 || opened_quotient_chunks.is_empty() {\n        return circuit.add_const(SC::Challenge::ZERO);\n    }\n\n    // Phase 1: Pre-compute extension field basis elements\n\n    // Compute the basis elements [e_0, e_1, ..., e_{d-1}] once and reuse for all chunks.\n    //\n    // Cost: O(d) - done once\n    let basis_targets: Vec\u003c_\u003e = (0..d)\n        .map(|i| {\n            let basis_elem =\n                SC::Challenge::ith_basis_element(i).expect(\"Basis index should be in range [0, d)\");\n            circuit.add_const(basis_elem)\n        })\n        .collect();\n\n    // Phase 2: Evaluate each chunk polynomial using inner product\n\n    // For each chunk, compute Q_i = ∑_j e_j · chunk_i[j] using inner product.\n    //\n    // Cost: O(n·d) multiply-adds\n    let chunk_evals = opened_quotient_chunks\n        .iter()\n        .map(|chunk| {\n            // Validate chunk length in debug builds\n            debug_assert_eq!(\n                chunk.len(),\n                d,\n                \"Chunk length must match field extension degree\"\n            );\n\n            // Compute Q_i = \u003cchunk, basis\u003e = ∑_j chunk[j] · e_j\n            circuit.inner_product(chunk, \u0026basis_targets)\n        })\n        .collect_vec();\n\n    // Phase 3: Combine chunk evaluations with Lagrange coefficients\n\n    // Compute the final sum Q(ζ) = ∑_i Q_i · L_i(ζ) using inner product.\n    //\n    // Cost: O(n) multiply-adds\n    circuit.inner_product(\u0026chunk_evals, zps)\n}\n\n/// Computes a vanishing polynomial evaluation **in-circuit**.\n///\n/// This function adds circuit constraints to compute `Z_H(point) = (point/g)^n - 1`\n/// for a domain `H`, where the result is a circuit variable (not a constant).\n///\n/// # Mathematical Formula\n///\n/// For a multiplicative coset `H = {g, gω, ..., gω^(n-1)}`:\n///\n/// ```text\n/// Z_H(point) = (point/g)^n - 1\n/// ```\n///\n/// where `n = |H|` and `g` is the coset generator.\n///\n/// # Arguments\n///\n/// * `pcs` - PCS providing domain metadata.\n/// * `domain` - The domain `H`.\n/// * `point` - The evaluation point (a circuit variable).\n/// * `circuit` - The circuit builder.\n///\n/// # Returns\n///\n/// A `Target` representing `Z_H(point)` in the circuit.\nfn vanishing_poly_at_point_circuit\u003c\n    SC: StarkGenericConfig,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    Comm: Recursive\u003cSC::Challenge\u003e,\n    Domain,\n\u003e(\n    pcs: \u0026SC::Pcs,\n    domain: \u0026Domain,\n    point: Target,\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n) -\u003e Target\nwhere\n    SC::Pcs: RecursivePcs\u003cSC, InputProof, OpeningProof, Comm, Domain\u003e,\n{\n    // Normalize: compute point/g where g is the coset generator\n    //\n    // Cost: 1 multiplication constraint\n    let inv = circuit.add_const(pcs.first_point(domain).inverse());\n    let mul = circuit.mul(point, inv);\n\n    // Exponentiate: compute (point/g)^n where n = 2^(log_size)\n    //\n    // Cost: log_2(n) squaring constraints\n    let exp = circuit.exp_power_of_2(mul, pcs.log_size(domain));\n\n    // Subtract: Z_H(point) = (point/g)^n - 1\n    //\n    // Cost: 1 subtraction constraint\n    let one = circuit.add_const(SC::Challenge::ONE);\n    circuit.sub(exp, one)\n}\n","traces":[{"line":60,"address":[2408592,2408368,2408598],"length":1,"stats":{"Line":5}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[2837182,2837262],"length":1,"stats":{"Line":10}},{"line":126,"address":[2406464],"length":1,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[2835288],"length":1,"stats":{"Line":3}},{"line":147,"address":[3675332],"length":1,"stats":{"Line":3}},{"line":172,"address":[2407441,2406704,2407447],"length":1,"stats":{"Line":5}},{"line":188,"address":[2046768],"length":1,"stats":{"Line":5}},{"line":189,"address":[3675669],"length":1,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[2046809,2047457,2047440],"length":1,"stats":{"Line":15}},{"line":201,"address":[2047474],"length":1,"stats":{"Line":5}},{"line":208,"address":[2406927,2407018],"length":1,"stats":{"Line":10}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[2047075,2047710,2047664],"length":1,"stats":{"Line":15}},{"line":222,"address":[2836404],"length":1,"stats":{"Line":5}},{"line":223,"address":[3557620],"length":1,"stats":{"Line":9}},{"line":224,"address":[2836435],"length":1,"stats":{"Line":5}},{"line":225,"address":[3676363],"length":1,"stats":{"Line":5}},{"line":226,"address":[2407813,2408080,2408090],"length":1,"stats":{"Line":15}},{"line":227,"address":[2407843,2407876,2407920,2407957],"length":1,"stats":{"Line":15}},{"line":229,"address":[3558008],"length":1,"stats":{"Line":3}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[3557999],"length":1,"stats":{"Line":3}},{"line":245,"address":[2407193],"length":1,"stats":{"Line":5}},{"line":248,"address":[2836208,2836176,2836009],"length":1,"stats":{"Line":15}},{"line":252,"address":[],"length":0,"stats":{"Line":5}},{"line":257,"address":[],"length":0,"stats":{"Line":5}},{"line":260,"address":[3676626],"length":1,"stats":{"Line":5}},{"line":288,"address":[2046028,2045488,2046022],"length":1,"stats":{"Line":5}},{"line":297,"address":[2045560],"length":1,"stats":{"Line":5}},{"line":300,"address":[2834305,2834380],"length":1,"stats":{"Line":10}},{"line":301,"address":[3674334],"length":1,"stats":{"Line":0}},{"line":309,"address":[3555894],"length":1,"stats":{"Line":5}},{"line":310,"address":[2406352,2405712],"length":1,"stats":{"Line":10}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[2406371],"length":1,"stats":{"Line":5}},{"line":313,"address":[3675140],"length":1,"stats":{"Line":5}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[2405824,2406080],"length":1,"stats":{"Line":10}},{"line":326,"address":[],"length":0,"stats":{"Line":5}},{"line":327,"address":[],"length":0,"stats":{"Line":5}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[3556474],"length":1,"stats":{"Line":5}},{"line":342,"address":[3674713,3674627],"length":1,"stats":{"Line":10}},{"line":370,"address":[3558048],"length":1,"stats":{"Line":5}},{"line":388,"address":[2048133],"length":1,"stats":{"Line":5}},{"line":389,"address":[2836924],"length":1,"stats":{"Line":5}},{"line":394,"address":[3558159],"length":1,"stats":{"Line":5}},{"line":399,"address":[],"length":0,"stats":{"Line":5}},{"line":400,"address":[],"length":0,"stats":{"Line":5}}],"covered":43,"coverable":60},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","src","verifier","stark.rs"],"content":"use alloc::string::ToString;\nuse alloc::vec::Vec;\nuse alloc::{format, vec};\n\nuse itertools::Itertools;\nuse p3_circuit::utils::ColumnsTargets;\nuse p3_circuit::{CircuitBuilder, CircuitError};\nuse p3_commit::Pcs;\nuse p3_field::{BasedVectorSpace, PrimeCharacteristicRing};\nuse p3_uni_stark::StarkGenericConfig;\n\nuse super::{ObservableCommitment, VerificationError, recompose_quotient_from_chunks_circuit};\nuse crate::Target;\nuse crate::challenger::CircuitChallenger;\nuse crate::traits::{Recursive, RecursiveAir, RecursivePcs};\nuse crate::types::{CommitmentTargets, OpenedValuesTargets, ProofTargets, StarkChallenges};\n\n/// Type alias for PCS verifier parameters.\ntype PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e =\n    \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as RecursivePcs\u003c\n        SC,\n        InputProof,\n        OpeningProof,\n        Comm,\n        \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n            \u003cSC as StarkGenericConfig\u003e::Challenge,\n            \u003cSC as StarkGenericConfig\u003e::Challenger,\n        \u003e\u003e::Domain,\n    \u003e\u003e::VerifierParams;\n\ntype PcsDomain\u003cSC\u003e = \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\n    \u003cSC as StarkGenericConfig\u003e::Challenger,\n\u003e\u003e::Domain;\n\n/// Verifies a STARK proof within a circuit.\n///\n/// This function adds constraints to the circuit builder that verify a STARK proof.\n///\n/// # Parameters\n/// - `config`: STARK configuration including PCS and challenger\n/// - `air`: The Algebraic Intermediate Representation defining the computation\n/// - `circuit`: Circuit builder to add verification constraints to\n/// - `proof_targets`: Recursive representation of the proof\n/// - `public_values`: Public input targets\n/// - `pcs_params`: PCS-specific verifier parameters (e.g. FRI's log blowup / final poly size)\n///\n/// # Returns\n/// `Ok(())` if the circuit was successfully constructed, `Err` otherwise.\npub fn verify_circuit\u003c\n    A,\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e + Clone\n        + ObservableCommitment,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    const RATE: usize,\n\u003e(\n    config: \u0026SC,\n    air: \u0026A,\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    proof_targets: \u0026ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    public_values: \u0026[Target],\n    preprocessed_commit: \u0026Option\u003cComm\u003e,\n    pcs_params: \u0026PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e,\n) -\u003e Result\u003c(), VerificationError\u003e\nwhere\n    A: RecursiveAir\u003cSC::Challenge\u003e,\n    \u003cSC as StarkGenericConfig\u003e::Pcs: RecursivePcs\u003c\n            SC,\n            InputProof,\n            OpeningProof,\n            Comm,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    let ProofTargets {\n        commitments_targets:\n            CommitmentTargets {\n                trace_targets,\n                quotient_chunks_targets,\n                random_commit,\n                ..\n            },\n        opened_values_targets,\n        opening_proof,\n        degree_bits,\n    } = proof_targets;\n\n    let OpenedValuesTargets {\n        trace_local_targets: opened_trace_local_targets,\n        trace_next_targets: opened_trace_next_targets,\n        preprocessed_local_targets: opt_opened_preprocessed_local_targets,\n        preprocessed_next_targets: opt_opened_preprocessed_next_targets,\n        quotient_chunks_targets: opened_quotient_chunks_targets,\n        random_targets: opened_random,\n        ..\n    } = opened_values_targets;\n\n    let degree = 1 \u003c\u003c degree_bits;\n    let preprocessed_width = opt_opened_preprocessed_local_targets\n        .as_ref()\n        .map_or(0, |p| p.len());\n    let log_quotient_degree = A::get_log_num_quotient_chunks(\n        air,\n        preprocessed_width,\n        public_values.len(),\n        config.is_zk(),\n    );\n    let quotient_degree = 1 \u003c\u003c (log_quotient_degree + config.is_zk());\n\n    let pcs = config.pcs();\n    let trace_domain = pcs.natural_domain_for_degree(degree);\n    let init_trace_domain = pcs.natural_domain_for_degree(degree \u003e\u003e (config.is_zk()));\n\n    let quotient_domain =\n        pcs.create_disjoint_domain(trace_domain, 1 \u003c\u003c (degree_bits + log_quotient_degree));\n    let quotient_chunks_domains = pcs.split_domains(\u0026quotient_domain, quotient_degree);\n\n    let randomized_quotient_chunks_domains = quotient_chunks_domains\n        .iter()\n        .map(|domain| pcs.natural_domain_for_degree(pcs.size(domain) \u003c\u003c (config.is_zk())))\n        .collect_vec();\n\n    // Generate all challenges (alpha, zeta, zeta_next, PCS challenges)\n    let challenge_targets = get_circuit_challenges::\u003cA, SC, Comm, InputProof, OpeningProof, RATE\u003e(\n        air,\n        config,\n        proof_targets,\n        public_values,\n        preprocessed_width,\n        circuit,\n        pcs_params,\n    )?;\n\n    // Validate ZK randomization consistency\n    if (opened_random.is_some() != SC::Pcs::ZK) || (random_commit.is_some() != SC::Pcs::ZK) {\n        return Err(VerificationError::RandomizationError);\n    }\n\n    // Validate proof shape\n    validate_proof_shape::\u003cA, SC, Comm\u003e(\n        air,\n        opened_values_targets,\n        preprocessed_width,\n        preprocessed_commit,\n        quotient_degree,\n    )?;\n\n    let alpha = challenge_targets[0];\n    let zeta = challenge_targets[1];\n    let zeta_next = challenge_targets[2];\n\n    // Prepare commitments with their opening points for PCS verification\n    let mut coms_to_verify = if let Some(r_commit) = \u0026random_commit {\n        let random_values = opened_random\n            .as_ref()\n            .ok_or(VerificationError::RandomizationError)?;\n        vec![(\n            r_commit.clone(),\n            vec![(trace_domain, vec![(zeta, random_values.clone())])],\n        )]\n    } else {\n        vec![]\n    };\n\n    coms_to_verify.extend(vec![\n        (\n            trace_targets.clone(),\n            vec![(\n                trace_domain,\n                vec![\n                    (zeta, opened_trace_local_targets.clone()),\n                    (zeta_next, opened_trace_next_targets.clone()),\n                ],\n            )],\n        ),\n        (\n            quotient_chunks_targets.clone(),\n            // Check the commitment on the randomized domains\n            {\n                if randomized_quotient_chunks_domains.len() != opened_quotient_chunks_targets.len()\n                {\n                    return Err(VerificationError::InvalidProofShape(\n                        \"Randomized quotient chunks length mismatch\".to_string(),\n                    ));\n                }\n                randomized_quotient_chunks_domains\n                    .iter()\n                    .zip(opened_quotient_chunks_targets)\n                    .map(|(domain, values)| (*domain, vec![(zeta, values.clone())]))\n                    .collect_vec()\n            },\n        ),\n    ]);\n\n    // Add preprocessed commitment verification if present\n    if preprocessed_width \u003e 0 {\n        coms_to_verify.push((\n            preprocessed_commit\n                .clone()\n                .expect(\"We checked in validate_proof_shape that the commit exists\"),\n            vec![(\n                trace_domain,\n                vec![\n                    (zeta, opt_opened_preprocessed_local_targets.clone().unwrap()),\n                    (\n                        zeta_next,\n                        opt_opened_preprocessed_next_targets.clone().unwrap(),\n                    ),\n                ],\n            )],\n        ));\n    }\n\n    // Verify polynomial openings using PCS\n    pcs.verify_circuit(\n        circuit,\n        \u0026challenge_targets[3..], // PCS challenges (after alpha, zeta, zeta_next)\n        \u0026coms_to_verify,\n        opening_proof,\n        pcs_params,\n    )?;\n\n    // Compute quotient polynomial evaluation from chunks\n    let quotient = recompose_quotient_from_chunks_circuit::\u003c\n        SC,\n        InputProof,\n        OpeningProof,\n        Comm,\n        PcsDomain\u003cSC\u003e,\n    \u003e(\n        circuit,\n        \u0026quotient_chunks_domains,\n        opened_quotient_chunks_targets,\n        zeta,\n        pcs,\n    );\n\n    // Evaluate AIR constraints at out-of-domain point\n    let sels = pcs.selectors_at_point_circuit(circuit, \u0026init_trace_domain, \u0026zeta);\n    let columns_targets = ColumnsTargets {\n        challenges: \u0026[],\n        public_values,\n        local_prep_values: opt_opened_preprocessed_local_targets\n            .as_ref()\n            .map_or(\u0026[], |p| p),\n        next_prep_values: opt_opened_preprocessed_next_targets\n            .as_ref()\n            .map_or(\u0026[], |p| p),\n        local_values: opened_trace_local_targets,\n        next_values: opened_trace_next_targets,\n    };\n    let folded_constraints = air.eval_folded_circuit(circuit, \u0026sels, \u0026alpha, columns_targets);\n\n    // Verify: constraints / Z_H(zeta) == quotient(zeta)\n    let folded_mul = circuit.mul(folded_constraints, sels.inv_vanishing);\n    circuit.connect(folded_mul, quotient);\n\n    Ok(())\n}\n\n/// Generate all challenges for STARK verification.\n///\n/// This includes:\n/// - Base STARK challenges (alpha, zeta, zeta_next)\n/// - PCS-specific challenges (e.g., FRI betas, query indices)\nfn get_circuit_challenges\u003c\n    A: RecursiveAir\u003cSC::Challenge\u003e,\n    SC: StarkGenericConfig,\n    Comm: Recursive\u003c\n            SC::Challenge,\n            Input = \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Commitment,\n        \u003e + ObservableCommitment,\n    InputProof: Recursive\u003cSC::Challenge\u003e,\n    OpeningProof: Recursive\u003cSC::Challenge\u003e,\n    const RATE: usize,\n\u003e(\n    air: \u0026A,\n    config: \u0026SC,\n    proof_targets: \u0026ProofTargets\u003cSC, Comm, OpeningProof\u003e,\n    public_values: \u0026[Target],\n    preprocessed_width: usize,\n    circuit: \u0026mut CircuitBuilder\u003cSC::Challenge\u003e,\n    pcs_params: \u0026PcsVerifierParams\u003cSC, InputProof, OpeningProof, Comm\u003e,\n) -\u003e Result\u003cVec\u003cTarget\u003e, CircuitError\u003e\nwhere\n    SC::Pcs: RecursivePcs\u003c\n            SC,\n            InputProof,\n            OpeningProof,\n            Comm,\n            \u003cSC::Pcs as Pcs\u003cSC::Challenge, SC::Challenger\u003e\u003e::Domain,\n        \u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    let log_quotient_degree = A::get_log_num_quotient_chunks(\n        air,\n        preprocessed_width,\n        public_values.len(),\n        config.is_zk(),\n    );\n\n    let mut challenger = CircuitChallenger::\u003cRATE\u003e::new();\n\n    // Allocate base STARK challenges (alpha, zeta, zeta_next) using Fiat-Shamir\n    let base_challenges = StarkChallenges::allocate::\u003cSC, Comm, OpeningProof\u003e(\n        circuit,\n        \u0026mut challenger,\n        proof_targets,\n        public_values,\n        log_quotient_degree,\n    );\n\n    // Get PCS-specific challenges (FRI betas, query indices, etc.)\n    let pcs_challenges = SC::Pcs::get_challenges_circuit::\u003cRATE\u003e(\n        circuit,\n        \u0026mut challenger,\n        proof_targets,\n        \u0026proof_targets.opened_values_targets,\n        pcs_params,\n    )?;\n\n    // Return flat vector: [alpha, zeta, zeta_next, ...pcs_challenges]\n    let mut all_challenges = base_challenges.to_vec();\n    all_challenges.extend(pcs_challenges);\n    Ok(all_challenges)\n}\n\n/// Validate the shape of the proof (dimensions, lengths).\nfn validate_proof_shape\u003cA, SC: StarkGenericConfig, Comm\u003e(\n    air: \u0026A,\n    opened_values: \u0026OpenedValuesTargets\u003cSC\u003e,\n    preprocessed_width: usize,\n    preprocessed_commit: \u0026Option\u003cComm\u003e,\n    quotient_degree: usize,\n) -\u003e Result\u003c(), VerificationError\u003e\nwhere\n    A: RecursiveAir\u003cSC::Challenge\u003e,\n    SC::Challenge: PrimeCharacteristicRing,\n{\n    let air_width = A::width(air);\n\n    if preprocessed_commit.is_some() \u0026\u0026 preprocessed_width == 0 {\n        return Err(VerificationError::InvalidProofShape(\n            \"There is a preprocessed commit but no opening values provided.\".to_string(),\n        ));\n    }\n\n    if preprocessed_commit.is_none() \u0026\u0026 preprocessed_width \u003e 0 {\n        return Err(VerificationError::InvalidProofShape(\n            \"Preprocessed width is non-zero but no preprocessed commit provided.\".to_string(),\n        ));\n    }\n\n    let OpenedValuesTargets {\n        trace_local_targets: opened_trace_local,\n        trace_next_targets: opened_trace_next,\n        preprocessed_local_targets: opened_prep_local,\n        preprocessed_next_targets: opened_prep_next,\n        quotient_chunks_targets: opened_quotient_chunks,\n        random_targets: opened_random,\n        ..\n    } = opened_values;\n\n    if opened_trace_local.len() != air_width || opened_trace_next.len() != air_width {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Expected opened_trace_local and opened_trace_next to have length {}, got {} and {}\",\n            air_width,\n            opened_trace_local.len(),\n            opened_trace_next.len()\n        )));\n    }\n\n    let preprocessed_local_len = opened_prep_local.as_ref().map_or(0, |v| v.len());\n    let preprocessed_next_len = opened_prep_next.as_ref().map_or(0, |v| v.len());\n    if preprocessed_width != preprocessed_local_len || preprocessed_width != preprocessed_next_len {\n        // Verifier expects preprocessed trace while proof does not have it, or vice versa\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Expected preprocessed width {preprocessed_width} but local has length {preprocessed_local_len} and next has length {preprocessed_next_len}\"\n        )));\n    }\n\n    if opened_quotient_chunks.len() != quotient_degree {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Expected opened_quotient_chunks to have length {}, got {}\",\n            quotient_degree,\n            opened_quotient_chunks.len()\n        )));\n    }\n\n    if opened_quotient_chunks\n        .iter()\n        .any(|opened_chunk| opened_chunk.len() != SC::Challenge::DIMENSION)\n    {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Invalid quotient chunk length: expected {}\",\n            SC::Challenge::DIMENSION\n        )));\n    }\n\n    if let Some(r_comm) = \u0026opened_random\n        \u0026\u0026 r_comm.len() != SC::Challenge::DIMENSION\n    {\n        return Err(VerificationError::InvalidProofShape(format!(\n            \"Expected opened random values to have length {}, got {}\",\n            SC::Challenge::DIMENSION,\n            r_comm.len()\n        )));\n    }\n\n    Ok(())\n}\n","traces":[{"line":50,"address":[2424360,2420928,2428540],"length":1,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[2138996],"length":1,"stats":{"Line":3}},{"line":85,"address":[],"length":0,"stats":{"Line":3}},{"line":86,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[2139071],"length":1,"stats":{"Line":3}},{"line":90,"address":[2421175],"length":1,"stats":{"Line":3}},{"line":91,"address":[2421200],"length":1,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[2139130],"length":1,"stats":{"Line":3}},{"line":96,"address":[2139138],"length":1,"stats":{"Line":3}},{"line":97,"address":[2421257],"length":1,"stats":{"Line":3}},{"line":98,"address":[2139184],"length":1,"stats":{"Line":3}},{"line":99,"address":[4624263],"length":1,"stats":{"Line":3}},{"line":100,"address":[2139230],"length":1,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[4624306],"length":1,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[2146505,2139299,2146496],"length":1,"stats":{"Line":7}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[2139332],"length":1,"stats":{"Line":3}},{"line":114,"address":[2421489,2421674],"length":1,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[2139615,2139682,2139557],"length":1,"stats":{"Line":6}},{"line":120,"address":[2421747,2421807,2421941],"length":1,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[2139809],"length":1,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[2139977,2147048,2147008],"length":1,"stats":{"Line":9}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":9}},{"line":142,"address":[2140460],"length":1,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[2140709],"length":1,"stats":{"Line":3}},{"line":155,"address":[2140764],"length":1,"stats":{"Line":3}},{"line":156,"address":[4625876],"length":1,"stats":{"Line":3}},{"line":159,"address":[4625939],"length":1,"stats":{"Line":3}},{"line":160,"address":[2141134,2142285,2141028],"length":1,"stats":{"Line":0}},{"line":162,"address":[4626034,4626126],"length":1,"stats":{"Line":0}},{"line":163,"address":[4627008,4626249,4626311,4627336],"length":1,"stats":{"Line":0}},{"line":164,"address":[4626296],"length":1,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[4627365,4626016],"length":1,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":9}},{"line":173,"address":[2424479],"length":1,"stats":{"Line":3}},{"line":174,"address":[4631450,4627584,4627543,4628044,4627496],"length":1,"stats":{"Line":9}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":9}},{"line":177,"address":[2142584,2142651],"length":1,"stats":{"Line":6}},{"line":178,"address":[2142697,2142760],"length":1,"stats":{"Line":6}},{"line":183,"address":[2143309],"length":1,"stats":{"Line":3}},{"line":186,"address":[2143364,2143411],"length":1,"stats":{"Line":6}},{"line":188,"address":[2428373],"length":1,"stats":{"Line":0}},{"line":189,"address":[2143482],"length":1,"stats":{"Line":0}},{"line":192,"address":[2143459],"length":1,"stats":{"Line":3}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":194,"address":[4628643],"length":1,"stats":{"Line":3}},{"line":195,"address":[2146560,2143618,2146611],"length":1,"stats":{"Line":9}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":203,"address":[4630045],"length":1,"stats":{"Line":2}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[2144083],"length":1,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[2144142,2146264,2144233,2144192,2144748],"length":1,"stats":{"Line":6}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[2146259,2144210,2144575,2144281,2144312,2144451],"length":1,"stats":{"Line":6}},{"line":210,"address":[2144297,2144344],"length":1,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":221,"address":[],"length":0,"stats":{"Line":3}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[2426117],"length":1,"stats":{"Line":3}},{"line":224,"address":[2145121],"length":1,"stats":{"Line":3}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[4630448],"length":1,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":3}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":3}},{"line":261,"address":[2146091],"length":1,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":3}},{"line":264,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[2149680,2150513,2150561],"length":1,"stats":{"Line":3}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[4634873],"length":1,"stats":{"Line":3}},{"line":308,"address":[2431964],"length":1,"stats":{"Line":3}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[4635339],"length":1,"stats":{"Line":3}},{"line":331,"address":[2432488],"length":1,"stats":{"Line":3}},{"line":335,"address":[4632208],"length":1,"stats":{"Line":3}},{"line":346,"address":[2147226],"length":1,"stats":{"Line":3}},{"line":348,"address":[],"length":0,"stats":{"Line":5}},{"line":349,"address":[2429405],"length":1,"stats":{"Line":0}},{"line":350,"address":[4632334],"length":1,"stats":{"Line":0}},{"line":354,"address":[4632569,4632311],"length":1,"stats":{"Line":4}},{"line":355,"address":[2429652],"length":1,"stats":{"Line":0}},{"line":356,"address":[4632581],"length":1,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[2147392],"length":1,"stats":{"Line":3}},{"line":362,"address":[2429496],"length":1,"stats":{"Line":3}},{"line":363,"address":[],"length":0,"stats":{"Line":3}},{"line":364,"address":[2429536],"length":1,"stats":{"Line":3}},{"line":365,"address":[2429556],"length":1,"stats":{"Line":3}},{"line":366,"address":[4632536],"length":1,"stats":{"Line":3}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[2429591,2429739],"length":1,"stats":{"Line":6}},{"line":371,"address":[2429791],"length":1,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[2429760],"length":1,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":7}},{"line":380,"address":[4634704,4633152,4634713],"length":1,"stats":{"Line":7}},{"line":381,"address":[2430217],"length":1,"stats":{"Line":3}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[2148526],"length":1,"stats":{"Line":3}},{"line":389,"address":[2148623],"length":1,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[2430705],"length":1,"stats":{"Line":0}},{"line":396,"address":[2430687,2430640],"length":1,"stats":{"Line":6}},{"line":398,"address":[],"length":0,"stats":{"Line":9}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[2148916,2149192],"length":1,"stats":{"Line":3}},{"line":407,"address":[4634268],"length":1,"stats":{"Line":0}},{"line":409,"address":[2431352],"length":1,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":3}}],"covered":86,"coverable":171},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","air_symbolic_to_circuit.rs"],"content":"mod common;\n\nuse p3_air::{Air, BaseAir};\nuse p3_circuit::utils::{ColumnsTargets, RowSelectorsTargets};\nuse p3_circuit::{CircuitBuilder, CircuitError};\nuse p3_circuit_prover::air::{AddAir, ConstAir, MulAir, PublicAir, WitnessAir};\nuse p3_commit::ExtensionMmcs;\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::TwoAdicFriPcs;\nuse p3_matrix::dense::RowMajorMatrixView;\nuse p3_matrix::stack::VerticalPair;\nuse p3_poseidon2_air::RoundConstants;\nuse p3_poseidon2_circuit_air::Poseidon2CircuitAirBabyBearD4Width16;\nuse p3_recursion::traits::RecursiveAir;\nuse p3_recursion::types::RecursiveLagrangeSelectors;\nuse p3_uni_stark::{StarkConfig, SymbolicAirBuilder, VerifierConstraintFolder};\nuse rand::rngs::SmallRng;\nuse rand::{Rng, RngCore, SeedableRng};\n\nuse crate::common::baby_bear_params::*;\n\ntype Challenge = F;\ntype ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\ntype MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\ntype MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\nfn run_recursive\u003cA\u003e(\n    air: \u0026A,\n    preprocessed_width: usize,\n    num_public_values: usize,\n    rng: \u0026mut SmallRng,\n) -\u003e Result\u003c(), CircuitError\u003e\nwhere\n    A: BaseAir\u003cF\u003e\n        + RecursiveAir\u003cF\u003e\n        + Air\u003cSymbolicAirBuilder\u003cF\u003e\u003e\n        + for\u003c'a\u003e Air\u003cVerifierConstraintFolder\u003c'a, MyConfig\u003e\u003e,\n{\n    let width = RecursiveAir::width(air);\n\n    let mut trace_local: Vec\u003cF\u003e = (0..width).map(|_| rng.random()).collect();\n    let mut trace_next: Vec\u003cF\u003e = (0..width).map(|_| rng.random()).collect();\n    let mut preprocessed_local: Vec\u003cF\u003e = (0..preprocessed_width).map(|_| rng.random()).collect();\n    let mut preprocessed_next: Vec\u003cF\u003e = (0..preprocessed_width).map(|_| rng.random()).collect();\n    let public_values: Vec\u003cF\u003e = (0..num_public_values)\n        .map(|_| F::from_u32(rng.next_u32()))\n        .collect();\n    let selectors: [F; 3] = [rng.random(), rng.random(), rng.random()];\n    let alpha: F = rng.random();\n\n    let main = VerticalPair::new(\n        RowMajorMatrixView::new_row(\u0026trace_local),\n        RowMajorMatrixView::new_row(\u0026trace_next),\n    );\n    let preprocessed = if preprocessed_width \u003e 0 {\n        Some(VerticalPair::new(\n            RowMajorMatrixView::new_row(\u0026preprocessed_local),\n            RowMajorMatrixView::new_row(\u0026preprocessed_next),\n        ))\n    } else {\n        None\n    };\n    let mut folder: VerifierConstraintFolder\u003c'_, MyConfig\u003e = VerifierConstraintFolder {\n        main,\n        preprocessed,\n        public_values: \u0026public_values,\n        is_first_row: selectors[0],\n        is_last_row: selectors[1],\n        is_transition: selectors[2],\n        alpha,\n        accumulator: F::ZERO,\n    };\n    air.eval(\u0026mut folder);\n    let folded_value = folder.accumulator;\n\n    let mut builder = CircuitBuilder::\u003cF\u003e::new();\n    let selector_targets = [\n        builder.add_public_input(),\n        builder.add_public_input(),\n        builder.add_public_input(),\n    ];\n    let public_targets: Vec\u003c_\u003e = (0..num_public_values)\n        .map(|_| builder.add_public_input())\n        .collect();\n\n    let pre_local_targets: Vec\u003c_\u003e = (0..preprocessed_width)\n        .map(|_| builder.add_public_input())\n        .collect();\n    let pre_next_targets: Vec\u003c_\u003e = (0..preprocessed_width)\n        .map(|_| builder.add_public_input())\n        .collect();\n    let local_targets: Vec\u003c_\u003e = (0..width).map(|_| builder.add_public_input()).collect();\n    let next_targets: Vec\u003c_\u003e = (0..width).map(|_| builder.add_public_input()).collect();\n\n    let row_selectors = RowSelectorsTargets {\n        is_first_row: selector_targets[0],\n        is_last_row: selector_targets[1],\n        is_transition: selector_targets[2],\n    };\n\n    let columns = ColumnsTargets {\n        challenges: \u0026[],\n        public_values: \u0026public_targets,\n        local_prep_values: \u0026pre_local_targets,\n        next_prep_values: \u0026pre_next_targets,\n        local_values: \u0026local_targets,\n        next_values: \u0026next_targets,\n    };\n\n    let alpha_t = builder.add_const(alpha);\n    let sels = RecursiveLagrangeSelectors {\n        row_selectors,\n        inv_vanishing: builder.add_const(F::ONE),\n    };\n    let sum = air.eval_folded_circuit(\u0026mut builder, \u0026sels, \u0026alpha_t, columns);\n    let const_target = builder.add_const(folded_value);\n    builder.connect(const_target, sum);\n\n    let mut all_public_inputs = Vec::new();\n    all_public_inputs.extend_from_slice(\u0026selectors);\n    all_public_inputs.extend_from_slice(\u0026public_values);\n    all_public_inputs.append(\u0026mut preprocessed_local);\n    all_public_inputs.append(\u0026mut preprocessed_next);\n    all_public_inputs.append(\u0026mut trace_local);\n    all_public_inputs.append(\u0026mut trace_next);\n\n    let circuit = builder.build()?;\n    let mut runner = circuit.runner();\n    runner.set_public_inputs(\u0026all_public_inputs)?;\n    runner.run()?;\n\n    Ok(())\n}\n\n#[test]\nfn primitive_airs_symbolic_to_circuit() -\u003e Result\u003c(), CircuitError\u003e {\n    let mut rng = SmallRng::seed_from_u64(7);\n\n    let add_air =\n        AddAir::\u003cF, 1\u003e::new_with_preprocessed(1, 1, vec![F::ZERO, F::ONE, F::from_u64(2)]);\n    run_recursive(\u0026add_air, add_air.preprocessed_width(), 0, \u0026mut rng)?;\n\n    let mul_air = MulAir::\u003cF, 1\u003e::new_with_preprocessed(1, 1, vec![F::ONE; 3]);\n    run_recursive(\u0026mul_air, mul_air.preprocessed_width(), 0, \u0026mut rng)?;\n\n    let const_air = ConstAir::\u003cF, 1\u003e::new_with_preprocessed(1, vec![F::from_u64(3)]);\n    run_recursive(\n        \u0026const_air,\n        ConstAir::\u003cF, 1\u003e::preprocessed_width(),\n        0,\n        \u0026mut rng,\n    )?;\n\n    let public_air = PublicAir::\u003cF, 1\u003e::new_with_preprocessed(1, vec![F::from_u64(4)]);\n    run_recursive(\n        \u0026public_air,\n        PublicAir::\u003cF, 1\u003e::preprocessed_width(),\n        1,\n        \u0026mut rng,\n    )?;\n\n    let witness_air = WitnessAir::\u003cF, 1\u003e::new(1, 1);\n    run_recursive(\u0026witness_air, witness_air.preprocessed_width(), 0, \u0026mut rng)?;\n\n    Ok(())\n}\n\n#[test]\nfn poseidon2_perm_air_symbolic_to_circuit() -\u003e Result\u003c(), CircuitError\u003e {\n    let mut rng = SmallRng::seed_from_u64(9);\n\n    let constants = RoundConstants::new(rng.random(), rng.random(), rng.random());\n    let preprocessed_width = Poseidon2CircuitAirBabyBearD4Width16::preprocessed_width();\n    let preprocessed_values: Vec\u003cF\u003e = (0..preprocessed_width).map(|_| rng.random()).collect();\n    let air =\n        Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(constants, preprocessed_values);\n\n    run_recursive(\u0026air, preprocessed_width, 0, \u0026mut rng)\n}\n","traces":[{"line":27,"address":[1915342,1901232,1910816,1915600,1920368,1920126,1896464,1900990,1905774,1910800,1915584,1924910,1901248,1906016,1920384,1910558,1906032,1925152],"length":1,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":18}},{"line":42,"address":[],"length":0,"stats":{"Line":24}},{"line":43,"address":[],"length":0,"stats":{"Line":24}},{"line":44,"address":[1911286,1926096,1926560,1926750,1926640,1920918,1926654,1906502,1925424,1927134,1920854,1926574,1916070,1926736,1901718,1901782,1896934,1927120,1926110,1896998,1925438,1906566,1916134,1911350],"length":1,"stats":{"Line":24}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[1921181,1906829,1902045,1897261,1911613,1916397],"length":1,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[1902143,1906927,1916495,1921279,1897359,1911711],"length":1,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":6}},{"line":57,"address":[],"length":0,"stats":{"Line":12}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":6}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":12}},{"line":78,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":8}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":18}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":18}},{"line":92,"address":[],"length":0,"stats":{"Line":24}},{"line":93,"address":[],"length":0,"stats":{"Line":24}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[1903436,1917788,1922572,1908220,1913004,1898652],"length":1,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[1908284,1913068,1917852,1898716,1903500,1922636],"length":1,"stats":{"Line":6}},{"line":104,"address":[1903607,1913175,1908391,1917959,1898823,1922743],"length":1,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":107,"address":[],"length":0,"stats":{"Line":6}},{"line":110,"address":[1918370,1923154,1899234,1913586,1904018,1908802],"length":1,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":115,"address":[1923293,1918509,1904157,1899373,1908941,1913725],"length":1,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[1918595,1899459,1909027,1923379,1904243,1913811],"length":1,"stats":{"Line":6}},{"line":119,"address":[],"length":0,"stats":{"Line":6}},{"line":120,"address":[1923426,1913858,1904290,1909074,1918642,1899506],"length":1,"stats":{"Line":6}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[1918805,1923589,1904453,1899669,1909237,1914021],"length":1,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":12}},{"line":129,"address":[],"length":0,"stats":{"Line":12}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":6}}],"covered":56,"coverable":62},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","common","mod.rs"],"content":"#![allow(unused)]\n\nuse itertools::Itertools;\nuse p3_air::{Air, AirBuilder, BaseAir, PairBuilder};\nuse p3_challenger::DuplexChallenger;\nuse p3_commit::ExtensionMmcs;\nuse p3_dft::Radix2DitParallel;\nuse p3_field::extension::BinomialExtensionField;\nuse p3_field::{Field, PrimeCharacteristicRing};\nuse p3_fri::TwoAdicFriPcs;\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_merkle_tree::MerkleTreeMmcs;\nuse p3_recursion::pcs::{\n    FriProofTargets, InputProofTargets, RecExtensionValMmcs, RecValMmcs, Witness,\n};\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\nuse p3_uni_stark::{StarkConfig, StarkGenericConfig, Val};\nuse rand::distr::{Distribution, StandardUniform};\nuse rand::rngs::SmallRng;\nuse rand::{Rng, SeedableRng};\n\n// Type of the `OpeningProof` used in the circuit for a `TwoAdicFriPcs`.\npub(crate) type InnerFriGeneric\u003cMyConfig, MyHash, MyCompress, const DIGEST_ELEMS: usize\u003e =\n    FriProofTargets\u003c\n        Val\u003cMyConfig\u003e,\n        \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n        RecExtensionValMmcs\u003c\n            Val\u003cMyConfig\u003e,\n            \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n            DIGEST_ELEMS,\n            RecValMmcs\u003cVal\u003cMyConfig\u003e, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n        \u003e,\n        InputProofTargets\u003c\n            Val\u003cMyConfig\u003e,\n            \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n            RecValMmcs\u003cVal\u003cMyConfig\u003e, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n        \u003e,\n        Witness\u003cVal\u003cMyConfig\u003e\u003e,\n    \u003e;\n\n/// Common parameters for the BabyBear field.\npub(crate) mod baby_bear_params {\n    pub(crate) use p3_baby_bear::{BabyBear, Poseidon2BabyBear};\n\n    use super::*;\n\n    pub(crate) type F = BabyBear;\n    pub(crate) const D: usize = 4;\n    pub(crate) const RATE: usize = 8;\n    pub(crate) const DIGEST_ELEMS: usize = 8;\n    pub(crate) type Challenge = BinomialExtensionField\u003cF, D\u003e;\n    pub(crate) type Dft = Radix2DitParallel\u003cF\u003e;\n    pub(crate) type Perm = Poseidon2BabyBear\u003c16\u003e;\n    pub(crate) type MyHash = PaddingFreeSponge\u003cPerm, 16, RATE, 8\u003e;\n    pub(crate) type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n    pub(crate) type ValMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n    pub(crate) type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n    pub(crate) type Challenger = DuplexChallenger\u003cF, Perm, 16, RATE\u003e;\n    pub(crate) type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n    pub(crate) type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n    pub(crate) type InnerFri = InnerFriGeneric\u003cMyConfig, MyHash, MyCompress, DIGEST_ELEMS\u003e;\n}\n\n/// Common parameters for the KoalaBear field.\npub(crate) mod koala_bear_params {\n    pub(crate) use p3_koala_bear::{KoalaBear, Poseidon2KoalaBear};\n\n    use super::*;\n\n    pub(crate) type F = KoalaBear;\n    pub(crate) const D: usize = 4;\n    pub(crate) const RATE: usize = 8;\n    pub(crate) const DIGEST_ELEMS: usize = 8;\n\n    pub(crate) type Challenge = BinomialExtensionField\u003cF, D\u003e;\n    pub(crate) type Dft = Radix2DitParallel\u003cF\u003e;\n    pub(crate) type Perm = Poseidon2KoalaBear\u003c16\u003e;\n    pub(crate) type MyHash = PaddingFreeSponge\u003cPerm, 16, RATE, 8\u003e;\n    pub(crate) type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\n    pub(crate) type ValMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\n    pub(crate) type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n    pub(crate) type Challenger = DuplexChallenger\u003cF, Perm, 16, RATE\u003e;\n    pub(crate) type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n    pub(crate) type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n    pub(crate) type InnerFri = InnerFriGeneric\u003cMyConfig, MyHash, MyCompress, DIGEST_ELEMS\u003e;\n}\n\n/// Common parameters for the Goldilocks field.\npub(crate) mod goldilocks_params {\n    pub(crate) use p3_goldilocks::{Goldilocks, Poseidon2Goldilocks};\n\n    use super::*;\n\n    pub(crate) type F = Goldilocks;\n    pub(crate) const D: usize = 2;\n    pub(crate) const RATE: usize = 4;\n    pub(crate) const DIGEST_ELEMS: usize = 4;\n\n    pub(crate) type Challenge = BinomialExtensionField\u003cF, D\u003e;\n    pub(crate) type Dft = Radix2DitParallel\u003cF\u003e;\n    pub(crate) type Perm = Poseidon2Goldilocks\u003c8\u003e;\n    pub(crate) type MyHash = PaddingFreeSponge\u003cPerm, 8, RATE, 4\u003e;\n    pub(crate) type MyCompress = TruncatedPermutation\u003cPerm, 2, 4, 8\u003e;\n    pub(crate) type ValMmcs =\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 4\u003e;\n    pub(crate) type ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\n    pub(crate) type Challenger = DuplexChallenger\u003cF, Perm, 8, RATE\u003e;\n    pub(crate) type MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\n    pub(crate) type MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n    pub(crate) type InnerFri = super::InnerFriGeneric\u003cMyConfig, MyHash, MyCompress, DIGEST_ELEMS\u003e;\n}\n\n/// A test AIR that enforces multiplication constraints: `a^(degree-1) * b = c`\n///\n/// # Constraints\n/// For each of REPETITIONS triples `(a, b, c)`:\n/// 1. Multiplication: `a^(degree-1) * b = c`\n/// 2. First row: `a^2 + 1 = b`\n/// 3. Transition: `a' = a + REPETITIONS` (where `a'` is next row's `a`)\n///\n/// # Trace Layout\n/// The trace has TRACE_WIDTH = REPETITIONS * 3 columns:\n/// `[a_0, b_0, c_0, a_1, b_1, c_1, ..., a_19, b_19, c_19]`\n#[derive(Clone, Copy)]\npub(crate) struct MulAir {\n    /// Degree of the polynomial constraint `(a^(degree-1) * b = c)`\n    pub(crate) degree: u64,\n    pub(crate) rows: usize,\n}\n\nimpl Default for MulAir {\n    fn default() -\u003e Self {\n        Self {\n            degree: 3,\n            rows: 1 \u003c\u003c 3,\n        }\n    }\n}\n\n/// Number of repetitions of the multiplication constraint (must be \u003c 255 to fit in u8)\npub(crate) const REPETITIONS: usize = 20;\n\n/// Total trace width: 3 columns per repetition (a, b, c)\npub(crate) const MAIN_TRACE_WIDTH: usize = REPETITIONS; // For c values\npub(crate) const PREP_WIDTH: usize = REPETITIONS * 2; // For a and b values\n\nimpl MulAir {\n    /// Generate a random valid (or invalid) trace for testing. The trace consists of a main trace and a preprocessed trace.\n    ///\n    /// # Parameters\n    /// - `rows`: Number of rows in the trace\n    /// - `valid`: If true, generates a valid trace; if false, makes it invalid\n    pub fn random_valid_trace\u003cVal: Field\u003e(\n        \u0026self,\n        valid: bool,\n    ) -\u003e (RowMajorMatrix\u003cVal\u003e, RowMajorMatrix\u003cVal\u003e)\n    where\n        StandardUniform: Distribution\u003cVal\u003e,\n    {\n        let mut rng = SmallRng::seed_from_u64(1);\n        let mut main_trace_values = Val::zero_vec(self.rows * MAIN_TRACE_WIDTH);\n        let mut prep_trace_values = Val::zero_vec(self.rows * PREP_WIDTH);\n\n        for (i, (a, b)) in prep_trace_values.iter_mut().tuples().enumerate() {\n            let row = i / REPETITIONS;\n            *a = Val::from_usize(i);\n\n            // First row: b = a^2 + 1\n            // Other rows: random b\n            *b = if row == 0 {\n                a.square() + Val::ONE\n            } else {\n                rng.random()\n            };\n\n            // Compute c = a^(degree-1) * b\n            main_trace_values[i] = a.exp_u64(self.degree - 1) * *b;\n\n            if !valid {\n                // Make the trace invalid by corrupting c\n                main_trace_values[i] *= Val::TWO;\n            }\n        }\n\n        (\n            RowMajorMatrix::new(main_trace_values, MAIN_TRACE_WIDTH),\n            RowMajorMatrix::new(prep_trace_values, PREP_WIDTH),\n        )\n    }\n}\n\nimpl\u003cVal: Field\u003e BaseAir\u003cVal\u003e for MulAir\nwhere\n    StandardUniform: Distribution\u003cVal\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        MAIN_TRACE_WIDTH\n    }\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003e\u003e {\n        Some(self.random_valid_trace(true).1)\n    }\n}\n\nimpl\u003cAB: PairBuilder\u003e Air\u003cAB\u003e for MulAir\nwhere\n    AB::F: Field,\n    StandardUniform: Distribution\u003cAB::F\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let main_local = main.row_slice(0).expect(\"Matrix is empty?\");\n\n        let preprocessed = builder.preprocessed();\n        let preprocessed_local = preprocessed\n            .row_slice(0)\n            .expect(\"Preprocessed matrix is empty?\");\n        let preprocessed_next = preprocessed\n            .row_slice(1)\n            .expect(\"Preprocessed matrix only has 1 row?\");\n\n        for i in 0..REPETITIONS {\n            let prep_start = i * 2;\n            let a = preprocessed_local[prep_start].clone();\n            let b = preprocessed_local[prep_start + 1].clone();\n            let c = main_local[i].clone();\n\n            // Constraint 1: a^(degree-1) * b = c\n            builder.assert_zero(a.clone().into().exp_u64(self.degree - 1) * b.clone() - c);\n\n            // Constraint 2: On first row, b = a^2 + 1\n            builder\n                .when_first_row()\n                .assert_eq(a.clone() * a.clone() + AB::Expr::ONE, b);\n\n            // Constraint 3: On transition rows, a' = a + REPETITIONS\n            let next_a = preprocessed_next[prep_start].clone();\n            builder\n                .when_transition()\n                .assert_eq(a + AB::Expr::from_u8(REPETITIONS as u8), next_a);\n        }\n    }\n}\n","traces":[{"line":138,"address":[2221680],"length":1,"stats":{"Line":0}},{"line":159,"address":[2106657,2105712,2107054],"length":1,"stats":{"Line":2}},{"line":166,"address":[2105769],"length":1,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[2105923,2105873,2105991],"length":1,"stats":{"Line":6}},{"line":170,"address":[2106007,2106072],"length":1,"stats":{"Line":4}},{"line":171,"address":[2106678,2106341],"length":1,"stats":{"Line":4}},{"line":172,"address":[2106701],"length":1,"stats":{"Line":2}},{"line":176,"address":[2106728,2106813],"length":1,"stats":{"Line":4}},{"line":177,"address":[2106739,2106778],"length":1,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[2106972],"length":1,"stats":{"Line":2}},{"line":187,"address":[2106985],"length":1,"stats":{"Line":0}},{"line":192,"address":[2192202],"length":1,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[2191504,2191488],"length":1,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[2191344],"length":1,"stats":{"Line":2}},{"line":206,"address":[2193970],"length":1,"stats":{"Line":2}},{"line":215,"address":[2185824,2191039,2190990,2183647,2185975,2193759,2188336,2191056,2183504,2193710],"length":1,"stats":{"Line":9}},{"line":216,"address":[],"length":0,"stats":{"Line":9}},{"line":217,"address":[2183682,2188464,2185952,2183640,2186026,2191184,2191263,2188543],"length":1,"stats":{"Line":18}},{"line":219,"address":[],"length":0,"stats":{"Line":9}},{"line":220,"address":[],"length":0,"stats":{"Line":6}},{"line":223,"address":[2188966,2186436,2191686],"length":1,"stats":{"Line":6}},{"line":227,"address":[2180880,2183575,2184361,2179044,2181641,2181574,2184294,2176610,2176031,2178367,2174284,2176534,2179123,2174214,2186295],"length":1,"stats":{"Line":27}},{"line":228,"address":[],"length":0,"stats":{"Line":18}},{"line":229,"address":[],"length":0,"stats":{"Line":18}},{"line":230,"address":[],"length":0,"stats":{"Line":18}},{"line":231,"address":[],"length":0,"stats":{"Line":18}},{"line":234,"address":[],"length":0,"stats":{"Line":18}},{"line":237,"address":[],"length":0,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":9}},{"line":242,"address":[],"length":0,"stats":{"Line":9}},{"line":243,"address":[],"length":0,"stats":{"Line":3}},{"line":245,"address":[],"length":0,"stats":{"Line":9}}],"covered":34,"coverable":37},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","fibonacci.rs"],"content":"mod common;\n\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::test_utils::{FibonacciAir, generate_trace_rows};\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::create_test_fri_params;\nuse p3_recursion::pcs::fri::{FriVerifierParams, HashTargets, InputProofTargets, RecValMmcs};\nuse p3_recursion::public_inputs::StarkVerifierInputsBuilder;\nuse p3_recursion::{VerificationError, generate_challenges, verify_circuit};\nuse p3_uni_stark::{prove, verify};\nuse rand::SeedableRng;\nuse rand::rngs::SmallRng;\n\nuse crate::common::baby_bear_params::*;\n\n#[test]\nfn test_fibonacci_verifier() -\u003e Result\u003c(), VerificationError\u003e {\n    let mut rng = SmallRng::seed_from_u64(1);\n    let n = 1 \u003c\u003c 3;\n    let x = 21;\n\n    let perm = Perm::new_from_rng_128(\u0026mut rng);\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n    let trace = generate_trace_rows::\u003cF\u003e(0, 1, n);\n    let log_final_poly_len = 0;\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params);\n    let log_height_max = fri_params.log_final_poly_len + fri_params.log_blowup;\n    let pow_bits = fri_params.proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::new(perm);\n\n    let config = MyConfig::new(pcs, challenger);\n    let pis = vec![BabyBear::ZERO, BabyBear::ONE, BabyBear::from_u64(x)];\n\n    let air = FibonacciAir {};\n    let proof = prove(\u0026config, \u0026air, trace, \u0026pis);\n    assert!(verify(\u0026config, \u0026air, \u0026proof, \u0026pis).is_ok());\n\n    let mut circuit_builder = CircuitBuilder::new();\n\n    // Allocate all targets\n    let verifier_inputs = StarkVerifierInputsBuilder::\u003c\n        MyConfig,\n        HashTargets\u003cF, DIGEST_ELEMS\u003e,\n        InnerFri,\n    \u003e::allocate(\u0026mut circuit_builder, \u0026proof, None, pis.len());\n\n    // Add the verification circuit to the builder.\n    verify_circuit::\u003c\n        FibonacciAir,\n        MyConfig,\n        HashTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        RATE,\n    \u003e(\n        \u0026config,\n        \u0026air,\n        \u0026mut circuit_builder,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        \u0026None,\n        \u0026fri_verifier_params,\n    )?;\n\n    // Build the circuit.\n    let circuit = circuit_builder.build()?;\n\n    let mut runner = circuit.runner();\n\n    // Generate all the challenge values.\n    let all_challenges = generate_challenges(\n        \u0026air,\n        \u0026config,\n        \u0026proof,\n        \u0026pis,\n        Some(\u0026[pow_bits, log_height_max]),\n    )?;\n\n    // Pack values using the same builder\n    let num_queries = proof.opening_proof.query_proofs.len();\n    let public_inputs =\n        verifier_inputs.pack_values(\u0026pis, \u0026proof, \u0026None, \u0026all_challenges, num_queries);\n\n    runner\n        .set_public_inputs(\u0026public_inputs)\n        .map_err(VerificationError::Circuit)?;\n\n    let _traces = runner.run().map_err(VerificationError::Circuit)?;\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","fibonacci_batch_stark_prover.rs"],"content":"mod common;\n\nuse p3_air::{Air, BaseAir, PairBuilder};\nuse p3_batch_stark::CommonData;\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit_prover::air::{AddAir, ConstAir, MulAir, PublicAir, WitnessAir};\nuse p3_circuit_prover::batch_stark_prover::PrimitiveTable;\nuse p3_circuit_prover::common::get_airs_and_degrees_with_prep;\nuse p3_circuit_prover::{BatchStarkProver, TablePacking};\nuse p3_field::{Field, PrimeCharacteristicRing};\nuse p3_fri::create_test_fri_params;\nuse p3_recursion::generation::generate_batch_challenges;\nuse p3_recursion::pcs::fri::{FriVerifierParams, HashTargets, InputProofTargets, RecValMmcs};\nuse p3_recursion::verifier::verify_p3_recursion_proof_circuit;\nuse rand::SeedableRng;\nuse rand::rngs::SmallRng;\n\nuse crate::common::baby_bear_params::*;\n\n/// Wrapper enum for heterogeneous circuit table AIRs\nenum CircuitTableAir\u003cF: Field, const D: usize\u003e {\n    Witness(WitnessAir\u003cF, D\u003e),\n    Const(ConstAir\u003cF, D\u003e),\n    Public(PublicAir\u003cF, D\u003e),\n    Add(AddAir\u003cF, D\u003e),\n    Mul(MulAir\u003cF, D\u003e),\n}\n\nimpl\u003cF: Field, const D: usize\u003e BaseAir\u003cF\u003e for CircuitTableAir\u003cF, D\u003e {\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::Witness(a) =\u003e a.width(),\n            Self::Const(a) =\u003e a.width(),\n            Self::Public(a) =\u003e a.width(),\n            Self::Add(a) =\u003e a.width(),\n            Self::Mul(a) =\u003e a.width(),\n        }\n    }\n}\n\nimpl\u003cAB, const D: usize\u003e Air\u003cAB\u003e for CircuitTableAir\u003cAB::F, D\u003e\nwhere\n    AB: PairBuilder,\n    AB::F: Field,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        match self {\n            Self::Witness(a) =\u003e a.eval(builder),\n            Self::Const(a) =\u003e a.eval(builder),\n            Self::Public(a) =\u003e a.eval(builder),\n            Self::Add(a) =\u003e a.eval(builder),\n            Self::Mul(a) =\u003e a.eval(builder),\n        }\n    }\n}\n\n#[test]\nfn test_fibonacci_batch_verifier() {\n    let n: usize = 100;\n\n    let mut builder = CircuitBuilder::new();\n\n    // Public input: expected F(n)\n    let expected_result = builder.alloc_public_input(\"expected_result\");\n\n    // Compute F(n) iteratively\n    let mut a = builder.alloc_const(F::ZERO, \"F(0)\");\n    let mut b = builder.alloc_const(F::ONE, \"F(1)\");\n\n    for _i in 2..=n {\n        let next = builder.add(a, b);\n        a = b;\n        b = next;\n    }\n\n    // Assert computed F(n) equals expected result\n    builder.connect(b, expected_result);\n\n    builder.dump_allocation_log();\n\n    let table_packing = TablePacking::new(1, 4, 1);\n\n    let circuit = builder.build().unwrap();\n    let airs_degrees =\n        get_airs_and_degrees_with_prep::\u003c_, _, 1\u003e(\u0026circuit, table_packing, None).unwrap();\n    let (airs, degrees): (Vec\u003c_\u003e, Vec\u003cusize\u003e) = airs_degrees.into_iter().unzip();\n    let mut runner = circuit.runner();\n\n    // Set public input\n    let expected_fib = compute_fibonacci_classical(n);\n    runner.set_public_inputs(\u0026[expected_fib]).unwrap();\n\n    let traces = runner.run().unwrap();\n\n    // Use a seeded RNG for deterministic permutations\n    let mut rng = SmallRng::seed_from_u64(42);\n    let perm = Perm::new_from_rng_128(\u0026mut rng);\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n\n    // Create test FRI params with log_final_poly_len = 0\n    let fri_params = create_test_fri_params(challenge_mmcs, 0);\n\n    // Create config for proving\n    let pcs_proving = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger_proving = Challenger::new(perm);\n    let config_proving = MyConfig::new(pcs_proving, challenger_proving);\n\n    // Create common data for proving and verifying.\n    let common = CommonData::from_airs_and_degrees(\u0026config_proving, \u0026airs, \u0026degrees);\n\n    let prover = BatchStarkProver::new(config_proving).with_table_packing(table_packing);\n    let batch_stark_proof = prover.prove_all_tables(\u0026traces, \u0026common).unwrap();\n    prover\n        .verify_all_tables(\u0026batch_stark_proof, \u0026common)\n        .unwrap();\n\n    // Now verify the batch STARK proof recursively\n    let dft2 = Dft::default();\n    let mut rng2 = SmallRng::seed_from_u64(42);\n    let perm2 = Perm::new_from_rng_128(\u0026mut rng2);\n    let hash2 = MyHash::new(perm2.clone());\n    let compress2 = MyCompress::new(perm2.clone());\n    let val_mmcs2 = ValMmcs::new(hash2, compress2);\n    let challenge_mmcs2 = ChallengeMmcs::new(val_mmcs2.clone());\n    let fri_params2 = create_test_fri_params(challenge_mmcs2, 0);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params2);\n    let pow_bits = fri_params2.proof_of_work_bits;\n    let log_height_max = fri_params2.log_final_poly_len + fri_params2.log_blowup;\n    let pcs_verif = MyPcs::new(dft2, val_mmcs2, fri_params2);\n    let challenger_verif = Challenger::new(perm2);\n    let config = MyConfig::new(pcs_verif, challenger_verif);\n\n    // Extract proof components\n    let batch_proof = \u0026batch_stark_proof.proof;\n    let rows = batch_stark_proof.rows;\n    let packing = batch_stark_proof.table_packing;\n\n    const TRACE_D: usize = 1; // Proof traces are in base field\n\n    // Base field AIRs for native challenge generation\n    let native_airs = vec![\n        CircuitTableAir::Witness(WitnessAir::\u003cF, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Witness],\n            packing.witness_lanes(),\n        )),\n        CircuitTableAir::Const(ConstAir::\u003cF, TRACE_D\u003e::new(rows[PrimitiveTable::Const])),\n        CircuitTableAir::Public(PublicAir::\u003cF, TRACE_D\u003e::new(rows[PrimitiveTable::Public])),\n        CircuitTableAir::Add(AddAir::\u003cF, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Add],\n            packing.add_lanes(),\n        )),\n        CircuitTableAir::Mul(MulAir::\u003cF, TRACE_D\u003e::new(\n            rows[PrimitiveTable::Mul],\n            packing.mul_lanes(),\n        )),\n    ];\n\n    // Public values (empty for all 5 circuit tables, using base field)\n    let pis: Vec\u003cVec\u003cF\u003e\u003e = vec![vec![]; 5];\n\n    // Build the recursive verification circuit\n    let mut circuit_builder = CircuitBuilder::new();\n\n    // Attach verifier without manually building circuit_airs\n    let verifier_inputs = verify_p3_recursion_proof_circuit::\u003c\n        MyConfig,\n        HashTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        RATE,\n        TRACE_D,\n    \u003e(\n        \u0026config,\n        \u0026mut circuit_builder,\n        \u0026batch_stark_proof,\n        \u0026fri_verifier_params,\n        \u0026common,\n    )\n    .unwrap();\n\n    // Build the circuit\n    let verification_circuit = circuit_builder.build().unwrap();\n    let expected_public_input_len = verification_circuit.public_flat_len;\n\n    // Generate all the challenge values for batch proof (uses base field AIRs)\n    let all_challenges = generate_batch_challenges(\n        \u0026native_airs,\n        \u0026config,\n        batch_proof,\n        \u0026pis,\n        Some(\u0026[pow_bits, log_height_max]),\n        \u0026common,\n    )\n    .unwrap();\n\n    // Pack values using the builder\n    let public_inputs = verifier_inputs.pack_values(\u0026pis, batch_proof, \u0026common, \u0026all_challenges);\n\n    assert_eq!(public_inputs.len(), expected_public_input_len);\n    assert!(!public_inputs.is_empty());\n\n    // Actually run the circuit to ensure constraints are satisfiable\n    let mut runner = verification_circuit.runner();\n    runner.set_public_inputs(\u0026public_inputs).unwrap();\n    let _traces = runner.run().unwrap();\n}\n\nfn compute_fibonacci_classical(n: usize) -\u003e F {\n    if n == 0 {\n        return F::ZERO;\n    }\n    if n == 1 {\n        return F::ONE;\n    }\n\n    let mut a = F::ZERO;\n    let mut b = F::ONE;\n\n    for _i in 2..=n {\n        let next = a + b;\n        a = b;\n        b = next;\n    }\n\n    b\n}\n","traces":[{"line":30,"address":[2299488],"length":1,"stats":{"Line":1}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":212,"address":[2402320],"length":1,"stats":{"Line":1}},{"line":213,"address":[2402336],"length":1,"stats":{"Line":1}},{"line":214,"address":[2402342],"length":1,"stats":{"Line":0}},{"line":216,"address":[2402356],"length":1,"stats":{"Line":1}},{"line":217,"address":[2402376],"length":1,"stats":{"Line":0}},{"line":220,"address":[2402390],"length":1,"stats":{"Line":1}},{"line":221,"address":[2402398],"length":1,"stats":{"Line":1}},{"line":223,"address":[2402542,2402406],"length":1,"stats":{"Line":2}},{"line":224,"address":[2402510],"length":1,"stats":{"Line":1}},{"line":225,"address":[2402530],"length":1,"stats":{"Line":1}},{"line":226,"address":[2402538],"length":1,"stats":{"Line":1}},{"line":229,"address":[2402544],"length":1,"stats":{"Line":1}}],"covered":24,"coverable":26},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","fri.rs"],"content":"mod common;\n\nuse p3_baby_bear::default_babybear_poseidon2_16;\nuse p3_challenger::{CanObserve, CanSampleBits, FieldChallenger, GrindingChallenger};\nuse p3_circuit::CircuitBuilder;\nuse p3_commit::Pcs;\nuse p3_dft::Radix2DitParallel as Dft;\nuse p3_field::coset::TwoAdicMultiplicativeCoset;\nuse p3_field::{Field, PrimeCharacteristicRing};\nuse p3_fri::create_test_fri_params;\nuse p3_matrix::dense::RowMajorMatrix;\n// Recursive target graph pieces\nuse p3_recursion::Recursive;\nuse p3_recursion::pcs::fri::{\n    FriProofTargets, InputProofTargets, RecExtensionValMmcs, RecValMmcs, Witness as RecWitness,\n};\nuse p3_recursion::public_inputs::{CommitmentOpening, FriVerifierInputs};\nuse rand::SeedableRng;\nuse rand::rngs::SmallRng;\n\nuse crate::common::baby_bear_params::*;\n\ntype RecVal = RecValMmcs\u003cF, 8, MyHash, MyCompress\u003e;\ntype RecExt = RecExtensionValMmcs\u003cF, Challenge, 8, RecVal\u003e;\n\n// Bring the circuit we're testing.\nuse p3_recursion::pcs::fri::verify_fri_circuit;\n\n/// Alias for FriProofTargets used for lens/value extraction and allocation\ntype FriTargets =\n    FriProofTargets\u003cF, Challenge, RecExt, InputProofTargets\u003cF, Challenge, RecVal\u003e, RecWitness\u003cF\u003e\u003e;\n\n/// Type alias for commitments with opening points structure\ntype CommitmentsWithPoints = Vec\u003c(\n    Challenge,\n    Vec\u003c(\n        TwoAdicMultiplicativeCoset\u003cF\u003e,\n        Vec\u003c(Challenge, Vec\u003cChallenge\u003e)\u003e,\n    )\u003e,\n)\u003e;\n\n/// Helper: build one group's evaluation matrices for a given seed and sizes.\nfn make_evals(\n    polynomial_log_sizes: \u0026[u8],\n    seed: u64,\n) -\u003e Vec\u003c(TwoAdicMultiplicativeCoset\u003cF\u003e, RowMajorMatrix\u003cF\u003e)\u003e {\n    let mut rng = SmallRng::seed_from_u64(seed);\n    polynomial_log_sizes\n        .iter()\n        .map(|\u0026deg_bits| {\n            let rows = 1usize \u003c\u003c deg_bits;\n            let domain = TwoAdicMultiplicativeCoset::new(F::GENERATOR, deg_bits as usize)\n                .expect(\"valid two-adic size\");\n\n            // Ensure width \u003e= 1 to avoid zero-width matrices for small degrees.\n            let width = core::cmp::max(1, (deg_bits as usize).saturating_sub(4));\n\n            (\n                domain,\n                RowMajorMatrix::\u003cF\u003e::rand_nonzero(\u0026mut rng, rows, width),\n            )\n        })\n        .collect()\n}\n\n/// Holds all the public inputs and challenges required for a recursive FRI verification circuit.\nstruct ProduceInputsResult {\n    /// FRI values, ordered to match the structure required by `FriProofTargets`.\n    fri_values: Vec\u003cChallenge\u003e,\n    /// The `alpha` challenge used for batching polynomial commitments.\n    alpha: Challenge,\n    /// The `beta` challenges, one for each FRI folding phase.\n    betas: Vec\u003cChallenge\u003e,\n    /// The query indices, represented as little-endian bits, for each query.\n    index_bits_per_query: Vec\u003cVec\u003cChallenge\u003e\u003e,\n    /// Commitments with opening points structure (per batch)\n    commitments_with_points: CommitmentsWithPoints,\n    /// The total number of FRI folding phases (rounds).\n    num_phases: usize,\n    /// The log base 2 of the size of the largest domain.\n    log_max_height: usize,\n    /// The FRI proof\n    fri_proof: \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::Proof,\n}\n\n/// Produce all public inputs for a recursive FRI verification circuit over **multiple input batches**.\n///\n/// `group_sizes` is a list of groups, each group is a list of log2 degrees.\nfn produce_inputs_multi(\n    pcs: \u0026MyPcs,\n    perm: \u0026Perm,\n    log_blowup: usize,\n    log_final_poly_len: usize,\n    pow_bits: usize,\n    group_sizes: \u0026[Vec\u003cu8\u003e],\n    seed_base: u64,\n) -\u003e ProduceInputsResult {\n    // Build per-group evals and commit\n    let mut groups_evals = Vec::new();\n    for (i, sizes) in group_sizes.iter().enumerate() {\n        groups_evals.push(make_evals(sizes, seed_base + i as u64));\n    }\n\n    // Flatten domain sizes (base log sizes) for public inputs\n    let mut domains_log_sizes = Vec::new();\n    for sizes in group_sizes {\n        domains_log_sizes.extend(sizes.iter().map(|\u0026b| b as usize));\n    }\n    let val_sizes: Vec\u003cF\u003e = domains_log_sizes\n        .iter()\n        .map(|\u0026b| F::from_u8(b as u8))\n        .collect();\n\n    // --- Prover path ---\n    let mut p_challenger = Challenger::new(perm.clone());\n    p_challenger.observe_slice(\u0026val_sizes);\n\n    // Commit each group and observe all commitments before sampling zeta\n    let mut commitments_and_data = Vec::new();\n    for evals in \u0026groups_evals {\n        let (commitment, prover_data) =\n            \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::commit(pcs, evals.clone());\n        p_challenger.observe(commitment);\n        commitments_and_data.push((commitment, prover_data));\n    }\n\n    // Single zeta for all matrices across all groups\n    let zeta: Challenge = p_challenger.sample_algebra_element();\n\n    // Build open request: one (\u0026ProverData, points_per_matrix) per group\n    let mut open_data = Vec::new();\n    for (i, _evals) in groups_evals.iter().enumerate() {\n        let mat_count = groups_evals[i].len();\n        open_data.push((\u0026commitments_and_data[i].1, vec![vec![zeta]; mat_count]));\n    }\n\n    // Open and produce FRI proof\n    let (opened_values, fri_proof) =\n        \u003cMyPcs as Pcs\u003cChallenge, Challenger\u003e\u003e::open(pcs, open_data, \u0026mut p_challenger);\n\n    // --- Verifier transcript replay (to derive the public inputs) ---\n    let mut v_challenger = Challenger::new(perm.clone());\n    v_challenger.observe_slice(\u0026val_sizes);\n    for (commitment, _) in \u0026commitments_and_data {\n        v_challenger.observe(*commitment);\n    }\n    let _zeta_v: Challenge = v_challenger.sample_algebra_element();\n\n    // Flatten opened values in the same order we passed to `open`\n    // Shape: OpenedValues -\u003e groups -\u003e matrices -\u003e columns\n    let point_values_flat: Vec\u003cVec\u003cChallenge\u003e\u003e =\n        opened_values.into_iter().flatten().flatten().collect();\n\n    // Extract proof pieces\n    let p3_fri::FriProof {\n        commit_phase_commits,\n        ref query_proofs,\n        final_poly,\n        pow_witness,\n    } = fri_proof.clone();\n\n    // Observe all opened evaluation values (same order)\n    for values in \u0026point_values_flat {\n        for \u0026opening in values {\n            v_challenger.observe_algebra_element(opening);\n        }\n    }\n\n    // α (batch combiner)\n    let alpha: Challenge = v_challenger.sample_algebra_element();\n\n    // β_i per phase: observe commitment, then sample β\n    let mut betas: Vec\u003cChallenge\u003e = Vec::with_capacity(commit_phase_commits.len());\n    for c in \u0026commit_phase_commits {\n        v_challenger.observe(*c);\n        betas.push(v_challenger.sample_algebra_element());\n    }\n\n    // Final poly coeffs (constant here)\n    for \u0026c in \u0026final_poly {\n        v_challenger.observe_algebra_element(c);\n    }\n\n    // PoW check\n    assert!(v_challenger.check_witness(pow_bits, pow_witness));\n\n    // Query indices\n    let num_phases = commit_phase_commits.len();\n    let log_max_height = num_phases + log_blowup + log_final_poly_len;\n    let num_queries = query_proofs.len();\n    let mut indices: Vec\u003cusize\u003e = Vec::with_capacity(num_queries);\n    for _ in 0..num_queries {\n        indices.push(v_challenger.sample_bits(log_max_height));\n    }\n\n    // Index bits per query (LE)\n    let mut index_bits_per_query: Vec\u003cVec\u003cChallenge\u003e\u003e = Vec::with_capacity(num_queries);\n    for \u0026index in \u0026indices {\n        let mut bits_one = Vec::with_capacity(log_max_height);\n        for k in 0..log_max_height {\n            bits_one.push(if (index \u003e\u003e k) \u0026 1 == 1 {\n                Challenge::ONE\n            } else {\n                Challenge::ZERO\n            });\n        }\n        index_bits_per_query.push(bits_one);\n    }\n\n    // Build commitments_with_points structure\n    // For each batch: (commitment_placeholder, Vec\u003c(domain, Vec\u003c(z, [f(z)])\u003e)\u003e)\n    let mut commitments_with_points = Vec::new();\n    let mut pv_idx = 0;\n    for sizes in group_sizes.iter() {\n        let mut mats_data = Vec::new();\n        for \u0026log_size in sizes {\n            let domain = TwoAdicMultiplicativeCoset::new(F::GENERATOR, log_size as usize)\n                .expect(\"valid domain\");\n            let points_and_values = vec![(zeta, point_values_flat[pv_idx].clone())];\n            mats_data.push((domain, points_and_values));\n            pv_idx += 1;\n        }\n        // Use a placeholder value for the commitment (not used in arithmetic verification)\n        let commit_placeholder = Challenge::ZERO;\n        commitments_with_points.push((commit_placeholder, mats_data));\n    }\n\n    // —— FriProofTargets values ——\n\n    let fri_values: Vec\u003cChallenge\u003e = FriTargets::get_values(\u0026p3_fri::FriProof {\n        commit_phase_commits,\n        query_proofs: query_proofs.clone(),\n        final_poly,\n        pow_witness,\n    });\n\n    ProduceInputsResult {\n        fri_values,\n        alpha,\n        betas,\n        index_bits_per_query,\n        commitments_with_points,\n        num_phases,\n        log_max_height,\n        fri_proof,\n    }\n}\n\n/// Linearize public inputs in the exact order allocated by the circuit builder.\nfn pack_inputs(\n    fri_vals: Vec\u003cChallenge\u003e,\n    alpha: Challenge,\n    betas: Vec\u003cChallenge\u003e,\n    index_bits_all_queries: Vec\u003cVec\u003cChallenge\u003e\u003e,\n    commitments_with_points: CommitmentsWithPoints,\n) -\u003e Vec\u003cChallenge\u003e {\n    let commitment_openings = commitments_with_points\n        .into_iter()\n        .map(|(commitment, mats)| {\n            let mut opened_points = Vec::new();\n            for (_domain, points_and_values) in mats {\n                for (z, fz) in points_and_values {\n                    opened_points.push((z, fz));\n                }\n            }\n            CommitmentOpening {\n                commitment,\n                opened_points,\n            }\n        })\n        .collect();\n\n    FriVerifierInputs {\n        fri_proof_values: fri_vals,\n        alpha,\n        betas,\n        query_index_bits: index_bits_all_queries,\n        commitment_openings,\n    }\n    .build()\n}\n\n/// Holds all the FRI parameters and group sizes to generate test inputs.\nstruct FriSetup {\n    pcs: MyPcs,\n    perm: Perm,\n    log_blowup: usize,\n    log_final_poly_len: usize,\n    pow_bits: usize,\n    group_sizes: Vec\u003cVec\u003cu8\u003e\u003e,\n}\n\nimpl FriSetup {\n    const fn new(\n        pcs: MyPcs,\n        perm: Perm,\n        log_blowup: usize,\n        log_final_poly_len: usize,\n        pow_bits: usize,\n        group_sizes: Vec\u003cVec\u003cu8\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            pcs,\n            perm,\n            log_blowup,\n            log_final_poly_len,\n            pow_bits,\n            group_sizes,\n        }\n    }\n}\n\nfn generate_setup(log_final_poly_len: usize, group_sizes: Vec\u003cVec\u003cu8\u003e\u003e) -\u003e FriSetup {\n    // Common setup\n    let perm = default_babybear_poseidon2_16();\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::\u003cF\u003e::default();\n\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let log_blowup = fri_params.log_blowup;\n    let log_final_poly_len = fri_params.log_final_poly_len;\n    let pow_bits = fri_params.proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n\n    FriSetup::new(\n        pcs,\n        perm,\n        log_blowup,\n        log_final_poly_len,\n        pow_bits,\n        group_sizes,\n    )\n}\n\nfn run_fri_test(setup: FriSetup, build_only: bool) {\n    let FriSetup {\n        pcs,\n        perm,\n        log_blowup,\n        log_final_poly_len,\n        pow_bits,\n        group_sizes,\n    } = setup;\n\n    // Produce two proofs with different inputs (same shape), to reuse one circuit\n    let result_1 = produce_inputs_multi(\n        \u0026pcs,\n        \u0026perm,\n        log_blowup,\n        log_final_poly_len,\n        pow_bits,\n        \u0026group_sizes,\n        /*seed_base=*/ 0,\n    );\n\n    let result_2 = produce_inputs_multi(\n        \u0026pcs,\n        \u0026perm,\n        log_blowup,\n        log_final_poly_len,\n        pow_bits,\n        \u0026group_sizes,\n        /*seed_base=*/ 1,\n    );\n\n    // Shape checks (must match so we can reuse one circuit)\n    assert_eq!(result_1.num_phases, result_2.num_phases);\n    assert_eq!(result_1.log_max_height, result_2.log_max_height);\n\n    let num_phases = result_1.num_phases;\n    let log_max_height = result_1.log_max_height;\n    let expected_final_poly_len = 1 \u003c\u003c log_final_poly_len;\n\n    // ——— Build circuit once (using first proof's shape) ———\n    let mut builder = CircuitBuilder::\u003cChallenge\u003e::new();\n\n    // 1) Allocate FriProofTargets using instance 1\n    let fri_targets = FriTargets::new(\u0026mut builder, \u0026result_1.fri_proof);\n\n    // Verify the final polynomial has the expected length\n    assert_eq!(\n        fri_targets.final_poly.len(),\n        expected_final_poly_len,\n        \"Circuit final polynomial should have {expected_final_poly_len} coefficients\"\n    );\n\n    // 2) Public inputs for α, βs, index bits\n    let alpha_t = builder.add_public_input();\n    let betas_t: Vec\u003c_\u003e = (0..num_phases)\n        .map(|_| builder.add_public_input())\n        .collect();\n\n    let num_queries = result_1.index_bits_per_query.len();\n    let index_bits_t_per_query: Vec\u003cVec\u003c_\u003e\u003e = (0..num_queries)\n        .map(|_| {\n            (0..log_max_height)\n                .map(|_| builder.add_public_input())\n                .collect()\n        })\n        .collect();\n\n    builder.push_scope(\"commitments_with_opening_points\");\n\n    // 3) Build commitments_with_opening_points targets structure\n    // For each batch: allocate commitment target + (domain, Vec\u003c(z_target, [fz_targets])\u003e)\n    let mut commitments_with_opening_points_targets = Vec::new();\n    for (_commit_val, mats_data) in \u0026result_1.commitments_with_points {\n        // Allocate commitment target (placeholder, not used in arithmetic verification)\n        let commit_t = builder.add_public_input();\n\n        let mut mats_targets = Vec::new();\n        for (domain, points_and_values) in mats_data {\n            let mut pv_targets = Vec::new();\n            for (_z, fz) in points_and_values {\n                let z_t = builder.add_public_input();\n                let fz_t: Vec\u003c_\u003e = (0..fz.len()).map(|_| builder.add_public_input()).collect();\n                pv_targets.push((z_t, fz_t));\n            }\n            mats_targets.push((*domain, pv_targets));\n        }\n        commitments_with_opening_points_targets.push((commit_t, mats_targets));\n    }\n    builder.pop_scope();\n\n    // 4) Wire the arithmetic-only FRI verifier\n    verify_fri_circuit::\u003cF, Challenge, RecExt, RecVal, RecWitness\u003cF\u003e, p3_recursion::Target\u003e(\n        \u0026mut builder,\n        \u0026fri_targets,\n        alpha_t,\n        \u0026betas_t,\n        \u0026index_bits_t_per_query,\n        \u0026commitments_with_opening_points_targets,\n        log_blowup,\n    )\n    .unwrap();\n\n    builder.dump_allocation_log();\n    let circuit = builder.build().unwrap();\n\n    if build_only {\n        return;\n    }\n\n    // ---- Run instance 1 ----\n    let pub_inputs1 = pack_inputs(\n        result_1.fri_values,\n        result_1.alpha,\n        result_1.betas,\n        result_1.index_bits_per_query.clone(),\n        result_1.commitments_with_points,\n    );\n    let mut runner1 = circuit.clone().runner();\n    runner1.set_public_inputs(\u0026pub_inputs1).unwrap();\n    runner1.run().unwrap();\n\n    // ---- Run instance 2 ----\n    let pub_inputs2 = pack_inputs(\n        result_2.fri_values,\n        result_2.alpha,\n        result_2.betas,\n        result_2.index_bits_per_query.clone(),\n        result_2.commitments_with_points,\n    );\n    let mut runner2 = circuit.runner();\n    runner2.set_public_inputs(\u0026pub_inputs2).unwrap();\n    runner2.run().unwrap();\n}\n\n#[test]\nfn test_circuit_fri_verifier_degree_0_final_poly() {\n    // Three \"rounds\"/batches of inputs, different shapes. Include a degree-0 (height=1)\n    // matrix so the `log_height == log_blowup` reduced-opening constraint is exercised.\n    //   [0, 5, 8, 8, 10], [8, 11], [4, 5, 8]\n    let groups = vec![vec![0u8, 5, 8, 8, 10], vec![8u8, 11], vec![4u8, 5, 8]];\n\n    let setup = generate_setup(0, groups);\n\n    run_fri_test(setup, false);\n}\n\n#[test]\nfn test_circuit_fri_verifier_degree_1_final_poly() {\n    // Use smaller matrices to ensure we actually get a higher-degree final polynomial\n    // For a final polynomial of degree 1, we need `log_max_height` small enough\n    let groups = vec![vec![3u8, 4], vec![5u8]];\n\n    let setup = generate_setup(1, groups);\n\n    run_fri_test(setup, false);\n}\n\n#[test]\nfn test_circuit_fri_verifier_degree_3_final_poly() {\n    // Small matrices to get higher-degree final polynomial\n    let groups = vec![vec![4u8], vec![5u8]];\n\n    let setup = generate_setup(2, groups);\n\n    run_fri_test(setup, false);\n}\n\n#[test]\nfn test_circuit_fri_verifier_scoped_builder() {\n    let groups = vec![vec![0u8, 5, 8, 8, 10], vec![8u8, 11], vec![4u8, 5, 8]];\n    let setup = generate_setup(0, groups);\n    run_fri_test(setup, true);\n}\n","traces":[{"line":43,"address":[2476528],"length":1,"stats":{"Line":4}},{"line":47,"address":[2476578],"length":1,"stats":{"Line":4}},{"line":50,"address":[2476607,2476688,2476656],"length":1,"stats":{"Line":12}},{"line":51,"address":[2476701,2476935],"length":1,"stats":{"Line":4}},{"line":52,"address":[2476744],"length":1,"stats":{"Line":4}},{"line":53,"address":[2476764],"length":1,"stats":{"Line":4}},{"line":56,"address":[2476802],"length":1,"stats":{"Line":4}},{"line":60,"address":[2476851],"length":1,"stats":{"Line":4}},{"line":89,"address":[2485808,2491412,2494143],"length":1,"stats":{"Line":4}},{"line":99,"address":[2486034],"length":1,"stats":{"Line":4}},{"line":100,"address":[2486135,2486222],"length":1,"stats":{"Line":8}},{"line":101,"address":[2494042,2486434],"length":1,"stats":{"Line":8}},{"line":105,"address":[2486464],"length":1,"stats":{"Line":4}},{"line":106,"address":[2486499,2486582],"length":1,"stats":{"Line":8}},{"line":107,"address":[2486684,2494208,2493948,2494218],"length":1,"stats":{"Line":16}},{"line":109,"address":[2486722],"length":1,"stats":{"Line":4}},{"line":111,"address":[2494160,2486804,2494173],"length":1,"stats":{"Line":12}},{"line":115,"address":[2486866,2486945],"length":1,"stats":{"Line":8}},{"line":116,"address":[2487044,2486960],"length":1,"stats":{"Line":8}},{"line":119,"address":[2487059],"length":1,"stats":{"Line":4}},{"line":120,"address":[2487153,2487074,2493909],"length":1,"stats":{"Line":9}},{"line":121,"address":[2493558],"length":1,"stats":{"Line":1}},{"line":123,"address":[2493646],"length":1,"stats":{"Line":1}},{"line":124,"address":[2493742],"length":1,"stats":{"Line":1}},{"line":128,"address":[2487289],"length":1,"stats":{"Line":2}},{"line":131,"address":[2487304],"length":1,"stats":{"Line":2}},{"line":132,"address":[2487311,2487407],"length":1,"stats":{"Line":4}},{"line":133,"address":[2493203,2487666],"length":1,"stats":{"Line":4}},{"line":134,"address":[2493236],"length":1,"stats":{"Line":2}},{"line":138,"address":[2487786],"length":1,"stats":{"Line":2}},{"line":142,"address":[2487914,2487990],"length":1,"stats":{"Line":4}},{"line":143,"address":[2488005,2488089],"length":1,"stats":{"Line":4}},{"line":144,"address":[2488104],"length":1,"stats":{"Line":2}},{"line":145,"address":[2493142,2488245],"length":1,"stats":{"Line":4}},{"line":147,"address":[2488310],"length":1,"stats":{"Line":2}},{"line":151,"address":[2488317],"length":1,"stats":{"Line":2}},{"line":155,"address":[2488465],"length":1,"stats":{"Line":2}},{"line":156,"address":[2488512],"length":1,"stats":{"Line":2}},{"line":157,"address":[2488552],"length":1,"stats":{"Line":2}},{"line":158,"address":[2488576],"length":1,"stats":{"Line":2}},{"line":159,"address":[2488616],"length":1,"stats":{"Line":2}},{"line":163,"address":[2488645,2488725],"length":1,"stats":{"Line":4}},{"line":164,"address":[2488827,2492938],"length":1,"stats":{"Line":4}},{"line":165,"address":[2493041],"length":1,"stats":{"Line":2}},{"line":170,"address":[2488869],"length":1,"stats":{"Line":2}},{"line":173,"address":[2488884],"length":1,"stats":{"Line":2}},{"line":174,"address":[2488938,2489018],"length":1,"stats":{"Line":4}},{"line":175,"address":[2489120],"length":1,"stats":{"Line":2}},{"line":176,"address":[2492869],"length":1,"stats":{"Line":2}},{"line":180,"address":[2489177],"length":1,"stats":{"Line":2}},{"line":181,"address":[2489321,2492848],"length":1,"stats":{"Line":4}},{"line":185,"address":[2489386],"length":1,"stats":{"Line":2}},{"line":188,"address":[2489451],"length":1,"stats":{"Line":2}},{"line":189,"address":[2489605,2489492],"length":1,"stats":{"Line":2}},{"line":190,"address":[2489590,2489634],"length":1,"stats":{"Line":4}},{"line":191,"address":[2489650],"length":1,"stats":{"Line":2}},{"line":192,"address":[2489665,2489756],"length":1,"stats":{"Line":4}},{"line":193,"address":[2492824,2489831],"length":1,"stats":{"Line":4}},{"line":197,"address":[2489865],"length":1,"stats":{"Line":2}},{"line":198,"address":[2492650,2489880,2489959],"length":1,"stats":{"Line":6}},{"line":199,"address":[2492381,2490092],"length":1,"stats":{"Line":4}},{"line":200,"address":[2492389,2492465],"length":1,"stats":{"Line":4}},{"line":201,"address":[2492738,2492786,2492668,2492571],"length":1,"stats":{"Line":8}},{"line":202,"address":[2492708],"length":1,"stats":{"Line":2}},{"line":204,"address":[2492740],"length":1,"stats":{"Line":2}},{"line":207,"address":[2492579],"length":1,"stats":{"Line":2}},{"line":212,"address":[2490110],"length":1,"stats":{"Line":2}},{"line":213,"address":[2490133],"length":1,"stats":{"Line":2}},{"line":214,"address":[2490145,2490224,2491779],"length":1,"stats":{"Line":6}},{"line":215,"address":[2490381],"length":1,"stats":{"Line":2}},{"line":216,"address":[2491426,2491514,2492324],"length":1,"stats":{"Line":6}},{"line":217,"address":[2491639],"length":1,"stats":{"Line":2}},{"line":219,"address":[2492350,2491836],"length":1,"stats":{"Line":2}},{"line":220,"address":[2492209],"length":1,"stats":{"Line":2}},{"line":221,"address":[2492280,2492329],"length":1,"stats":{"Line":2}},{"line":224,"address":[2486023],"length":1,"stats":{"Line":4}},{"line":225,"address":[2491649],"length":1,"stats":{"Line":2}},{"line":230,"address":[2490541],"length":1,"stats":{"Line":2}},{"line":231,"address":[2490399],"length":1,"stats":{"Line":2}},{"line":232,"address":[2490447],"length":1,"stats":{"Line":2}},{"line":233,"address":[2490501],"length":1,"stats":{"Line":2}},{"line":250,"address":[2477445,2476960,2477475],"length":1,"stats":{"Line":2}},{"line":257,"address":[2477009],"length":1,"stats":{"Line":2}},{"line":259,"address":[2478363,2477120,2477504,2477528],"length":1,"stats":{"Line":6}},{"line":260,"address":[2477575],"length":1,"stats":{"Line":2}},{"line":261,"address":[2477623,2477705,2477817],"length":1,"stats":{"Line":6}},{"line":262,"address":[2478060,2477918,2478187],"length":1,"stats":{"Line":5}},{"line":263,"address":[2478358,2478272],"length":1,"stats":{"Line":2}},{"line":266,"address":[2477991],"length":1,"stats":{"Line":1}},{"line":268,"address":[2477952],"length":1,"stats":{"Line":1}},{"line":294,"address":[2496832],"length":1,"stats":{"Line":4}},{"line":313,"address":[2485699,2485778,2484544],"length":1,"stats":{"Line":4}},{"line":315,"address":[2484579],"length":1,"stats":{"Line":4}},{"line":316,"address":[2484778,2484692],"length":1,"stats":{"Line":8}},{"line":317,"address":[2484793,2484855],"length":1,"stats":{"Line":8}},{"line":318,"address":[2484882],"length":1,"stats":{"Line":4}},{"line":319,"address":[2485025,2485089],"length":1,"stats":{"Line":8}},{"line":320,"address":[2485112],"length":1,"stats":{"Line":4}},{"line":322,"address":[2485157],"length":1,"stats":{"Line":4}},{"line":323,"address":[2485274],"length":1,"stats":{"Line":4}},{"line":324,"address":[2485295],"length":1,"stats":{"Line":4}},{"line":325,"address":[2485316],"length":1,"stats":{"Line":4}},{"line":326,"address":[2485337],"length":1,"stats":{"Line":4}},{"line":330,"address":[2485481],"length":1,"stats":{"Line":4}},{"line":334,"address":[2485560],"length":1,"stats":{"Line":4}},{"line":338,"address":[2484349,2478400,2482825],"length":1,"stats":{"Line":4}},{"line":339,"address":[2478451],"length":1,"stats":{"Line":4}},{"line":340,"address":[2478599],"length":1,"stats":{"Line":4}},{"line":341,"address":[2478609],"length":1,"stats":{"Line":4}},{"line":342,"address":[2478684],"length":1,"stats":{"Line":4}},{"line":343,"address":[2478707],"length":1,"stats":{"Line":4}},{"line":344,"address":[2478730],"length":1,"stats":{"Line":4}},{"line":345,"address":[2478753],"length":1,"stats":{"Line":4}},{"line":355,"address":[2478791],"length":1,"stats":{"Line":4}},{"line":365,"address":[2478975],"length":1,"stats":{"Line":2}},{"line":370,"address":[2479152],"length":1,"stats":{"Line":1}},{"line":371,"address":[2479435,2479295],"length":1,"stats":{"Line":1}},{"line":373,"address":[2479491],"length":1,"stats":{"Line":1}},{"line":374,"address":[2479515],"length":1,"stats":{"Line":1}},{"line":375,"address":[2479531,2479578],"length":1,"stats":{"Line":1}},{"line":378,"address":[2479571],"length":1,"stats":{"Line":1}},{"line":381,"address":[2479599],"length":1,"stats":{"Line":1}},{"line":384,"address":[2479755,2479873],"length":1,"stats":{"Line":1}},{"line":391,"address":[2479856,2480033],"length":1,"stats":{"Line":2}},{"line":393,"address":[2484368,2484382,2480060],"length":1,"stats":{"Line":3}},{"line":396,"address":[2480165,2480090],"length":1,"stats":{"Line":2}},{"line":398,"address":[2480201,2484400],"length":1,"stats":{"Line":2}},{"line":399,"address":[2484423],"length":1,"stats":{"Line":1}},{"line":400,"address":[2484429,2484512,2484526],"length":1,"stats":{"Line":3}},{"line":401,"address":[2484451],"length":1,"stats":{"Line":1}},{"line":405,"address":[2480231],"length":1,"stats":{"Line":1}},{"line":409,"address":[2480310],"length":1,"stats":{"Line":1}},{"line":410,"address":[2483572,2480317,2480401],"length":1,"stats":{"Line":4}},{"line":412,"address":[2480539,2483202],"length":1,"stats":{"Line":4}},{"line":414,"address":[2483217],"length":1,"stats":{"Line":2}},{"line":415,"address":[2483232,2483314,2483936],"length":1,"stats":{"Line":5}},{"line":416,"address":[2483448],"length":1,"stats":{"Line":2}},{"line":417,"address":[2483582,2483658],"length":1,"stats":{"Line":4}},{"line":418,"address":[2483787,2483950],"length":1,"stats":{"Line":2}},{"line":419,"address":[2483957,2484480,2484494],"length":1,"stats":{"Line":3}},{"line":420,"address":[2484028],"length":1,"stats":{"Line":1}},{"line":422,"address":[2483806],"length":1,"stats":{"Line":1}},{"line":424,"address":[2483462],"length":1,"stats":{"Line":1}},{"line":426,"address":[2480564],"length":1,"stats":{"Line":1}},{"line":433,"address":[2480579],"length":1,"stats":{"Line":1}},{"line":434,"address":[2480634],"length":1,"stats":{"Line":1}},{"line":435,"address":[2480709],"length":1,"stats":{"Line":1}},{"line":440,"address":[2480878],"length":1,"stats":{"Line":1}},{"line":441,"address":[2480885],"length":1,"stats":{"Line":1}},{"line":443,"address":[2480999],"length":1,"stats":{"Line":2}},{"line":449,"address":[2481007],"length":1,"stats":{"Line":2}},{"line":450,"address":[2481055],"length":1,"stats":{"Line":2}},{"line":451,"address":[2481071],"length":1,"stats":{"Line":2}},{"line":452,"address":[2481119],"length":1,"stats":{"Line":1}},{"line":453,"address":[2481201],"length":1,"stats":{"Line":2}},{"line":455,"address":[2481407,2481344],"length":1,"stats":{"Line":2}},{"line":456,"address":[2481523,2481430],"length":1,"stats":{"Line":2}},{"line":457,"address":[2481552],"length":1,"stats":{"Line":2}},{"line":461,"address":[2481666],"length":1,"stats":{"Line":2}},{"line":462,"address":[2481714],"length":1,"stats":{"Line":2}},{"line":463,"address":[2481730],"length":1,"stats":{"Line":2}},{"line":464,"address":[2481778],"length":1,"stats":{"Line":2}},{"line":465,"address":[2481842],"length":1,"stats":{"Line":2}},{"line":467,"address":[2481969,2482078],"length":1,"stats":{"Line":4}},{"line":468,"address":[2482187,2482094],"length":1,"stats":{"Line":3}},{"line":469,"address":[2482216],"length":1,"stats":{"Line":1}}],"covered":166,"coverable":166},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","mul_air.rs"],"content":"//! Test for recursive STARK verification with a multiplication AIR.\n\nmod common;\n\nuse p3_circuit::CircuitBuilder;\nuse p3_fri::create_test_fri_params;\nuse p3_matrix::Matrix;\nuse p3_recursion::pcs::fri::{FriVerifierParams, HashTargets};\nuse p3_recursion::public_inputs::StarkVerifierInputsBuilder;\nuse p3_recursion::{VerificationError, generate_challenges, verify_circuit};\nuse p3_uni_stark::{prove_with_preprocessed, setup_preprocessed, verify_with_preprocessed};\nuse p3_util::log2_ceil_usize;\nuse rand::SeedableRng;\nuse rand::rngs::SmallRng;\n\nuse crate::common::MulAir;\nuse crate::common::baby_bear_params::{\n    ChallengeMmcs, Challenger, DIGEST_ELEMS, Dft, F, InnerFri, MyCompress, MyConfig, MyHash, MyPcs,\n    Perm, RATE, ValMmcs,\n};\n\n#[test]\nfn test_mul_verifier_circuit() -\u003e Result\u003c(), VerificationError\u003e {\n    let mut rng = SmallRng::seed_from_u64(1);\n    let n = 1 \u003c\u003c 3;\n\n    let perm = Perm::new_from_rng_128(\u0026mut rng);\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n\n    let log_final_poly_len = 0;\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params);\n    let log_height_max = fri_params.log_final_poly_len + fri_params.log_blowup;\n    let pow_bits = fri_params.proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::new(perm);\n\n    let config = MyConfig::new(pcs, challenger);\n    let pis = vec![];\n\n    // Create AIR and generate valid trace\n    let air = MulAir { degree: 2, rows: n };\n    let (trace, _) = air.random_valid_trace(true);\n\n    // Setup preprocessed data\n    let (preprocessed_prover_data, preprocessed_vk) =\n        setup_preprocessed(\u0026config, \u0026air, log2_ceil_usize(trace.height())).unzip();\n    // Generate and verify proof\n    let proof = prove_with_preprocessed(\n        \u0026config,\n        \u0026air,\n        trace,\n        \u0026pis,\n        preprocessed_prover_data.as_ref(),\n    );\n    assert!(\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026pis, preprocessed_vk.as_ref()).is_ok()\n    );\n\n    let mut circuit_builder = CircuitBuilder::new();\n\n    // Allocate all targets\n    let verifier_inputs =\n        StarkVerifierInputsBuilder::\u003cMyConfig, HashTargets\u003cF, DIGEST_ELEMS\u003e, InnerFri\u003e::allocate(\n            \u0026mut circuit_builder,\n            \u0026proof,\n            preprocessed_vk.as_ref().map(|vk| \u0026vk.commitment),\n            pis.len(),\n        );\n\n    // Add the verification circuit to the builder\n    verify_circuit::\u003c_, _, _, _, _, RATE\u003e(\n        \u0026config,\n        \u0026air,\n        \u0026mut circuit_builder,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        \u0026verifier_inputs.preprocessed_commit,\n        \u0026fri_verifier_params,\n    )?;\n\n    // Build the circuit\n    let circuit = circuit_builder.build()?;\n\n    let mut runner = circuit.runner();\n    // Generate all the challenge values\n    let all_challenges = generate_challenges(\n        \u0026air,\n        \u0026config,\n        \u0026proof,\n        \u0026pis,\n        Some(\u0026[pow_bits, log_height_max]),\n    )?;\n\n    // Pack values using the same builder\n    let num_queries = proof.opening_proof.query_proofs.len();\n    let public_inputs = verifier_inputs.pack_values(\n        \u0026pis,\n        \u0026proof,\n        \u0026preprocessed_vk.map(|vk| vk.commitment),\n        \u0026all_challenges,\n        num_queries,\n    );\n\n    runner\n        .set_public_inputs(\u0026public_inputs)\n        .map_err(VerificationError::Circuit)?;\n\n    let _traces = runner.run().map_err(VerificationError::Circuit)?;\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","poseidon_perm.rs"],"content":"mod common;\n\nuse p3_baby_bear::{BabyBear as F, Poseidon2BabyBear};\nuse p3_circuit::CircuitBuilder;\nuse p3_circuit::tables::Poseidon2CircuitRow;\nuse p3_commit::ExtensionMmcs;\nuse p3_field::PrimeCharacteristicRing;\nuse p3_fri::{TwoAdicFriPcs, create_test_fri_params};\nuse p3_poseidon2::ExternalLayerConstants;\nuse p3_poseidon2_air::RoundConstants;\nuse p3_poseidon2_circuit_air::{\n    Poseidon2CircuitAirBabyBearD4Width16, extract_preprocessed_from_operations,\n};\nuse p3_recursion::pcs::fri::{\n    FriProofTargets, FriVerifierParams, HashTargets, InputProofTargets, RecExtensionValMmcs,\n    RecValMmcs, Witness,\n};\nuse p3_recursion::public_inputs::StarkVerifierInputsBuilder;\nuse p3_recursion::{VerificationError, generate_challenges, verify_circuit};\nuse p3_uni_stark::{\n    StarkConfig, StarkGenericConfig, prove_with_preprocessed, setup_preprocessed,\n    verify_with_preprocessed,\n};\nuse rand::rngs::SmallRng;\nuse rand::{Rng, SeedableRng};\nuse tracing_forest::ForestLayer;\nuse tracing_forest::util::LevelFilter;\nuse tracing_subscriber::layer::SubscriberExt;\nuse tracing_subscriber::util::SubscriberInitExt;\nuse tracing_subscriber::{EnvFilter, Registry};\n\n/// Initializes a global logger with default parameters.\nfn init_logger() {\n    let env_filter = EnvFilter::builder()\n        .with_default_directive(LevelFilter::INFO.into())\n        .from_env_lossy();\n\n    Registry::default()\n        .with(env_filter)\n        .with(ForestLayer::default())\n        .init();\n}\n\nuse crate::common::baby_bear_params::*;\n\ntype Challenge = F;\ntype ChallengeMmcs = ExtensionMmcs\u003cF, Challenge, ValMmcs\u003e;\ntype MyPcs = TwoAdicFriPcs\u003cF, Dft, ValMmcs, ChallengeMmcs\u003e;\ntype MyConfig = StarkConfig\u003cMyPcs, Challenge, Challenger\u003e;\n\n#[test]\nfn test_poseidon2_perm_verifier() -\u003e Result\u003c(), VerificationError\u003e {\n    init_logger();\n\n    let mut rng = SmallRng::seed_from_u64(1);\n    let beginning_full_constants = rng.random();\n    let partial_constants = rng.random();\n    let ending_full_constants = rng.random();\n    let constants = RoundConstants::new(\n        beginning_full_constants,\n        partial_constants,\n        ending_full_constants,\n    );\n    let perm = Poseidon2BabyBear::\u003c16\u003e::new(\n        ExternalLayerConstants::new(\n            beginning_full_constants.to_vec(),\n            ending_full_constants.to_vec(),\n        ),\n        partial_constants.to_vec(),\n    );\n    let perm_for_trace = perm.clone();\n\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n    // Keep a small final poly length; with enough rows we still get FRI fold phases.\n    let log_final_poly_len = 0;\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params);\n    let log_height_max = fri_params.log_final_poly_len + fri_params.log_blowup;\n    let pow_bits = fri_params.proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::new(perm);\n    let config = MyConfig::new(pcs, challenger);\n\n    // Build a trace with enough rows to satisfy FRI height constraints.\n    let n_rows: usize = 32;\n    let ops: Vec\u003c_\u003e = (0..n_rows)\n        .map(|row| {\n            let input_values: Vec\u003cF\u003e = (0..16_u32)\n                .map(|i| F::from_u32(i + 5 + row as u32))\n                .collect();\n            Poseidon2CircuitRow {\n                new_start: true,\n                merkle_path: false,\n                mmcs_bit: false,\n                mmcs_index_sum: F::ZERO,\n                input_values,\n                in_ctl: [false; 4],\n                input_indices: [0; 4],\n                out_ctl: [false; 2],\n                output_indices: [0; 2],\n                mmcs_index_sum_idx: 0,\n            }\n        })\n        .collect();\n\n    let preprocessed = extract_preprocessed_from_operations(\u0026ops);\n    let air = Poseidon2CircuitAirBabyBearD4Width16::new_with_preprocessed(\n        constants.clone(),\n        preprocessed,\n    );\n\n    let (prover_data, verifier_data) = setup_preprocessed(\u0026config, \u0026air, 5).unwrap();\n\n    let trace = air.generate_trace_rows(\u0026ops, \u0026constants, 0, \u0026perm_for_trace);\n\n    let public_inputs: Vec\u003cF\u003e = vec![];\n    let proof = prove_with_preprocessed(\u0026config, \u0026air, trace, \u0026public_inputs, Some(\u0026prover_data));\n    assert!(\n        verify_with_preprocessed(\u0026config, \u0026air, \u0026proof, \u0026public_inputs, Some(\u0026verifier_data))\n            .is_ok()\n    );\n\n    type InnerFri = FriProofTargets\u003c\n        p3_uni_stark::Val\u003cMyConfig\u003e,\n        \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n        RecExtensionValMmcs\u003c\n            p3_uni_stark::Val\u003cMyConfig\u003e,\n            \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n            DIGEST_ELEMS,\n            RecValMmcs\u003cp3_uni_stark::Val\u003cMyConfig\u003e, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n        \u003e,\n        InputProofTargets\u003c\n            p3_uni_stark::Val\u003cMyConfig\u003e,\n            \u003cMyConfig as StarkGenericConfig\u003e::Challenge,\n            RecValMmcs\u003cp3_uni_stark::Val\u003cMyConfig\u003e, DIGEST_ELEMS, MyHash, MyCompress\u003e,\n        \u003e,\n        Witness\u003cp3_uni_stark::Val\u003cMyConfig\u003e\u003e,\n    \u003e;\n\n    let mut circuit_builder = CircuitBuilder::new();\n    let verifier_inputs =\n        StarkVerifierInputsBuilder::\u003cMyConfig, HashTargets\u003cF, DIGEST_ELEMS\u003e, InnerFri\u003e::allocate(\n            \u0026mut circuit_builder,\n            \u0026proof,\n            Some(\u0026verifier_data.commitment),\n            public_inputs.len(),\n        );\n\n    verify_circuit::\u003c\n        Poseidon2CircuitAirBabyBearD4Width16,\n        MyConfig,\n        HashTargets\u003cF, DIGEST_ELEMS\u003e,\n        InputProofTargets\u003cF, Challenge, RecValMmcs\u003cF, DIGEST_ELEMS, MyHash, MyCompress\u003e\u003e,\n        InnerFri,\n        RATE,\n    \u003e(\n        \u0026config,\n        \u0026air,\n        \u0026mut circuit_builder,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        \u0026verifier_inputs.preprocessed_commit,\n        \u0026fri_verifier_params,\n    )?;\n\n    let circuit = circuit_builder.build()?;\n    let mut runner = circuit.runner();\n\n    let all_challenges = generate_challenges(\n        \u0026air,\n        \u0026config,\n        \u0026proof,\n        \u0026public_inputs,\n        Some(\u0026[pow_bits, log_height_max]),\n    )?;\n    let num_queries = proof.opening_proof.query_proofs.len();\n    let packed_publics = verifier_inputs.pack_values(\n        \u0026public_inputs,\n        \u0026proof,\n        \u0026Some(verifier_data.commitment),\n        \u0026all_challenges,\n        num_queries,\n    );\n\n    runner\n        .set_public_inputs(\u0026packed_publics)\n        .map_err(VerificationError::Circuit)?;\n    let _ = runner.run().map_err(VerificationError::Circuit)?;\n\n    Ok(())\n}\n","traces":[{"line":33,"address":[4206526,4206532,4205952],"length":1,"stats":{"Line":1}},{"line":34,"address":[4206110,4205989],"length":1,"stats":{"Line":2}},{"line":35,"address":[4206069,4206038,4206561,4206118],"length":1,"stats":{"Line":2}},{"line":38,"address":[4206438,4206297],"length":1,"stats":{"Line":2}},{"line":39,"address":[4206316],"length":1,"stats":{"Line":1}},{"line":40,"address":[4206401,4206390,4206516,4206462],"length":1,"stats":{"Line":2}}],"covered":6,"coverable":6},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","recursion","tests","preprocessing.rs"],"content":"mod common;\n\nuse p3_air::{Air, BaseAir, PairBuilder};\nuse p3_batch_stark::{CommonData, StarkInstance, prove_batch, verify_batch};\nuse p3_circuit::CircuitBuilder;\nuse p3_field::Field;\nuse p3_fri::create_test_fri_params;\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\nuse p3_recursion::pcs::HashTargets;\nuse p3_recursion::{\n    BatchStarkVerifierInputsBuilder, FriVerifierParams, VerificationError,\n    generate_batch_challenges, verify_batch_circuit,\n};\nuse rand::SeedableRng;\nuse rand::distr::{Distribution, StandardUniform};\nuse rand::rngs::SmallRng;\n\nuse crate::common::MulAir;\nuse crate::common::baby_bear_params::{\n    ChallengeMmcs, Challenger, DIGEST_ELEMS, Dft, F, InnerFri, MyCompress, MyConfig, MyHash, MyPcs,\n    Perm, RATE, ValMmcs,\n};\n\n/// Enum to hold different AIR types for batch verification\n#[derive(Clone, Copy)]\nenum MixedAir {\n    Mul(MulAir),               // has preprocessed columns\n    Add(AddAirNoPreprocessed), // doesn't have any preprocessed columns\n    Sub(SubAirPartialPreprocessed),\n}\n\nimpl\u003cVal: Field\u003e BaseAir\u003cVal\u003e for MixedAir\nwhere\n    StandardUniform: Distribution\u003cVal\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        match self {\n            Self::Mul(air) =\u003e BaseAir::\u003cVal\u003e::width(air),\n            Self::Add(air) =\u003e BaseAir::\u003cVal\u003e::width(air),\n            Self::Sub(air) =\u003e BaseAir::\u003cVal\u003e::width(air),\n        }\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003e\u003e {\n        match self {\n            Self::Mul(air) =\u003e BaseAir::\u003cVal\u003e::preprocessed_trace(air),\n            Self::Add(air) =\u003e BaseAir::\u003cVal\u003e::preprocessed_trace(air),\n            Self::Sub(air) =\u003e BaseAir::\u003cVal\u003e::preprocessed_trace(air),\n        }\n    }\n}\n\nimpl\u003cAB: PairBuilder\u003e Air\u003cAB\u003e for MixedAir\nwhere\n    AB::F: Field,\n    StandardUniform: Distribution\u003cAB::F\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        match self {\n            Self::Mul(air) =\u003e Air::\u003cAB\u003e::eval(air, builder),\n            Self::Add(air) =\u003e Air::\u003cAB\u003e::eval(air, builder),\n            Self::Sub(air) =\u003e Air::\u003cAB\u003e::eval(air, builder),\n        }\n    }\n}\n\n/// AIR that doesn't have preprocessed columns - simple addition of two values\n#[derive(Clone, Copy)]\npub struct AddAirNoPreprocessed {\n    rows: usize,\n}\n\nimpl Default for AddAirNoPreprocessed {\n    fn default() -\u003e Self {\n        Self { rows: 1 \u003c\u003c 3 }\n    }\n}\n\nimpl AddAirNoPreprocessed {\n    pub fn random_valid_trace\u003cVal: Field\u003e(\u0026self, valid: bool) -\u003e RowMajorMatrix\u003cVal\u003e\n    where\n        StandardUniform: Distribution\u003cVal\u003e,\n    {\n        let width = 3; // [a, b, c] columns\n        let mut main_trace_values = Val::zero_vec(self.rows * width);\n\n        for row in 0..self.rows {\n            let base_idx = row * width;\n            let a = Val::from_usize(row);\n            let b = Val::from_usize(row + 1);\n            main_trace_values[base_idx] = a;\n            main_trace_values[base_idx + 1] = b;\n\n            // c = a + b\n            main_trace_values[base_idx + 2] = if valid {\n                a + b\n            } else {\n                a + b + Val::ONE // Make invalid\n            };\n        }\n\n        RowMajorMatrix::new(main_trace_values, width)\n    }\n}\n\nimpl\u003cVal: Field\u003e BaseAir\u003cVal\u003e for AddAirNoPreprocessed\nwhere\n    StandardUniform: Distribution\u003cVal\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        3 // [a, b, c]\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003e\u003e {\n        None // No preprocessed columns\n    }\n}\n\nimpl\u003cAB: PairBuilder\u003e Air\u003cAB\u003e for AddAirNoPreprocessed\nwhere\n    AB::F: Field,\n    StandardUniform: Distribution\u003cAB::F\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let main_local = main.row_slice(0).expect(\"Matrix is empty?\");\n\n        let a = main_local[0].clone();\n        let b = main_local[1].clone();\n        let c = main_local[2].clone();\n\n        // Constraint: a + b = c\n        builder.assert_zero(a + b - c);\n    }\n}\n\n/// AIR that has some preprocessed columns - subtraction with one preprocessed constant\n#[derive(Clone, Copy)]\npub struct SubAirPartialPreprocessed {\n    rows: usize,\n}\n\nimpl Default for SubAirPartialPreprocessed {\n    fn default() -\u003e Self {\n        Self { rows: 1 \u003c\u003c 3 }\n    }\n}\n\nimpl SubAirPartialPreprocessed {\n    pub fn random_valid_trace\u003cVal: Field\u003e(\n        \u0026self,\n        valid: bool,\n    ) -\u003e (RowMajorMatrix\u003cVal\u003e, RowMajorMatrix\u003cVal\u003e)\n    where\n        StandardUniform: Distribution\u003cVal\u003e,\n    {\n        let main_width = 2; // [a, result] columns\n        let prep_width = 1; // [constant] column\n\n        let mut main_trace_values = Val::zero_vec(self.rows * main_width);\n        let mut prep_trace_values = Val::zero_vec(self.rows * prep_width);\n\n        for row in 0..self.rows {\n            let main_base_idx = row * main_width;\n            let prep_base_idx = row * prep_width;\n\n            let a = Val::from_usize(row + 10);\n            let constant = Val::from_usize(5); // Preprocessed constant\n\n            main_trace_values[main_base_idx] = a;\n            prep_trace_values[prep_base_idx] = constant;\n\n            // result = a - constant\n            main_trace_values[main_base_idx + 1] = if valid {\n                a - constant\n            } else {\n                a - constant + Val::ONE // Make invalid\n            };\n        }\n\n        (\n            RowMajorMatrix::new(main_trace_values, main_width),\n            RowMajorMatrix::new(prep_trace_values, prep_width),\n        )\n    }\n}\n\nimpl\u003cVal: Field\u003e BaseAir\u003cVal\u003e for SubAirPartialPreprocessed\nwhere\n    StandardUniform: Distribution\u003cVal\u003e,\n{\n    fn width(\u0026self) -\u003e usize {\n        2 // [a, result]\n    }\n\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cVal\u003e\u003e {\n        Some(self.random_valid_trace(true).1)\n    }\n}\n\nimpl\u003cAB: PairBuilder\u003e Air\u003cAB\u003e for SubAirPartialPreprocessed\nwhere\n    AB::F: Field,\n    StandardUniform: Distribution\u003cAB::F\u003e,\n{\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let main_local = main.row_slice(0).expect(\"Matrix is empty?\");\n\n        let preprocessed = builder.preprocessed();\n        let preprocessed_local = preprocessed\n            .row_slice(0)\n            .expect(\"Preprocessed matrix is empty?\");\n\n        let a = main_local[0].clone();\n        let result = main_local[1].clone();\n        let constant = preprocessed_local[0].clone();\n\n        // Constraint: a - constant = result\n        builder.assert_zero(a - constant - result);\n    }\n}\n\n#[test]\nfn test_batch_verifier_with_mixed_preprocessed() -\u003e Result\u003c(), VerificationError\u003e {\n    let mut rng = SmallRng::seed_from_u64(42);\n    let n = 1 \u003c\u003c 3;\n\n    let perm = Perm::new_from_rng_128(\u0026mut rng);\n    let hash = MyHash::new(perm.clone());\n    let compress = MyCompress::new(perm.clone());\n    let val_mmcs = ValMmcs::new(hash, compress);\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\n    let dft = Dft::default();\n\n    let log_final_poly_len = 0;\n    let fri_params = create_test_fri_params(challenge_mmcs, log_final_poly_len);\n    let fri_verifier_params = FriVerifierParams::from(\u0026fri_params);\n    let log_height_max = fri_params.log_final_poly_len + fri_params.log_blowup;\n    let pow_bits = fri_params.proof_of_work_bits;\n    let pcs = MyPcs::new(dft, val_mmcs, fri_params);\n    let challenger = Challenger::new(perm);\n\n    let config = MyConfig::new(pcs, challenger);\n\n    // Create three different AIRs with different preprocessed column configurations\n    let air1 = MulAir { degree: 2, rows: n }; // Has preprocessed columns\n    let air2 = AddAirNoPreprocessed { rows: n }; // No preprocessed columns  \n    let air3 = SubAirPartialPreprocessed { rows: n }; // Some preprocessed columns\n\n    // Generate valid traces for each AIR\n    let trace1 = air1.random_valid_trace(true).0;\n    let trace2 = air2.random_valid_trace(true);\n    let trace3 = air3.random_valid_trace(true).0;\n\n    // Each AIR has empty public inputs for this test\n    let pvs = [vec![], vec![], vec![]];\n\n    // Create MixedAir instances for batch proving\n    let mixed_air1 = MixedAir::Mul(air1);\n    let mixed_air2 = MixedAir::Add(air2);\n    let mixed_air3 = MixedAir::Sub(air3);\n\n    // Create StarkInstances for batch proving\n    let instances = vec![\n        StarkInstance {\n            air: \u0026mixed_air1,\n            trace: trace1,\n            public_values: pvs[0].clone(),\n        },\n        StarkInstance {\n            air: \u0026mixed_air2,\n            trace: trace2,\n            public_values: pvs[1].clone(),\n        },\n        StarkInstance {\n            air: \u0026mixed_air3,\n            trace: trace3,\n            public_values: pvs[2].clone(),\n        },\n    ];\n\n    let airs = [mixed_air1, mixed_air2, mixed_air3];\n\n    // Generate common data and batch proof\n    let common_data = CommonData::from_instances(\u0026config, \u0026instances);\n    let batch_proof = prove_batch(\u0026config, instances, \u0026common_data);\n    verify_batch(\u0026config, \u0026airs, \u0026batch_proof, \u0026pvs, \u0026common_data).unwrap();\n\n    // Create AIRs vector for verification circuit\n    let airs = vec![mixed_air1, mixed_air2, mixed_air3];\n\n    // The first and last AIRs have preprocessed columns, the second does not\n    assert!(BaseAir::\u003cF\u003e::preprocessed_trace(\u0026airs[0]).is_some());\n    assert!(BaseAir::\u003cF\u003e::preprocessed_trace(\u0026airs[1]).is_none());\n    assert!(BaseAir::\u003cF\u003e::preprocessed_trace(\u0026airs[2]).is_some());\n\n    let mut circuit_builder = CircuitBuilder::new();\n\n    // Allocate batch verifier inputs\n    let air_public_counts = vec![0usize; batch_proof.opened_values.instances.len()];\n    let verifier_inputs = BatchStarkVerifierInputsBuilder::\u003c\n        MyConfig,\n        HashTargets\u003cF, DIGEST_ELEMS\u003e,\n        InnerFri,\n    \u003e::allocate(\n        \u0026mut circuit_builder,\n        \u0026batch_proof,\n        \u0026common_data,\n        \u0026air_public_counts,\n    );\n\n    // Create PCS verifier params from FRI verifier params\n    let pcs_verifier_params = fri_verifier_params;\n\n    // Add the batch verification circuit to the builder for the following AIRs:\n    // 1. MulAir (has preprocessed columns)\n    // 2. AddAirNoPreprocessed (no preprocessed columns)\n    // 3. SubAirPartialPreprocessed (some preprocessed columns)\n    verify_batch_circuit::\u003c_, _, _, _, _, RATE\u003e(\n        \u0026config,\n        \u0026airs,\n        \u0026mut circuit_builder,\n        \u0026verifier_inputs.proof_targets,\n        \u0026verifier_inputs.air_public_targets,\n        \u0026pcs_verifier_params,\n        \u0026verifier_inputs.preprocessed,\n    )?;\n\n    // Build the circuit\n    let circuit = circuit_builder.build()?;\n\n    let mut runner = circuit.runner();\n\n    // Generate all the challenge values for batch proof\n    let all_challenges = generate_batch_challenges(\n        \u0026airs,\n        \u0026config,\n        \u0026batch_proof,\n        \u0026pvs,\n        Some(\u0026[pow_bits, log_height_max]),\n        \u0026common_data,\n    )?;\n\n    // Pack values using the batch builder\n    let public_inputs = verifier_inputs.pack_values(\n        \u0026pvs, // public inputs for each AIR\n        \u0026batch_proof,\n        \u0026common_data,\n        \u0026all_challenges,\n    );\n\n    runner\n        .set_public_inputs(\u0026public_inputs)\n        .map_err(VerificationError::Circuit)?;\n\n    let _traces = runner.run().map_err(VerificationError::Circuit)?;\n\n    Ok(())\n}\n","traces":[{"line":37,"address":[3124304,3124432],"length":1,"stats":{"Line":2}},{"line":38,"address":[3124317,3124445],"length":1,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[3124160],"length":1,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[3124278],"length":1,"stats":{"Line":1}},{"line":59,"address":[3117536,3117248,3117680,3117392],"length":1,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":4}},{"line":63,"address":[3117510,3117654,3117798,3117366],"length":1,"stats":{"Line":4}},{"line":81,"address":[3076099,3075200,3076131],"length":1,"stats":{"Line":1}},{"line":85,"address":[3075257],"length":1,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":89,"address":[3075664,3075683,3075542],"length":1,"stats":{"Line":2}},{"line":90,"address":[3075672,3075712],"length":1,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[3075968,3075929],"length":1,"stats":{"Line":0}},{"line":103,"address":[3075570],"length":1,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[3132296],"length":1,"stats":{"Line":1}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[3128780,3131356,3130540,3129596],"length":1,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":8}},{"line":129,"address":[3129827,3129778,3128968,3130778,3131538,3128922,3130729,3131587],"length":1,"stats":{"Line":8}},{"line":130,"address":[3129100,3130857,3129899,3130920,3131659,3129962,3131722,3129037],"length":1,"stats":{"Line":8}},{"line":131,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":151,"address":[3076144,3076955,3077448],"length":1,"stats":{"Line":1}},{"line":158,"address":[3076201],"length":1,"stats":{"Line":1}},{"line":159,"address":[3076229],"length":1,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":164,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[3077131],"length":1,"stats":{"Line":1}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[3077297,3077258],"length":1,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":8}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":3}},{"line":216,"address":[],"length":0,"stats":{"Line":8}},{"line":217,"address":[],"length":0,"stats":{"Line":8}},{"line":218,"address":[],"length":0,"stats":{"Line":8}},{"line":221,"address":[],"length":0,"stats":{"Line":4}}],"covered":65,"coverable":67},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","symmetric-air","src","lib.rs"],"content":"#![no_std]\n\npub mod sponge_air;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","symmetric-air","src","sponge_air","air.rs"],"content":"//! An AIR for a sponge construction using an arbitrary permutation on field elements.\n//!\n//! We instantiate a duplex challenger in overwrite mode: at each row, the challenger applies\n//! one permutation.\n//! Depending on the situation, the rate part of the state comes either from the input\n//! (during absorbing) or is the output of the previous row (during squeezing).\n//! When we want to clear the state, we set the `reset` flag to 1 to clear the capacity.\n//!\n//! We assume that the input is correctly padded, and that its length is a multiple of `RATE`.\n\nuse core::array;\nuse core::borrow::Borrow;\nuse core::marker::PhantomData;\n\nuse p3_air::{Air, AirBuilder, BaseAir};\nuse p3_field::{PrimeCharacteristicRing, PrimeField};\nuse p3_matrix::Matrix;\nuse p3_matrix::dense::RowMajorMatrix;\n\nuse crate::sponge_air::columns::{SpongeCols, num_cols};\n\n#[derive(Debug)]\npub struct SpongeAir\u003cF: PrimeCharacteristicRing, const RATE: usize, const CAPACITY: usize\u003e {\n    _phantom: PhantomData\u003cF\u003e,\n}\n\nimpl\u003cF, const RATE: usize, const CAPACITY: usize\u003e Default for SpongeAir\u003cF, RATE, CAPACITY\u003e\nwhere\n    F: PrimeCharacteristicRing,\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl\u003cF: PrimeCharacteristicRing, const RATE: usize, const CAPACITY: usize\u003e\n    SpongeAir\u003cF, RATE, CAPACITY\u003e\n{\n    pub const fn new() -\u003e Self {\n        Self {\n            _phantom: PhantomData,\n        }\n    }\n\n    pub fn generate_trace_rows(\u0026self) -\u003e RowMajorMatrix\u003cF\u003e\n    where\n        F: PrimeField,\n    {\n        todo!()\n    }\n}\n\nimpl\u003cF: PrimeCharacteristicRing + Sync, const RATE: usize, const CAPACITY: usize\u003e BaseAir\u003cF\u003e\n    for SpongeAir\u003cF, RATE, CAPACITY\u003e\n{\n    fn width(\u0026self) -\u003e usize {\n        num_cols::\u003cRATE, CAPACITY\u003e()\n    }\n}\n\nimpl\u003cAB: AirBuilder, const RATE: usize, const CAPACITY: usize\u003e Air\u003cAB\u003e\n    for SpongeAir\u003cAB::F, RATE, CAPACITY\u003e\n{\n    /// Correctness of state transitions is enforced outside the AIR with lookups.\n    #[inline]\n    fn eval(\u0026self, builder: \u0026mut AB) {\n        let main = builder.main();\n        let (local, next) = (\n            main.row_slice(0).expect(\"Matrix is empty?\"),\n            main.row_slice(1).expect(\"Matrix only has 1 row?\"),\n        );\n        let local: \u0026SpongeCols\u003cAB::Var, RATE, CAPACITY\u003e = (*local).borrow();\n        let _next: \u0026SpongeCols\u003cAB::Var, RATE, CAPACITY\u003e = (*next).borrow();\n\n        let _output_mode = AB::Expr::ONE - local.absorb.clone();\n\n        // When resetting the state, we just have to clear the capacity. The rate will be overwritten by the input.\n        builder\n            .when(local.reset.clone())\n            .assert_zeros::\u003cCAPACITY, _\u003e(array::from_fn(|i| local.capacity[i].clone()));\n\n        // TODO: Add all lookups:\n        // - If local.absorb = 1:\n        //      * local.rate comes from input lookups.\n        // - If local.absorb = 0:\n        //      * local.rate is sent to output lookups.\n        // - If next.absorb = 0:\n        //      * next.rate = perm(local.state).rate.\n        // - If next.reset = 0:\n        //      * next.capacity = perm(local.state).capacity.\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","symmetric-air","src","sponge_air","columns.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\nuse core::mem::size_of;\n\n/// Columns for the sponge AIR which hashes an arbitrary-length input.\n#[repr(C)]\npub struct SpongeCols\u003cT, const RATE: usize, const CAPACITY: usize\u003e {\n    // Flag to clear the capacity, which will clear the state.\n    // Preprocessed.\n    pub reset: T,\n    // When set to 1, the rate is overwritten by external input.\n    // When set to 0, the rate is copied from the previous row.\n    // Preprocessed.\n    pub absorb: T,\n\n    pub input_addresses: [T; RATE],\n\n    pub rate: [T; RATE],\n\n    pub capacity: [T; CAPACITY],\n}\n\npub const fn num_cols\u003cconst RATE: usize, const CAPACITY: usize\u003e() -\u003e usize {\n    size_of::\u003cSpongeCols\u003cu8, RATE, CAPACITY\u003e\u003e()\n}\n\nimpl\u003cT, const RATE: usize, const CAPACITY: usize\u003e Borrow\u003cSpongeCols\u003cT, RATE, CAPACITY\u003e\u003e for [T] {\n    fn borrow(\u0026self) -\u003e \u0026SpongeCols\u003cT, RATE, CAPACITY\u003e {\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cSpongeCols\u003cT, RATE, CAPACITY\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026shorts[0]\n    }\n}\n\nimpl\u003cT, const RATE: usize, const CAPACITY: usize\u003e BorrowMut\u003cSpongeCols\u003cT, RATE, CAPACITY\u003e\u003e\n    for [T]\n{\n    fn borrow_mut(\u0026mut self) -\u003e \u0026mut SpongeCols\u003cT, RATE, CAPACITY\u003e {\n        let (prefix, shorts, suffix) =\n            unsafe { self.align_to_mut::\u003cSpongeCols\u003cT, RATE, CAPACITY\u003e\u003e() };\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\n        debug_assert_eq!(shorts.len(), 1);\n        \u0026mut shorts[0]\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["/","home","runner","work","Plonky3-recursion","Plonky3-recursion","symmetric-air","src","sponge_air","mod.rs"],"content":"pub mod air;\npub mod columns;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, '🌙'),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '🌙';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '☀️';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '🌙';
    }
  });
})();
</script>
</body>
</html>